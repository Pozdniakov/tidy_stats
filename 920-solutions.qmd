# Решения заданий {#sec-solutions}

```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Задания, которые помечены звездочкой (\*) можно пропускать: это задания повышенной сложности, в них требуется подумать над решением, а не просто применить выученные инструменты.

## Начало работы в R {#sec-solution_begin}

-   Разделите 9801 на 9.

```{r}
9801/9
```

-   Посчитайте логарифм от 2176782336 по основанию 6.

```{r}
log(2176782336, 6)
```

-   Теперь натуральный логарифм 10 и умножьте его на 5.

```{r}
log(10)*5
```

-   С помощью функции `sin()` посчитайте $\sin (\pi), \sin \left(\frac{\pi}{2}\right), \sin \left(\frac{\pi}{6}\right)$.

> Значение $\pi$ - зашитая в R константа (`pi`).

```{r}
sin(pi)
sin(pi/2)
sin(pi/6)
```

## Создание векторов {#sec-solution_new_vecs}

-   Создайте вектор из значений 2, 30 и 4000.

```{r}
c(2, 30, 4000)
```

-   Создайте вектор от 1 до 20.

```{r}
1:20
```

-   Создайте вектор от 20 до 1.

```{r}
20:1
```

Функция `sum()` возвращает сумму элементов вектора на входе. Посчитайте сумму первых 100 натуральных чисел (т.е. всех целых чисел от 1 до 100).

```{r}
sum(1:100)
```

-   Создайте вектор от 1 до 20 и снова до 1. Число 20 должно присутствовать только один раз!

```{r}
c(1:20, 19:1)
```

-   Создайте вектор значений 5, 4, 3, 2, 2, 3, 4, 5:

```{r}
c(5:2, 2:5)
```

-   Создайте вектор 2, 4, 6, ... , 18, 20.

```{r}
seq(2, 20, 2)
```

-   Создайте вектор 0.1, 0.2, 0.3, ..., 0.9, 1.

```{r}
seq(0.1, 1, 0.1)
```

-   2020 год --- високосный. Следующий високосный год через 4 года --- это будет 2024 год. Составьте календарь всех високосных годов XXI века, начиная с 2020 года.

> 2100 год относится к XXI веку, а не к XXII.

```{r}
seq(2020, 2100, 4)
```

-   Создайте вектор, состоящий из 20 повторений "Хэй!".

```{r}
rep("Хэй!", 20)
```

-   Как я и говорил, многие функции, работающие с одним значением на входе, так же прекрасно работают и с целыми векторами. Попробуйте посчитать квадратный корень чисел от 1 до 10 с помощью функции `sqrt()` и сохраните результат в векторе `roots`. Выведите содержание вектора `roots` в консоль.

```{r}
roots <- sqrt(1:10)
roots
```

-   \*Создайте вектор из одной единицы, двух двоек, трех троек, .... , девяти девяток.

```{r}
rep(1:9, 1:9)
```

## Приведение типов {#sec-solution_coer}

-   Сделайте вектор `vec1`, в котором соедините `3`, а также значения `"Мой"` и `"вектор"`.

```{r}
vec1 <- c(3, "Мой", "вектор")
vec1
```

-   Попробуйте вычесть `TRUE` из 10.

```{r}
10 - TRUE
```

-   Соедините значение `10` и `TRUE` в вектор `vec2`.

```{r}
vec2 <- c(10, TRUE)
vec2
```

-   Соедините вектор `vec2` и значение `"r"`:

```{r}
c(vec2, "r")
```

-   Соедините значения `10`, `TRUE`, `"r"` в вектор.

```{r}
c(10, TRUE, "r")
```

## Векторизация {#sec-solution_vec_ion}

-   Создайте вектор `p`, состоящий из значений 4, 5, 6, 7, и вектор `q`, состоящий из 0, 1, 2, 3.

```{r}
p <- 4:7
p
q <- 0:3
q
```

-   Посчитайте поэлементную сумму векторов `p` и `q`:

```{r}
p + q
```

-   Посчитайте поэлементную разницу `p` и `q`:

```{r}
p - q
```

-   Поделите каждый элемент вектора `p` на соответствующий ему элемент вектора `q`:

> О, да, Вам нужно делить на 0!

```{r}
p / q
```

-   Возведите каждый элемент вектора `p` в степень соответствующего ему элемента вектора `q`:

```{r}
p ^ q
```

-   Умножьте каждое значение вектора `p` на 10.

```{r}
p * 10
```

-   Создайте вектор квадратов чисел от 1 до 10:

```{r}
(1:10)^2
```

-   Создайте вектор 0, 2, 0, 4, ... , 18, 0, 20.

```{r}
1:20 * 0:1
```

-   Создайте вектор 1, 0, 3, 0, 5, ..., 17, 0, 19, 0.

```{r}
1:20 * 1:0
```

-   \*Создайте вектор, в котором будут содержаться первые 20 степеней двойки.

```{r}
2 ^ (1:20)
```

-   \*Создайте вектор из чисел 1, 10, 100, 1000, 10000:

```{r}
10 ^ (0:4)
```

-   \*Посчитать сумму последовательности $\frac{1}{1 \cdot 2}+\frac{1}{2 \cdot 3}+\frac{1}{3 \cdot 4}+\ldots+\frac{1}{50 \cdot 51}$.

```{r}
sum(1 / (1:50 * 2:51))
```

-   \*Посчитать сумму последовательности $\frac{1}{2^{0}}+\frac{1}{2^{1}}+\frac{1}{2^{2}}+\frac{1}{2^{3}}+\ldots \frac{1}{2^{20}}$.

```{r}
sum(1 / 2 ^ (0:20))
```

-   \*Посчитать сумму последовательности $1+\frac{4}{3}+\frac{7}{9}+\frac{10}{27}+\frac{13}{81}+\ldots+\frac{28}{19683}$.

```{r}
sum((3 * (1:10) - 2) / 3 ^ (0:9))
```

-   \*Сколько чисел из последовательности $1+\frac{4}{3}+\frac{7}{9}+\frac{10}{27}+\frac{13}{81}+\ldots+\frac{28}{19683}$ больше чем 0.5?

```{r}
sum((3 * (1:10) - 2) / 3 ^ (0:9) > 0.5)
```

## Индексирование векторов {#sec-solution_vec_ind}

-   Создайте вектор `troiki` со значениями 3, 6, 9, ..., 24, 27.

```{r}
troiki <- seq(3, 27, 3)
troiki
```

-   Извлеките 2, 5 и 7 значения вектора `troiki`.

```{r}
troiki[c(2, 5, 7)]
```

-   Извлеките *предпоследнее* значение вектора `troiki`.

```{r}
troiki[length(troiki) - 1]
```

-   Извлеките все значения вектора `troiki` *кроме* предпоследнего:

```{r}
troiki[-(length(troiki) - 1)]
```

Создайте вектор `vec3`, скопировав следующий код:

```{r, echo = TRUE}
vec3 <- c(3, 5, 2, 1, 8, 4, 9, 10, 3, 15, 1, 11)
```

-   Найдите второй элемент вектора `vec3`.

```{r}
vec3[2]
```

-   Верните второй и пятый элемент вектора `vec3`.

```{r}
vec3[c(2, 5)]
```

-   Попробуйте извлечь сотое значение вектора `vec3`:

```{r}
vec3[100]
```

-   Верните все элементы вектора `vec3` *кроме* второго элемента.

```{r}
vec3[-2]
```

-   Верните все элементы вектора `vec3` *кроме* второго и пятого элемента.

```{r}
vec3[c(-2, -5)]
```

-   Найдите последний элемент вектора `vec3`.

```{r}
vec3[length(vec3)]
```

-   Верните все значения вектора `vec3` кроме первого и последнего.

```{r}
vec3[c(-1, -length(vec3))]
```

-   Найдите все значения вектора `vec3`, которые больше 4.

```{r}
vec3[vec3 > 4]
```

-   Найдите все значения вектора `vec3`, которые больше 4, но меньше 10.

> Если хотите сделать это в одну строчку, то вам помогут логические операторы!

```{r}
vec3[vec3 > 4 & vec3 < 10]
```

-   Найдите все значения вектора `vec3`, которые меньше 4 или больше 10.

```{r}
vec3[vec3 < 4 | vec3 > 10]
```

-   Возведите в квадрат каждое значение вектора `vec3`.

```{r}
vec3 ^ 2
```

-   \*Возведите в квадрат каждое значение вектора на нечетной позиции и извлеките корень из каждого значения на четной позиции вектора `vec3`.

> Извлечение корня - это то же самое, что и возведение в степень 0.5.

```{r}
vec3 ^ c(2, 0.5)
```

-   Создайте вектор 2, 4, 6, ... , 18, 20 как минимум 2 новыми способами.

> Знаю, это задание может показаться бессмысленным, но это очень базовая операция, с помощью которой можно, например, разделить данные на две части. Чем больше способов Вы знаете, тем лучше!

```{r}
(1:20)[c(FALSE,TRUE)]
#(1:10)*2
```

## Работа с пропущенными значениями {#sec-solution_na}

-   Создайте вектор `vec4` со значениями 300, 15, 8, 2, 0, 1, 110, скопировав следующий код:

```{r, echo = TRUE}
vec4 <- c(300, 15, 8, 20, 0, 1, 110)
vec4
```

-   Замените все значения `vec4`, которые больше 20 на `NA`.

```{r}
vec4[vec4 > 20] <- NA
```

-   Проверьте полученный вектор `vec4`:

```{r}
vec4
```

-   Посчитайте сумму `vec4` с помощью функции `sum()`. Ответ `NA` не считается!

```{r}
sum(vec4, na.rm = TRUE)
```

## Матрицы {#sec-solution_matrix}

-   Создайте матрицу размером *4х4,* состоящую из единиц. Назовите ее `M1`.

```{r}
M1 <- matrix(rep(1, 16), ncol = 4)
M1
```

-   Поменяйте все некрайние значения матрицы `M1` (то есть значения на позициях \[2,2\], \[2,3\], \[3,2\] и \[3,3\]) на число 2.

```{r}
M1[2:3, 2:3] <- 2
M1
```

-   Выделите второй и третий столбик из матрицы `M1`.

```{r}
M1[,2:3]
```

-   Сравните (`==`) вторую колонку и вторую строчку матрицы `M1`.

```{r}
M1[,2] == M1[2,]
```

-   Создайте матрицу `M2` из *пяти строк* и *шести столбцов*, в которой будут записаны значения *от 1 до 30* (сверху вниз, затем слева направо):

```{r}
M2 <- matrix(1:30, ncol = 6)
M2
```

-   Извлеките из матрицы `M2` все значения (в виде матрицы) *кроме значений из третьей строки и второго столбца.*

```{r}
M2[-3, -2]
```

-   Умножьте каждое значение матрицы `M2` на 100.

```{r}
M2 * 100
```

-   Возведите каждое значение матрицы `M2` *в квадрат.*

```{r}
M2 ^ 2
```

-   Возведите каждое значение матрицы `M2` *в квадрат* и *вычтите* значения изначальной матрицы `M2`.

```{r}
M2 ^ 2 - M2
```

-   \*Создайте таблицу умножения (9х9) в виде матрицы. Сохраните ее в переменную `mult_tab`.

> Вам может понадобиться функция `rep()`.

```{r}
mult_tab <- matrix(rep(1:9, rep(9,9))*(1:9), nrow = 9)
mult_tab

#Еще
#outer(1:9, 1:9, "*")
#1:9 %o% 1:9
```

-   \*Из матрицы `mult_tab` выделите подматрицу, включающую в себя только строчки с 6 по 8 и столбцы с 3 по 7.

```{r}
mult_tab[6:8, 3:7]
```

-   \*Создайте матрицу с логическими значениями, где `TRUE`, если в этом месте в таблице умножения (`mult_tab`) двузначное число и `FALSE`, если однозначное.

> Матрица - это почти вектор. К нему можно обращаться с единственным индексом.

```{r}
mult_tab >= 10
```

-   \*Создайте матрицу `mult_tab2`, в которой все значения `tab` меньше 10 заменены на 0.

```{r}
mult_tab2 <- mult_tab
mult_tab2[mult_tab < 10] <- 0
mult_tab2
```

## Списки {#sec-solution_list}

Дан список `list1`:

```{r, echo = TRUE}
list1 = list(numbers = 1:5, letters = letters, logic = TRUE)
list1
```

-   Найдите первый элемент списка `list1`. Ответ должен быть списком длиной один.

```{r}
list1[1]
```

-   Теперь найдите содержание первого элемента списка `list1` двумя разными способами. Ответ должен быть вектором.

```{r}
list1[[1]]
list1$numbers
```

-   Теперь возьмите первый элемент содержания первого элемента списка `list1`. Ответ должен быть вектором.

```{r}
list1[[1]][1]
```

-   Создайте список `list2`, содержащий в себе два списка `list1`. Один из них будет иметь имя `pupa`, а другой --- `lupa`.

```{r}
list2 = list(pupa = list1, lupa = list1)
list2
```

-   \*Извлеките первый элемент списка `list2`, из него --- второй подэлемент, а из него --- третье значение.

```{r}
list2[[1]][[2]][3]
```

## Датафрейм {#sec-solution_df}

-   Запустите команду `data(mtcars)` чтобы загрузить встроенный датафрейм с информацией про автомобили. Каждая строчка датафрейма - модель автомобиля, каждая колонка - отдельная характеристика. Подробнее см. `?mtcars`.

```{r, echo = TRUE}
data(mtcars)
mtcars
```

-   Изучите структуру датафрейма `mtcars` с помощью функции `str()`.

```{r}
str(mtcars)
```

-   Найдите значение третьей строчки четвертого столбца датафрейма `mtcars`.

```{r}
mtcars[3, 4]
```

-   Извлеките первые шесть строчек и первые шесть столбцов датафрейма `mtcars`.

```{r}
mtcars[1:6, 1:6]
```

-   Извлеките колонку `wt` датафрейма `mtcars` - массу автомобиля в тысячах фунтов.

```{r}
mtcars$wt
```

-   Извлеките колонки из `mtcars` в следующем порядке: `hp`, `mpg`, `cyl`.

```{r}
mtcars[, c("hp", "mpg", "cyl")]
```

-   Посчитайте *количество* автомобилей с 4 цилиндрами (`cyl`) в датафрейме `mtcars`.

```{r}
sum(mtcars$cyl == 4)
```

-   Посчитайте *долю* автомобилей с 4 цилиндрами (`cyl`) в датафрейме `mtcars`.

```{r}
mean(mtcars$cyl == 4)
```

-   Найдите все автомобили мощностью не менее 100 лошадиных сил (`hp`) в датафрейме `mtcars`.

```{r}
mtcars[mtcars$hp >= 100, ]
```

-   Найдите все автомобили мощностью не менее 100 лошадиных сил (`hp`) и 4 цилиндрами (`cyl`) в датафрейме `mtcars`.

```{r}
mtcars[mtcars$hp >= 100 & mtcars$cyl == 4, ]
```

-   Посчитайте максимальную массу (`wt`) автомобиля в выборке, воспользовавшись функцией `max()`:

```{r}
max(mtcars$wt)
```

-   Посчитайте минимальную массу (`wt`) автомобиля в выборке, воспользовавшись функцией `min()`:

```{r}
min(mtcars$wt)
```

-   Найдите строчку датафрейма `mtcars` с самым легким автомобилем.

```{r}
mtcars[mtcars$wt == min(mtcars$wt), ]
```

-   Извлеките строчки датафрейма `mtcars` с автомобилями, масса которых ниже средней массы.

```{r}
mtcars[mtcars$wt < mean(mtcars$wt), ]
```

-   Масса автомобиля указана в тысячах фунтов. Создайте колонку `wt_kg` с массой автомобиля в килограммах. Результат округлите до целых значений с помощью функции `round()`.

> 1 фунт = 0.45359237 кг.

```{r}
mtcars$wt_kg <- round(mtcars$wt * 1000 * 0.45359237)
mtcars
```

## Условные конструкции {#sec-solution_if}

-   Создайте вектор `vec5`, скопировав следующий код:

```{r, echo = TRUE}
vec5 <- c(5, 20, 30, 0, 2, 9)
```

-   Создайте новый строковый вектор, где на месте чисел больше 10 в `vec5` будет стоять "большое число", а на месте остальных чисел -- "маленькое число".

```{r}
ifelse(vec5 > 10, "большое число", "маленькое число")
```

-   Загрузите файл heroes_information.csv в переменную `heroes`.

```{r, echo = TRUE}
heroes <- read.csv("data/heroes_information.csv", 
                   stringsAsFactors = FALSE,
                   na.strings = c("-", "-99"))
```

-   Создайте новою колонку `hair` в `heroes`, в которой будет значение `"Bold"` для тех супергероев, у которых в колонке `Hair.color` стоит `"No Hair"`, и значение `"Hairy"` во всех остальных случаях.

```{r}
heroes$hair <- ifelse(heroes$Hair.color == "No Hair", "Bold", "Hairy")
head(heroes)
```

-   Создайте новою колонку `tall` в `heroes`, в которой будет значение `"tall"` для тех супергероев, у которых в колонке `Height` стоит число больше 190, значение `"short"` для тех супергероев, у которых в колонке `Height` стоит число меньше 170, и значение `"middle"` во всех остальных случаях.

```{r}
# heroes$tall <- dplyr::case_when(
#   heroes$Height > 190 ~ "tall",
#   heroes$Height < 170 ~ "short",
#   TRUE ~ "middle"
# )
heroes$tall <- ifelse(heroes$Height > 190, 
                      "tall",
                      ifelse(heroes$Height < 170,
                             "short",
                             "middle"))
```

## Создание функций {#sec-solution_function}

-   Создайте функцию `plus_one()`, которая принимает число и возвращает это же число + 1.

```{r}
plus_one <- function(x) x + 1
```

-   Проверьте функцию `plus_one()` на числе 41.

```{r, echo = TRUE}
plus_one(41)
```

-   Создайте функцию `circle_area()`, которая вычисляет площадь круга по радиусу согласно формуле $\pi r^2$.

```{r}
circle_area <- function(r) pi * r ^ 2
```

-   Посчитайте площадь круга с радиусом 5.

```{r}
circle_area(5)
```

-   Создайте функцию `cels2fahr()`, которая будет превращать градусы по Цельсию в градусы по Фаренгейту.

```{r}
cels2fahr <- function(x) x * 9 / 5 + 32
```

-   Проверьте на значениях -100, -40 и 0, что функция `cels2fahr()` работает корректно.

```{r, echo = TRUE}
cels2fahr(c(-100, -40, 0))
```

-   Напишите функцию `highlight()`, которая принимает на входе строковый вектор, а возвращает тот же вектор, но дополненный значением `"***"` в начале и конце вектора. Лучше всего это рассмотреть на примере:

```{r}
highlight <- function(x) c("***", x, "***")
```

```{r, echo = TRUE}
highlight(c("Я", "Бэтмен!"))
```

-   Теперь сделайте функцию `highlight` более гибкой. Добавьте в нее параметр `wrapper =`, который по умолчанию равен `"***"`. Значение параметра `wrapper =` и будет вставлено в начало и конец вектора.

```{r}
highlight <- function(x, wrapper = "***") c(wrapper, x, wrapper)
```

-   Проверьте написанную функцию на векторе `c("Я", "Бэтмен!")`.

```{r, echo = TRUE}
highlight(c("Я", "Бэтмен!")) 
highlight(c("Я", "Бэтмен!"), wrapper = "__") 
```

-   Создайте функцию `na_n()`, которая будет возвращать количество `NA` в векторе.

```{r}
na_n <- function(x) sum(is.na(x))
```

-   Проверьте функцию `na_n()` на векторе:

```{r, echo = TRUE}
na_n(c(NA, 3:5, NA, 2, NA))
```

-   Напишите функцию `factors()`, которая будет возвращать все делители числа в виде числового вектора.

> Здесь может понадобиться оператор для получения остатка от деления: `%%`.

```{r}
factors <- function(x) (1:x)[x %% (1:x) == 0]
```

-   Проверьте функцию `factors()` на простых и сложных числах:

```{r, echo = TRUE}
factors(3)
factors(161)
factors(1984)
```

-   \*Напишите функцию `is_prime()`, которая проверяет, является ли число простым.

> Здесь может пригодиться функция `any()` - она возвращает `TRUE`, если в векторе есть хотя бы один `TRUE`.

```{r}
is_prime <- function(x) !any(x%%(2:(x-1)) == 0)
#is_prime <- function(x) length(factors(x)) == 2 #Используя уже написанную функцию factors()
```

-   Проверьте какие года были для нас простыми, а какие нет:

```{r, echo = TRUE}
is_prime(2017)
is_prime(2019)
2019/3 #2019 делится на 3 без остатка
is_prime(2020)
is_prime(2021)
```

-   \*Создайте функцию `monotonic()`, которая возвращает `TRUE`, если значения в векторе не убывают (то есть каждое следующее - больше или равно предыдущему) или не возврастают.

> Полезная функция для этого --- `diff()` --- возвращает разницу соседних значений.

```{r}
monotonic <- function(x) all(diff(x)>=0) | all(diff(x)<=0)
```

```{r, echo = TRUE}
monotonic(1:7)
monotonic(c(1:5,5:1))
monotonic(6:-1)
monotonic(c(1:5, rep(5, 10), 5:10))
```

Бинарные операторы типа `+` или `%in%` тоже представляют собой функции. Более того, мы можем создавать свои бинарные операторы! В этом нет особой сложности --- нужно все так же создавать функцию (для двух переменных), главное окружать их `%` и название обрамлять обратными штрихами \`. Например, можно сделать свой бинарный оператор `%notin%`, который будет выдавать `TRUE`, если значения слева *нет* в векторе справа:

```{r, echo = TRUE}
`%notin%` <- function(x, y) ! (x %in% y)
1:10 %notin% c(1, 4, 5)
```

-   \*Создайте бинарный оператор `%without%`, который будет возвращать все значения вектора слева без значений вектора справа.

```{r}
`%without%` <- function(x, y) x[!x %in% y]
```

```{r, echo = TRUE}
c("а", "и", "б", "сидели", "на", "трубе") %without% c("а", "б")
```

-   \*Создайте бинарный оператор `%between%`, который будет возвращать `TRUE`, если значение в векторе слева накходится в *диапазоне* значений вектора справа:

```{r}
`%between%` <- function(x, y) x >= min(y) & x <= max(y)
```

```{r, echo = TRUE}
1:10 %between% c(1, 4, 5)
```

## Проверка на адекватность {#sec-solution_sanity}

-   Создайте функцию `trim()`, которая будет возвращать вектор без первого и последнего значения (вне зависимости от типа данных).

```{r}
trim <- function(x) x[c(-1, -length(x))]
```

-   Проверьте, что функция `trim()` работает корректно:

```{r, echo = TRUE}
trim(1:7)
trim(letters)
```

-   Теперь добавьте в функцию `trim()` параметр `n =` со значением по умолчанию 1. Этот параметр будет обозначать сколько значений нужно отрезать слева и справа от вектора.

```{r}
trim <- function(x, n = 1) x[c(-1:-n, (-length(x)+n-1):-length(x))]
```

-   Проверьте полученную функцию:

```{r, echo = TRUE}
trim(letters)
trim(letters, n = 2)
```

-   Сделайте так, чтобы функция `trim()` работала корректно с `n = 0`, т.е. функция возвращала бы исходный вектор без изменений.

```{r}
trim <- function(x, n = 1) {
  if (n == 0) return(x)
  x[c(-1:-n, (-length(x)+n-1):-length(x))]
}
```

```{r, echo = TRUE}
trim(letters, n = 0)
```

-   \*Теперь добавьте проверку на адекватность входных данных: функция `trim()` должна выдавать ошибку, если `n =` меньше нуля или если `n =` слишком большой и отрезает все значения вектора:

```{r}
trim <- function(x, n = 1) {
  if (n < 0) stop("n не может быть меньше нуля!")
  l <- length(x)
  if (n > ceiling(l/2) - 1) stop("n слишком большой!")
  if (n == 0) return(x)
  x[c(-1:-n, (-l+n-1):-l)]
}
```

-   \*Проверьте полученную функцию `trim()`:

```{r, error = TRUE, echo = TRUE}
trim(1:6, 3)
trim(1:6, -1)
```

## Семейство функций apply() {#sec-solution_apply}

-   Создайте матрицу `M2`:

```{r, echo = TRUE}
M2 <- matrix(c(20:11, 11:20), nrow = 5)
M2
```

-   Посчитайте максимальное значение матрицы `M2` по каждой строчке.

```{r}
apply(M2, 1, max)
```

-   Посчитайте максимальное значение матрицы `M2` по каждому столбцу.

```{r}
apply(M2, 2, max)
```

-   Посчитайте среднее значение матрицы `M2` по каждой строке.

```{r}
apply(M2, 1, mean)
```

-   Посчитайте среднее значение матрицы `M2` по каждому столбцу.

```{r}
apply(M2, 2, mean)
```

-   Создайте список `list3`:

```{r, echo = TRUE}
list3 <- list(
  a = 1:5,
  b = 0:20,
  c = 4:24,
  d = 6:3,
  e = 6:25
  )
```

-   Найдите максимальное значение каждого вектора списка `list3`.

```{r}
sapply(list3, max)
```

-   Посчитайте сумму каждого вектора списка `list3`.

```{r}
sapply(list3, sum)
```

-   Посчитайте длину каждого вектора списка `list3`.

```{r}
sapply(list3, length)
```

-   Напишите функцию `max_item()`, которая будет принимать на входе список, а возвращать - (первый) самый длинный его элемент.

> Для этого вам может понадобиться функция `which.max()`, которая возвращает индекс максимального значения (первого, если их несколько).

```{r}
max_item <- function (x) x[[which.max(sapply(x, length))]]
```

-   Проверьте функцию `max_item()` на списке `list3`.

```{r, echo = TRUE}
max_item(list3)
```

-   Теперь мы сделаем сложный список `list4`:

```{r, echo = TRUE}
list4 <- list(1:3, 3:40, list3)
```

-   Посчитайте длину каждого вектора в списке, в т.ч. для списка внутри. Результат должен быть списком с такой же структорой, как и изначальный список `list4`.

> Для этого может понадобиться функция `rapply()`: **recursive lapply**

```{r}
rapply(list4, length, how = "list")
```

-   \*Загрузите набор данных `heroes` и посчитайте, сколько `NA` в каждом из столбцов.

> Для этого удобно использовать ранее написанную функцию `na_n()`.

```{r}
sapply(heroes, na_n)
```

-   \*Используя ранее написанную функцию `is_prime()`, напишите функцию `prime_numbers()`, которая будет возвращать все простые числа до выбранного числа.

```{r}
is_prime <- function(x) !any(x %% (2:(x - 1)) == 0)
prime_numbers <- function(x) (2:x)[sapply(2:x, is_prime)]
```

```{r, echo = TRUE}
prime_numbers(200)
```

## magrittr::`%>%` {#sec-solution_pipe}

```{r}
library(tidyverse)
```

-   Перепишите следующие выражения, используя `%>%`:

```{r}
1:10 %>%
  sum() %>%
  sqrt()
```

```{r}
-5:5 %>%
  min() %>%
  abs()
```

```{r}
2 %>% c("Корень из", ., "равен", sqrt(.))
```

```{r}
10:39 %>% 
  matrix(nrow = 5) %>%
  apply(1, mean)
```

## Выбор столбцов: `dplyr::select()` {#sec-solution_select}

Для выполнения следующих заданий нам понадобятся датасеты `heroes` и `powers`, которые можно загрузить, используя следующие команды:

```{r, echo = TRUE}
library(tidyverse)
heroes <- read_csv("https://raw.githubusercontent.com/Pozdniakov/tidy_stats/master/data/heroes_information.csv",
                   na = c("-", "-99"))
powers <- read_csv("https://raw.githubusercontent.com/Pozdniakov/tidy_stats/master/data/super_hero_powers.csv")
```

-   Выберете первые 4 столбца в `powers`.

```{r}
powers %>%
  select(1:4)
```

-   Выберите все столбцы от `Reflexes` до `Empathy` в тиббле `powers`:

```{r}
powers %>%
  select(Reflexes:Empathy)
```

-   Выберите все столбцы тиббла `powers` кроме первого (`hero_names`):

```{r}
powers %>%
select(!hero_names)
```

## Выбор строк: `dplyr::slice()` и `dplyr::filter()` {#sec-solution_filt}

-   Выберите только те строчки, в которых содержится информация о супергероях тяжелее 500 кг.

```{r}
heroes %>% 
  filter(Weight > 500)
```

-   Выберите только те строчки, в которых содержится информация о *женщинах*-супергероях тяжелее 500 кг.

```{r}
heroes %>% 
  filter(Weight > 500 & Gender == "Female")
```

-   Выберите только те строчки, в которых содержится информация о супергероях человеческой расы (`"Human"`) женского пола. Из этих супергероев возьмите первые 5.

```{r}
heroes %>% 
  filter(Race == "Human" & Gender == "Female") %>%
  slice(1:5)
```

## Сортировка строк: `dplyr::arrange()` {#sec-solution_arr}

-   Выберите из тиббла `heroes` колонки `name`, `Gender`, `Height` и отсортируйте строчки *по возрастанию* `Height`.

```{r}
heroes %>%
  select(name, Gender, Height) %>%
  arrange(Height)
```

-   Выберите из тиббла `heroes` колонки `name`, `Gender`, `Height` и отсортируйте строчки *по убыванию* `Height`.

```{r}
heroes %>%
  select(name, Gender, Height) %>%
  arrange(desc(Height))
```

-   Выберите из тиббла `heroes` колонки `name`, `Gender`, `Height` и отсортируйте строчки сначала по `Gender`, затем *по убыванию* `Height`.

```{r}
heroes %>%
  select(name, Gender, Height) %>%
  arrange(Gender, desc(Height))
```

## Уникальные значения: `dplyr::distinct()` {#sec-solution_dist}

-   Извлеките уникальные значения столбца `Eye color` из тиббла `heroes`.

```{r}
heroes %>%
  distinct(`Eye color`)
```

-   Извлеките уникальные значения столбца `Hair color` из тиббла `heroes`.

```{r}
heroes %>%
  distinct(`Hair color`)
```

## Создание колонок: `dplyr::mutate()` и `dplyr::transmute()` {#sec-solution_mutate}

-   Создайте колонку `height_m` с ростом супергероев в метрах, затем выберите только колонки `name` и `height_m`.

```{r}
heroes %>%
  mutate(height_m = Height/100) %>%
  select(name, height_m)
```

-   Создайте новою колонку hair в heroes, в которой будет значение "Bold" для тех супергероев, у которых в колонке Hair.color стоит "No Hair", и значение "Hairy" во всех остальных случаях. Затем выберите только колонки `name`, `Hair color`, `hair`.

```{r}
heroes %>%
  mutate(hair = ifelse(`Hair color` == "No Hair", "Bold", "Hairy")) %>%
  select(name, `Hair color`, hair)
```

## Агрегация: `dplyr::group_by() %>% summarise()` {#sec-solution_group_by}

-   Посчитайте количество супергероев по расам и отсортируйте по убыванию. Извлеките первые 5 строк.

```{r}
heroes %>%
  count(Race, sort = TRUE) %>%
  slice(1:5)
```

-   Посчитайте средний пост по полу.

```{r}
heroes %>%
  group_by(Gender) %>%
  summarise(height_mean = mean(Height, na.rm = TRUE))
```

## Соединение датафреймов: \*\_join {#sec-solution_join}

Создайте тиббл `web_creators`, в котором будут супергерои, которые могут плести паутину, т.е. у них стоит `TRUE` в колонке `Web Creation` в тиббле `powers`.

```{r}
powers_web <- powers %>%
  select(hero_names, `Web Creation`)
web_creators <- left_join(heroes, powers_web, by = c("name" = "hero_names")) %>%
  filter(`Web Creation`)
web_creators
```

-   Найдите всех супергероев, которые присутствуют в `heroes`, но отсутствуют в `powers`. Ответом должен быть строковый вектор с именами супергероев.

```{r}
anti_join(heroes, powers, by = c("name" = "hero_names")) %>%
  pull(name)
```

-   Найдите всех супергероев, которые присутствуют в `powers`, но отсутствуют в `heroes`. Ответом должен быть строковый вектор с именами супергероев.

```{r}
anti_join(powers, heroes, by = c("hero_names" = "name")) %>%
  pull(hero_names)
```

## Tidy data {#sec-solution_pivot}

-   Для начала создайте тиббл `heroes_weight`, скопировав код:

```{r, echo = TRUE}
heroes_weight <- heroes %>%
  filter(Publisher %in% c("DC Comics", "Marvel Comics")) %>%
  group_by(Gender, Publisher) %>%
  summarise(weight_mean = mean(Weight, na.rm = TRUE)) %>%
  drop_na()
heroes_weight 
```

> Функция `drop_na()` позволяет выбросить все строчки, в которых встречается `NA`.

-   Превратите тиббл `heroes_weight` в широкий тиббл:

```{r}
heroes_weight %>%
  pivot_wider(names_from = "Publisher", values_from = "weight_mean")
```

-   Затем превратите его обратно в длинный тиббл:

```{r}
heroes_weight %>%
  pivot_wider(names_from = "Publisher", values_from = "weight_mean") %>%
  pivot_longer(cols = !Gender,
               names_to = "Publisher",
               values_to = "weight_mean")
```

-   Сделайте `powers` длинным тибблом с тремя колонками: `hero_names`, `power` (названгие суперсилы) и `has` (наличие суперсилы у данного супергероя).

```{r}
powers %>%
  pivot_longer(cols = !hero_names,
               names_to = "power",
               values_to = "has")
```

-   Сделайте тиббл `powers` обратно широким, но с новой структурой: каждая строчка означает суперсилу, а каждая колонка - супергероя (за исключением первой колонки - названия суперсилы).

```{r}
powers %>%
  pivot_longer(cols = !hero_names,
               names_to = "power",
               values_to = "has") %>%
  pivot_wider(names_from = hero_names,
              values_from = has)
```

## Операции с несколькими колонками: `across()` {#sec-solution_across}

-   Посчитайте количество `NA` в каждой колонке, группируя по полу (`Gender`).

```{r}
na_n <- function(x) sum(is.na(x))
heroes %>%
  group_by(Gender) %>%
  summarise(across(everything(), na_n))
```

-   Посчитайте количество `NA` в каждой колонке, которая заканчивается на `"color"`, группируя по полу (`Gender`).

```{r}
na_n <- function(x) sum(is.na(x))
heroes %>%
  group_by(Gender) %>%
  summarise(across(ends_with("color"), na_n))
```

-   Найдите (первую) самую длинную строчку для каждой колонки с `character` типом данных, группируя по полу (`Gender`).

> Для расчета количества значений в строке есть функция `nchar()`, для расчета индекса (первого) максимального значения есть функция `which.max()`.

```{r}
longest_char <- function(x) x[which.max(nchar(x))]
heroes %>%
  group_by(Gender) %>%
  summarise(across(where(is.character), longest_char))
```

-   Создайте из тиббла `heroes` новый тиббл, в котором числовые значения `Height` и `Weight` заменены на следующие строковые значения: если у супергероя рост или вес выше среднего по колонке, то `"выше среднего"`, если его/ее рост или вес ниже или равен среднему, то `"ниже среднего"`.

```{r}
higher_than_average <- function(x) ifelse(x > mean(x, na.rm = TRUE),
                                          "выше среднего",
                                          "ниже среднего")
heroes %>%
  mutate(across(c(Height, Weight), 
                   higher_than_average))
```

-   Создайте из тиббла `heroes` новый тиббл, в котором числовые значения `Height` и `Weight` заменены на следующие строковые значения: если у супергероя *внутри соответствующей группы по полу* рост или вес выше среднего по колонке, то `"выше среднего по X"`, если его/ее рост или вес ниже или равен среднему *внутри соответствующей группы по полу*, то `"ниже среднего по X"` , где *X* --- соответствующий пол (`Gender`).

```{r}
heroes %>%
  group_by(Gender) %>%
  mutate(across(c(Height, Weight), 
                   higher_than_average)) %>%
  ungroup() %>%
  mutate(across(c(Height, Weight), 
                   ~paste(., "по", Gender)))
```

## Описательная статистика {#sec-desc_solutions}

Для выполнения задания создайте вектор `height` из колонки `Height` датасета `heroes`, удалив в нем `NA`.

```{r}
height <- heroes %>%
  drop_na(Height) %>%
  pull(Height)
```

-   Посчитайте среднее в векторе `height`.

```{r}
mean(height)
```

-   Посчитайте усеченное среднее в векторе `height` с усечением 5% значений с обоих сторон.

```{r}
mean(height, trim = 0.05)
```

-   Посчитайте медиану в векторе `height`.

```{r}
median(height)
```

-   Посчитайте стандартное отклонение в векторе `height`.

```{r}
sd(height)
```

-   Посчитайте межквартильный размах в векторе `height`.

```{r}
IQR(height)
```

-   Посчитайте ассиметрию в векторе `height`.

```{r}
psych::skew(height)
```

Посчитайте эксцесс в векторе `height`.

```{r}
psych::kurtosi(height)
```

Примените функции для получения множественных статистик на векторе `height`.

```{r}
summary(height)
psych::describe(height)
skimr::skim(height)
```

## Построение графиков в `ggplot2` {#sec-ggplot2_solutions}

-   Нарисуйте столбиковую диаграмму (`geom_bar()`), которая будет отражать количество супергероев издателей `"Marvel Comics"`, `"DC Comics"` и всех остальных (отдельным столбиком) из датасета `heroes`.

```{r}
heroes %>%
  mutate(Publisher = ifelse(Publisher %in% c("Marvel Comics", "DC Comics"), 
                            Publisher,
                            "Other publishers")) %>%
  #mutate(Publisher = fct_lump(Publisher, 2)) %>% #Еще один способ сделать то же самое, но через forcats
  ggplot(aes(x = Publisher)) +
  geom_bar()
```

-   Добавьте к этой диаграме заливку цветом (`fill =`) в зависимости от распределения `Gender` внутри каждой группы.

```{r}
heroes %>%
  mutate(Publisher = ifelse(Publisher %in% c("Marvel Comics", "DC Comics"), 
                            Publisher,
                            "Other publishers")) %>%
  #mutate(Publisher = fct_lump(Publisher, 2)) %>% #Еще один способ сделать то же самое, но через forcats
  ggplot(aes(x = Publisher, fill = Gender)) +
  geom_bar()
```

-   Сделайте так, чтобы каждый столбик был максимальной высоты (`position = "fill"`).

```{r}
heroes %>%
  mutate(Publisher = ifelse(Publisher %in% c("Marvel Comics", "DC Comics"), 
                            Publisher,
                            "Other publishers")) %>%
  #mutate(Publisher = fct_lump(Publisher, 2)) %>% #Еще один способ сделать то же самое, но через forcats
  ggplot(aes(x = Publisher, fill = Gender)) +
  geom_bar(position = "fill")
```

-   Финализируйте график, задав ему описания осей (например, функция `labs()`), использовав процентную шкалу (`scale_y_continuous(labels = scales::percent)`) и задав тему `theme_minimal()`.

```{r}
heroes %>%
  mutate(Publisher = ifelse(Publisher %in% c("Marvel Comics", "DC Comics"), 
                            Publisher,
                            "Other publishers")) %>%
  #mutate(Publisher = fct_lump(Publisher, 2)) %>% #Еще один способ сделать то же самое, но через forcats
  ggplot(aes(x = Publisher, fill = Gender)) +
  geom_bar(position = "fill") +
  labs(title = "Распределение супергероев по полу у разных издателей коммиксов",
       x = "Издатель",
       y = "Количество супергероев")+
  scale_y_continuous(labels = scales::percent) +
  theme_minimal()
```

Создайте диаграмму рассеяния для датасета `heroes`, для которой координаты по оси *x* будут взяты из колонки `Height`, а координаты по оси *y* --- из колонки `Weight`.

```{r}
heroes %>%
  ggplot(aes(x = Height, y = Weight)) +
  geom_point()
```

-   Удалите с графика все экстремальные значения, для которых `Weight` больше или равен 700 или `Height` больше или равен 400. (*Подсказка:* это можно делать как средствами `ggplot2`, так и функцией `filter()` из `dplyr`).

```{r}
heroes %>%
  filter(Weight < 700 & Height < 400) %>%
  ggplot(aes(x = Height, y = Weight)) +
  geom_point()
```

-   Раскрасьте точки в зависимости от `Gender`, сделайте их полупрозрачными ( параметр `alpha =`).

```{r}
heroes %>%
  filter(Weight < 700 & Height < 400) %>%
  ggplot(aes(x = Height, y = Weight)) +
  geom_point(aes(colour = Gender), alpha = 0.5)
```

-   Сделайте так, чтобы координатная плоскость имела соотношение 1:1 шкал по оси *x* и *y*. Этого можно добиться с помощью функции `coord_fixed()`.

```{r}
heroes %>%
  filter(Weight < 700 & Height < 400) %>%
  ggplot(aes(x = Height, y = Weight)) +
  geom_point(aes(colour = Gender), alpha = 0.5) +
  coord_fixed()
```

Разделите график (`facet_wrap()`) на три: для `"DC Comics"`,`"Marvel Comics"` и всех остальных.

```{r}
heroes %>%
  mutate(Publisher = ifelse(Publisher %in% c("Marvel Comics", "DC Comics"), 
                            Publisher,
                            "Other publishers")) %>%
  filter(Weight < 700 & Height < 400) %>%
  ggplot(aes(x = Height, y = Weight)) +
  geom_point(aes(colour = Gender), alpha = 0.5) +
  coord_fixed() +
  facet_wrap(~Publisher)
```

-   Используйте для графика тему `theme_linedraw()`.

```{r}
heroes %>%
  mutate(Publisher = ifelse(Publisher %in% c("Marvel Comics", "DC Comics"), 
                            Publisher,
                            "Other publishers")) %>%
  filter(Weight < 700 & Height < 400) %>%
  ggplot(aes(x = Height, y = Weight)) +
  geom_point(aes(colour = Gender), alpha = 0.5) +
  coord_fixed() +
  facet_wrap(~Publisher)+
  theme_linedraw()
```

-   

    -   Постройте новый график (или возьмите старый) по датасетам `heroes` и/или `powers` и сделайте его некрасивым! Чем *хуже* у вас получится график, тем лучше. Желательно, чтобы этот график был по-прежнему графиком, а не [произведением абстрактного искусства](https://twitter.com/accidental__art?lang=en). Разница очень тонкая, но она есть.

Вот несколько подсказок для этого задания:

1.  Для вдохновения посмотрите на [вот эти графики](https://twitter.com/drdrewsteen/status/1172547837046820864).

2.  Для реально плохих графиков вам придется покопаться с настройками темы. Посмотрите подсказку по темам `?theme`, попытайтесь что-то поменять в теме.

3.  Экспериментируйте с разными геомами и необычными их применениями.

4.  По изучайте дополнения к `gpplot2`.

5.  Попробуйте подготовить интересные данные для этого графика.

<!-- -->

```         
НЕТ ПРАВИЛЬНОГО РЕШЕНИЯ, ПРОЯВИТЕ СВОЮ ФАНТАЗИЮ!
```

## Распределения {#sec-dist_solutions}

Выберите любое непрерывное распределение из представленных в базовом пакете `stats` или же в любом другом пакете. Найти все распределения пакета `stats` можно с помощью `?Distributions`. Подберите для него какие-нибудь параметры или используйте параметры по умолчанию.

> Я возьму F-распределение с параметрами `df1 = 4` и `df = 10`, но вы можете выбрать другое распределение.

-   Визуализируйте функцию плотности вероятности для выбранного распределения.

```{r}
v <- seq(0, 5, 0.01)
plot(v, df(v, df1 = 4, df2 = 10))
```

-   Визуализируйте функцию накопленной плотности распределения для выбранной функции.

```{r}
plot(v, pf(v, df1 = 4, df2 = 10))
```

-   Визуализируйте квантильную функцию для выбранного распределения.

```{r}
p <- seq(0, 1, .01)
plot(p, qf(p, df1 = 4, df2 = 10))
```

-   Сделайте выборку из 100 случайных значений из выбранного распределения и постройте гистограмму (функция `hist()`) для полученной выборки.

```{r}
hist(rf(100, df1 = 4, df2 = 10))
```

## Одновыборочный t-test {#sec-one_ttest_solutions}

-   Представьте, что наши супергерои из набора данных `heroes` --- это выборка из генеральной совокупности всех написанных и ненаписанных супергероев. Проведите одновыборочный t-тест для веса супергероев и числа 100 --- предположительного среднего веса в генеральной совокупности всех супергероев. Проинтерпретируйте результат.

```{r}
t.test(heroes$Weight, mu = 100)
```

p-value меньше .05, поэтому мы можем отклонить нулевую гипотезу о том, что среднее для веса в генеральной совкупности, из которой вы взяли выборку супергероев, равно 100. Мы принимаем ненулевую гипотезу о том, что в генеральной совокупности средний вес *не равен* 100.

-   Проведите одновыборочный t-тест для роста супергероев и числа 185 --- предположительного среднего роста в генеральной совокупности всех супергероев. Проинтерпретируйте результат.

```{r}
t.test(heroes$Height, mu = 185)
```

p-value больше .05, поэтому мы *не* можем отклонить нулевую гипотезу о том, что среднее для роста в генеральной совкупности, из которой вы взяли выборку супергероев, равно 185.

## Двухвыборочный зависимый t-test {#sec-dep_ttest_solutions}

```{r}
diet <- readr::read_csv("https://raw.githubusercontent.com/Pozdniakov/tidy_stats/master/data/stcp-Rdataset-Diet.csv")
```

-   Посчитайте двухвыборочный зависимый т-тест для остальных диет: для диеты 2 и диеты 3. Проинтерпретируйте полученные результаты.

```{r}
diet2 <- diet %>%
  filter(Diet == 2)
t.test(diet2$pre.weight, diet2$weight6weeks, paired = TRUE)
```

p-value меньше .05, поэтому мы можем отклонить нулевую гипотезу о том, что масса до и после диеты одинаковая. Мы принимаем альтернативную гипотезу о различии средних в генеральной совокупности.

-   Сделайте независимый t-тест для сравнения массы испытуемых двух групп после диеты, сравнив первую и третью группу. Проинтерпретируйте результаты.

```{r}
diet3 <- diet %>%
  filter(Diet == 3)
t.test(diet3$pre.weight, diet3$weight6weeks, paired = TRUE)
```

p-value меньше .05, поэтому мы можем отклонить нулевую гипотезу о том, что масса до и после диеты одинаковая. Мы принимаем альтернативную гипотезу о различии средних в генеральной совокупности.

-   Проведите независимый t-тест для сравнения массы супергероев с черными и белыми глазами.

```{r}
#| echo: true
heroes_white_black <- heroes %>%
  filter(`Eye color` %in% c("white", "black"))
```

```{r}
t.test(heroes_white_black$Weight ~ heroes_white_black$`Eye color`)
```

p-value больше .05, поэтому мы не можем отклонить нулевую гипотезу о том, что массы супергероев с черными и белыми глазами одинаковые.

## Двухвыборочный независимый t-test {#sec-ind_ttest_solutions}

-   Сделайте независимый t-тест для сравнения веса испытуемых двух групп после диеты, сравнив вторую и третью группу. Проинтерпретируйте результаты.

```{r}
diet23 <- diet %>%
  filter(Diet %in% 2:3)
t.test(weight6weeks ~ Diet, data = diet23, paired = FALSE)
```

p-value больше .05, поэтому мы не можем отклонить нулевую гипотезу о том, что масса до и после диеты одинаковая.

-   Сделайте независимый t-тест для сравнения веса испытуемых двух групп после диеты, сравнив первую и третью группу. Проинтерпретируйте результаты.

```{r}
diet13 <- diet %>%
  filter(Diet %in% c(1,3))
t.test(weight6weeks ~ Diet, data = diet13, paired = FALSE)
```

p-value больше .05, поэтому мы не можем отклонить нулевую гипотезу о том, что масса до и после диеты одинаковая.

## Непараметрические аналоги t-теста {#sec-nonparam_ttest_solutions}

-   Сравните вес первой и второй группы после диеты, используя тест Манна-Уитни. Сравните результаты теста Манна-Уитни с результатами t-теста? Проинтерпретируйте полученные результаты.

```{r}
diet12 <- diet %>%
  filter(Diet %in% c(1,2))
wilcox.test(weight6weeks ~ Diet, data = diet12, paired = FALSE)
```

В обоих случаях *p-value* больше 0.05, мы не можем отклонить нулевую гипотезу об отсутствии различий.

-   Повторите задание для второй и третьей группы, а так же для первой и третьей группы.

```{r}
wilcox.test(weight6weeks ~ Diet, data = diet23, paired = FALSE)
wilcox.test(weight6weeks ~ Diet, data = diet13, paired = FALSE)
```

В обоих случаях *p-value* больше 0.05, как и для соответствующих t-тестов. Мы не можем отклонить нулевую гипотезу об отстутствии различий между второй и третьей диетой, между первой и третьей диетой.

-   Сравните вес до и после для диеты 1, используя тест Уилкоксона. Сравните с результатами применения t-теста. Проинтерпретируйте полученные результаты.

```{r}
diet1 <- diet %>%
  filter(Diet == 1)
wilcox.test(diet1$pre.weight, diet1$weight6weeks, paired = TRUE)
```

И t-тест, и тест Уилкоксона дают *p-value* ниже 0.05. Мы можем отклонить нулевую гипотезу об отсутствии различий.

-   Сравните вес до и после для диеты 2 и диеты 3, используя тест Уилкоксона. Сравните с результатами применения t-теста. Проинтерпретируйте полученные результаты.

```{r}
wilcox.test(diet2$pre.weight, diet2$weight6weeks, paired = TRUE)
wilcox.test(diet3$pre.weight, diet3$weight6weeks, paired = TRUE)
```

В обоих случаях и t-тест, и тест Уилкоксона дают *p-value* ниже 0.05. Мы можем отклонить нулевую гипотезу об отсутствии различий.

## Критерий хи-квадрат Пирсона {#sec-chi_sq_solutions}

-   Связаны ли переменные Alignment и Gender? Используйте критерий хи-квадрат для проверки и проинтерпретируйте результаты

```{r}
#| echo: true
pub_good <- heroes %>%
  filter(Alignment %in% c("good", "bad")) %>%
  select(Alignment, Gender) %>%
  drop_na()
```

```{r}
table(pub_good) %>%
  summary()
```

-   Создайте в `heroes` новую колонку `is_human` логического типа, в которой будет `TRUE`, если супергерой принадлежит расе (`Race`) `"Human"`, и `FALSE` в случае если супергерой принадлежит другой расе.

```{r}
heroes %>%
  mutate(is_human = Race == "Human")
```

-   Посчитайте долю женщин для `"Human"` и всех остальных (`is_human` равен `TRUE` и `FALSE` соответственно). Перед этим удалите все строчки с `NA` в переменных `is_human` и `Gender`.

```{r}
heroes %>%
  mutate(is_human = Race == "Human") %>%
  drop_na(is_human, Gender) %>%
  group_by(is_human) %>%
  summarise(mean(Gender == "Female"))
```

-   Сравните распределения частот для переменных `is_human` и `Gender` используя хи-квадрат Пирсона. Проинтерпретируйте результаты.

```{r}
heroes %>%
  mutate(is_human = Race == "Human") %>%
  drop_na(is_human, Gender) %>%
  select(is_human, Gender) %>%
  table() %>%
  chisq.test(correct = FALSE)
```

Мы не можем отвергнуть нулевую гипотезу о независимости расы (Человек/не-человек) и пола.

-   Постройте мозаичный график для переменных `is_human` и `Gender`.

```{r}
heroes %>%
  mutate(is_human = Race == "Human") %>%
  drop_na(is_human, Gender) %>%
  select(is_human, Gender) %>%
  table() %>%
  mosaicplot(shade = TRUE)
```

## Исследование набора данных Backpack {#sec-backpack_solutions}

Для следующих тем нам понадобится набор данных `Backpack` из пакета `Stat2Data`.

```{r}
#install.packages("Stat2Data")
library(Stat2Data)
data(Backpack)
back <- Backpack %>%
  mutate(backpack_kg = 0.45359237 * BackpackWeight,
         body_kg = 0.45359237 * BodyWeight)
```

-   Как различается вес рюкзака в зависимости от пола? Кто весит больше?

```{r}
back %>%
  group_by(Sex) %>%
  summarise(mean(backpack_kg))
```

-   Если допустить, что выборка репрезентативна, то можно ли сделать вывод о различии по среднему весу рюкзаков в генеральной совокупности?

```{r}
t.test(backpack_kg ~ Sex, data = back)
```

p-value больше .05, поэтому мы не можем отклонить нулевую гипотезу о том, что масса до и после диеты одинаковая.

-   Повторите пунктs 2 и 3 для веса самих студентов.

```{r}
back %>%
  group_by(Sex) %>%
  summarise(mean(body_kg))
t.test(body_kg ~ Sex, data = back)
```

p-value меньше .05, поэтому мы можем отклонить нулевую гипотезу о том, что масса студентов-мужчин и студентов-женщин одинаковая. Мы принимаем альтернативную гипотезу о различии средних в генеральной совокупности.

-   Визуализируйте распределение этих двух переменных в зависимости от пола (используя `ggplot2`)

```{r}
library(ggplot2)
ggplot(back)+
  geom_histogram(aes(x = body_kg, fill = Sex), bins = 15, position = "identity", alpha = 0.7)
```

-   Постройте диаграмму рассеяния с помощью `ggplot2`. Цветом закодируйте пол респондента.

```{r, class.source=NULL}
ggplot(back, aes(x = body_kg, y = backpack_kg))+
  geom_point(aes(colour = Sex), alpha = 0.5, size = 2)
```

## Ковариация {#sec-cov_solutions}

-   Посчитайте матрицу ковариаций для веса студентов и их рюкзаков в *фунтах.* Различаются ли результаты подсчета ковариации этих двух переменных от результатов подсчета ковариаций веса студентов и их рюкзаков в *килограммах*? Почему?

```{r}
back %>%
  select(BodyWeight, BackpackWeight) %>%
  cov()
```

Результаты различаются, потому что значение ковариации зависит от размерности исходных шкал.

## Коэффициент корреляции {#sec-cor_solutions}

-   Посчитайте коэффициент корреляции Пирсона для веса студентов и их рюкзаков в *фунтах.* Различаются ли результаты подсчета коэффициента корреляции Пирсона (сам коэффициент, p-value) этих двух переменных от результатов подсчета корреляции Пирсона веса студентов и их рюкзаков в *килограммах*? Почему?

```{r}
cor.test(back$BackpackWeight, back$BodyWeight)
```

Результаты не различаются, потому что значение ковариации не зависит от размерности исходных шкал.

-   Посчитайте коэффициент корреляции Пирсона для веса и роста супергероев из датасета `heroes`. Проинтерпретируйте результат.

```{r}
cor.test(heroes$Weight, heroes$Height)
```

p-value меньше 0.05, поэтому мы можем отклонить нулевую гипотезу об отсутствии линейной связи между ростом и весом и принять альтернативную гипотезу о том, что такая связь есть. Судя по знаку и размеру корреляции, чем выше рост, тем выше вес супергероя, но эта связь достаточно слабая.

-   Теперь посчитайте коэффициент корреляции Спирмена и коэффициент корреляции Кэнделла для веса и роста супергероев из датасета `heroes`. Различаются ли результаты по сравнению с коэффициентом корреляции Пирсона? Почему?

```{r}
cor.test(heroes$Weight, heroes$Height, method = "spearman")
```

```{r}
cor.test(heroes$Weight, heroes$Height, method = "kendall")
```

В обоих случаях p-value меньше 0.05, поэтому мы можем отклонить нулевую гипотезу об отсутствии связи между ростом и весом и принять альтернативную гипотезу о том, что такая связь есть. Сильное различие между коэффициентами корреляции указывает на нелинейность этой связи, либо же на наличие значительных выбросов в данных.

## ANOVA {#sec-anova_solutions}

Загрузите пингвиний датасет:

```{r}
#| echo: true
#| message: false
library(tidyverse)
penguins <- readr::read_csv("https://raw.githubusercontent.com/Pozdniakov/tidy_stats/master/data/penguins.csv") %>%
  mutate(id = row_number()) #добавляем id
```

Давайте посчитаем арифметические средние по группам для различных признаков:

```{r}
#| echo: true
#| warning: false
penguins %>%
  group_by(species) %>%
  summarise(across(ends_with("_mm") | ends_with("_g"),
                   mean,
                   na.rm = TRUE))
```

-   Есть ли статистически значимые различия между видами пингвинов по массе тела (`body_mass_g`)? Если да, то между какими?\

```{r}
aov(body_mass_g ~ species, data = penguins) %>%
  summary()
aov(body_mass_g ~ species, data = penguins) %>%
  TukeyHSD()
```

-   Есть ли статистически значимые различия между видами пингвинов по длине ласт (`flipper_length_mm`)? Если да, то между какими?

```{r}
aov(flipper_length_mm ~ species, data = penguins) %>%
  summary()
aov(flipper_length_mm ~ species, data = penguins) %>%
  TukeyHSD()
```

-   Есть ли взаимодействие между полом (`sex`) и видом (`species`) для длины ласт `flipper_length_mm`? Если да, то между какими группами?

Решение с помощью `aov()`:

```{r}
aov(flipper_length_mm ~ species * sex, data = penguins) %>%
  TukeyHSD()
```

Решение с помощью пакета `{ez}`

```{r}
library(ez)
ez_species_sex <- ezANOVA(data = penguins %>% drop_na(flipper_length_mm, species, sex), 
        dv = .(flipper_length_mm),
        wid = .(id),
        between = .(species, sex),
        return_aov = TRUE)
```

```{r}
TukeyHSD(ez_species_sex$aov)
```
