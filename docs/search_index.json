[
["index.html", "Анализ данных и статистика в R 1 О курсе", " Анализ данных и статистика в R Поздняков Иван 2020-10-01 1 О курсе Здесь будут материалы для курса &quot;Анализ данных и статистика в R&quot;. Эта онлайн-книжка будет постоянно пополняться, поэтому следите за обновлениями! По всем вопросам пишите на мне на почту ivanspozdniakov@gmail.com, VK или в Telegram:@pozdniakovivan. "],
["intro.html", "2 День 1. Основы R 2.1 Знакомимся с самым базовым 2.2 Типы данных 2.3 Вектор 2.4 Матрицы (matrix) 2.5 Списки (list) 2.6 Датафрейм 2.7 Начинаем работу с реальными данными", " 2 День 1. Основы R 2.1 Знакомимся с самым базовым 2.1.1 Установка R и Rstudio Для работы с R необходимо его сначала скачать и установить. R на Windows, найдите большую кнопку Download R (номер версии) for Windows. на Mac, если маку меньше, чем 5 лет, то смело ставьте *.pkg файл с последней версией. Если старше, то поищите на той же странице версию для вашей системы. на Linux, также можно добавить зеркало и установить из командной строки: sudo apt-get install r-cran-base В данной книге используется следующая версия R: sessionInfo()$R.version$version.string ## [1] &quot;R version 4.0.2 (2020-06-22)&quot; После установки R необходимо скачать и установить RStudio: RStudio Если вдруг что-то установить не получается (или же вы просто не хотите устанавливать на компьютер лишние программы), то можно работать в облаке, делая все то же самое в веб-браузере: RStudio cloud Первый и вполне закономерный вопрос: зачем мы ставили R и отдельно еще какой-то RStudio? Если опустить незначительные детали, то R --- это сам язык программирования, а RStudio --- это среда (IDE), которая позволяет в этом языке очень удобно работать. RStudio --- это не единственная среда для R, но, определенно, самая удобная на сегодняшний день. Почти все пользуются именно ею и не стоит тратить время на поиск чего-то более удобного и лучшего. Если же вы привыкли работать с Jupyter Notebook, то в R обычно вместо него используется великолепный RMarkdown --- с помощью которого и написан этот онлайн-учебник, кстати говоря. И с RMarkdown мы тоже будем разбираться! 2.1.2 RStudio Так, давайте взглянем на то, что нам тут открылось: В первую очередь нас интересуют два окна: 1 - Code Editor (окно для написания скриптов)1 и 2 - R Console (консоль). Здесь можно писать команды и запускать их. При этом работа в консоли и работа со скриптом немного различается. В 2 - R Console вы пишите команду и запускаете ее нажиманием Enter. Иногда после запуска команды появляется какой-то результат. Если нажимать стрелку вверх на клавиатуре, то можно выводить в консоль предыдущие команды. Это очень удобно для запуска предыдущих команд с небольшими изменениями. В 1 - Code Editor для запуска команды вы должны выделить ее и нажать Ctrl + Enter (Cmd + Enter на macOS). Если не нажать эту комбинацию клавиш, то команда не запустится. Можно выделить и запустить сразу несколько команд или даже все команды скрипта. Все команды скрипта можно выделить с помощью сочетания клавиш Ctrl + A на Windows и Linux, Cmd + A на macOS.2 Как только вы запустите команду (или несколько команд), соответствующие строчки кода появятся в 2 - R Console, как будто бы вы запускали их прямо там. Обычно в консоли удобно что-то писать, чтобы быстро что-то посчитать. Скрипты удобнее при работе с длинными командами и как способ сохранения написанного кода для дальнейшей работы. Для сохранения скрипта нажмите File - Save As.... R скрипты сохраняются с разрешением .R, но по своей сути это просто текстовые файлы, которые можно открыть и модифицировать в любом текстовом редакторе а-ля &quot;Блокнот&quot;. 3 - Workspace and History --- здесь можно увидеть переменные. Это поле будет автоматически обновляться по мере того, как Вы будете запускать строчки кода и создавать новые переменные. Еще там есть вкладка с историей всех команд, которые были запущены. 4 - Plots and files. Здесь есть очень много всего. Во-первых, небольшой файловый менеджер, во-вторых, там будут появляться графики, когда вы будете их рисовать. Там же есть вкладка с вашими пакетами (Packages) и Help по функциям. Но об этом потом. 2.1.3 R как калькулятор R --- полноценный язык программирования, который позволяет решать широкий спектр задач. Но в первую очередь R используется для анализа данных и статистических вычислений. Тем не менее, многими R до сих пор воспринимается как просто продвинутый калькулятор. Ну что ж, калькулятор, так калькулятор. Давайте начнем с самого простого и попробуем использовать R как калькулятор с помощью арифметических операторов +, -, *, /, ^ (степень), () и т.д. Просто запускайте в консоли пока не надоест: 40+2 ## [1] 42 3-2 ## [1] 1 5*6 ## [1] 30 99/9 #деление ## [1] 11 2^3 #степень ## [1] 8 13 %/% 3 #целочисленное деление ## [1] 4 13 %% 3 #остаток от деления ## [1] 1 Попробуйте самостоятельно посчитать что-нибудь с разными числами. Ничего сложного, верно? Вводим выражение и получаем результат. Вы могли заметить, что некоторые команды у меня заканчиваются знаком решетки (#). Все, что написано в строчке после # игнорируется R при выполнении команды. Написанные команды в скрипте рекомендуется сопровождать комментариями, которые будут объяснять вам же в будущем (или кому-то еще), что конкретно происходит в соответствующем куске кода.3 Кроме того, комментарии можно использовать в тех случаях, когда вы хотите написать кусок кода по-другому, не стирая полностью предыдущий код: достаточно &quot;закомментить&quot; нужные строчки - поставить # в начало каждой строки, которую вы хотите переписать. Для этого есть специальное сочетание горячих клавиш: Ctrl + Shift + C (Cmd + Shift + C на macOS) --- во всех выделенных строчках будет написан # в начале. Согласно данным навязчивых рекламных баннеров в интернете, только 14% россиян могут справиться с этим примером: 2 + 2 * 2 ## [1] 6 На самом деле, разные языки программирования ведут себя по-разному в таких ситуациях, поэтому ответ 6 (сначала умножаем, потом складываем) не так очевиден. Порядок выполнения арифметических операций (т.е. приоритет операторов, operator precedence) в R как в математике, так что не забывайте про скобочки. (2+2)*2 ## [1] 8 Если Вы не уверены в том, какие операторы имеют приоритет, то используйте скобочки, чтобы точно обозначить, в каком порядке нужно производить операции. Или же смотрите на таблицу приоритета операторов с помощью команды ?Syntax. 2.1.4 Функции Давайте теперь извлечем корень из какого-нибудь числа. В принципе, тем, кто помнит школьный курс математики, возведения в степень вполне достаточно: 16^0.5 ## [1] 4 Ну а если нет, то можете воспользоваться специальной функцией: это обычно какие-то буквенные символы с круглыми скобками сразу после названия функции. Мы подаем на вход (внутрь скобочек) какие-то данные, внутри этих функций происходят какие-то вычисления, которые выдает в ответ какие-то другие данные (или же функция записывает файл, рисует график и т.д.). Вот, например, функция для корня: sqrt(16) ## [1] 4 R --- case-sensitive язык, т.е. регистр важен. SQRT(16) не будет работать. А вот так выглядит функция логарифма: log(8) ## [1] 2.079442 Так, вроде бы все нормально, но... Если Вы еще что-то помните из школьной математики, то должны понимать, что что-то здесь не так. Здесь не хватает основания логарифма! Логарифм --- показатель степени, в которую надо возвести число, называемое основанием, чтобы получить данное число. То есть у логарифма 8 по основанию 2 будет значение 3: \\(\\log_2 8 = 3\\) То есть если возвести 2 в степень 3 у нас будет 8: \\(2^3 = 8\\) Только наша функция считает все как-то не так. Чтобы понять, что происходит, нам нужно залезть в хэлп этой функции: ?log Справа внизу в RStudio появится вот такое окно: Действительно, у этой функции есть еще аргумент base =. По дефолту он равен числу Эйлера (2.7182818...), т.е. функция считает натуральный логарифм. В большинстве функций R есть какой-то основной инпут --- данные в том или ином формате, а есть и дополнительные параметры, которые можно прописывать вручную, если параметры по умолчанию нас не устраивают. log(x = 8, base = 2) ## [1] 3 ...или просто (если Вы уверены в порядке переменных): log(8,2) ## [1] 3 Более того, Вы можете использовать оутпут одних функций как инпут для других: log(8, sqrt(4)) ## [1] 3 Отличненько. Мы еще много раз будем возвращаться к функциям. Вообще, функции --- это одна из важнейших штук в R (примерно так же как и в Python). Мы будем создавать свои функции, использовать функции как инпут для функций и многое-многое другое. В R очень крутые возможности работы с функциями. Поэтому подружитесь с функциями, они клевые. Арифметические знаки, которые мы использовали: +, - , /, ^ и т.д. называются операторами и на самом деле тоже являются функциями: &#39;+&#39;(3, 4) ## [1] 7 2.1.5 Переменные Важная штука в программировании на практически любом языке --- возможность сохранять значения в переменных. В R это обычно делается с помощью вот этих символов: &lt;- (но можно использовать и обычное =, хотя это не очень принято). Для этого есть удобное сочетание клавиш: нажмите одновременно Alt + - (или option + - на macOS). a &lt;- 2 a ## [1] 2 Заметьте, при присвоении результат вычисления не выводится в консоль! Если опустить детали, то обычно результат выполнения комманды либо выводится в консоль, либо записывается в переменную. После присвоения переменная появляется во вкладке Environment в RStudio: Можно использовать переменные в функциях и просто вычислениях: b &lt;- a ^ a + a * a b ## [1] 8 log(b, a) ## [1] 3 Вы можете сравнивать разные переменные: a == b ## [1] FALSE Заметьте, что сравнивая две переменные мы используем два знака равно ==, а не один =. Иначе это будет означать присвоение. a = b a ## [1] 8 Теперь Вы сможете понять комикс про восстание роботов на следующей странице (пусть он и совсем про другой язык программирования) Этот комикс объясняет, как важно не путать присваивание и сравнение (хотя я иногда путаю до сих пор =( ). Иногда нам нужно проверить на неравенство: a &lt;- 2 b &lt;- 3 a==b ## [1] FALSE a!=b ## [1] TRUE Восклицательный язык в программировании вообще и в R в частности стандартно означает отрицание. Еще мы можем сравнивать на больше/меньше: a &gt; b ## [1] FALSE a &lt; b ## [1] TRUE a &gt;= b ## [1] FALSE a &lt;= b ## [1] TRUE 2.2 Типы данных До этого момента мы работали только с числами (numeric): class(a) ## [1] &quot;numeric&quot; Вообще, в R много типов numeric: integer (целые), double (с десятичной дробью), complex (комплексные числа). Последние пишутся так: complexnumber &lt;- 2+2i Однако в R с этим обычно можно вообще не заморачиваться, R сам будет конвертить между форматами при необходимости. Немного подробностей здесь: Разница между numeric и integer, Как работать с комплексными числами в R Теперь же нам нужно ознакомиться с двумя другими важными типами данных в R: character: строки символов. Они должны выделяться кавычками. Можно использовать как &quot;, так и ' (что удобно, когда строчка внутри уже содержит какие-то кавычки). s &lt;- &quot;Всем привет!&quot; s ## [1] &quot;Всем привет!&quot; class(s) ## [1] &quot;character&quot; logical: просто TRUE или FALSE. t1 &lt;- TRUE f1 &lt;- FALSE t1 ## [1] TRUE f1 ## [1] FALSE Вообще, можно еще писать T и F (но не True и False!) t2 &lt;- T f2 &lt;- F Это дурная практика, так как R защищает от перезаписи переменные TRUE и FALSE, но не защищает от этого T и F TRUE &lt;- FALSE ## Error in TRUE &lt;- FALSE: неправильная (do_set) левая сторона в присвоении TRUE ## [1] TRUE T &lt;- FALSE T ## [1] FALSE Теперь вы можете догадаться, что результаты сравнения, например, числовых или строковых переменных вы можете сохранять в переменные тоже! comparison &lt;- a == b comparison ## [1] FALSE Это нам очень понадобится, когда мы будем работать с реальными данными: нам нужно будет постоянно вытаскивать какие-то данные из датасета, а это как раз и построено на игре со сравнением переменных. Чтобы этим хорошо уметь пользоваться, нам нужно еще освоить как работать с логическими операторами. Про один мы немного уже говорили --- это не (!): t1 ## [1] TRUE !t1 ## [1] FALSE !!t1 #Двойное отрицание! ## [1] TRUE Еще есть И (выдаст TRUE только в том случае если обе переменные TRUE): t1 &amp; t2 ## [1] TRUE t1 &amp; f1 ## [1] FALSE А еще ИЛИ (выдаст TRUE в случае если хотя бы одна из переменных TRUE): t1 | f1 ## [1] TRUE f1 | f2 ## [1] FALSE Поздравляю, мы только что разобрались с самой занудной (но очень важной!) частью. Пора переходить к важному и интересному. ВЕКТОРАМ! 2.3 Вектор Если у вас не было линейной алгебры (или у вас с ней было все плохо), то просто запомните, что вектор (atomic vector или просто atomic) --- это набор (столбик) чисел в определенном порядке. Если вы привыкли из школьного курса физики считать вектора стрелочками, то не спешите возмущаться и паниковать. Представьте стрелочки как точки из нуля координат {0,0} до какой-то точки на координатной плоскости, например, {2,3}: Вот последние два числа и будем считать вектором. Попытайтесь теперь мысленно стереть координатную плоскость и выбросить стрелочки из головы, оставив только последовательность чисел {2,3}: На самом деле, мы уже работали с векторами в R, но, возможно, вы об этом даже не догадывались. Дело в том, что в R нет как таковых скалярных (т.е. одиночных) значений, есть вектора длиной 1. Такие дела! Чтобы создать вектор из нескольких значений, нужно воспользоваться функцией c(): c(4,8,15,16,23,42) ## [1] 4 8 15 16 23 42 Создавать вектора можно не только из numeric, но также и из character и logical: c(&quot;Хэй&quot;, &quot;Хэй&quot;, &quot;Ха&quot;) ## [1] &quot;Хэй&quot; &quot;Хэй&quot; &quot;Ха&quot; c(TRUE, FALSE) ## [1] TRUE FALSE Одна из самых мерзких и раздражающих причин ошибок в коде --- это использование с из кириллицы вместо c из латиницы. Видите разницу? И я не вижу. А R видит. Для создания числовых векторов есть удобный оператор : 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 5:-3 ## [1] 5 4 3 2 1 0 -1 -2 -3 Этот оператор создает вектор от первого числа до второго с шагом 1. Вы не представляете, как часто эта штука нам пригодится... Если же нужно сделать вектор с другим шагом, то есть функция seq(): seq(10,100, by = 10) ## [1] 10 20 30 40 50 60 70 80 90 100 Кроме того, можно задавать не шаг, а длину вектора. Тогда шаг функция seq() посчитает сама: seq(1,13, length.out = 4) ## [1] 1 5 9 13 Другая функция --- rep() --- позволяет создавать вектора с повторяющимися значениями. Первый аргумент --- значение, которое нужно повторять, а второй аргумент --- сколько раз повторять. rep(1, 5) ## [1] 1 1 1 1 1 И первый, и второй аргумент могут быть векторами! rep(1:3, 3) ## [1] 1 2 3 1 2 3 1 2 3 rep(1:3, 1:3) ## [1] 1 2 2 3 3 3 Еще можно объединять вектора (что мы, по сути, и делали, просто с векторами длиной 1): v1 &lt;- c(&quot;Hey&quot;, &quot;Ho&quot;) v2 &lt;- c(&quot;Let&#39;s&quot;, &quot;Go!&quot;) c(v1, v2) ## [1] &quot;Hey&quot; &quot;Ho&quot; &quot;Let&#39;s&quot; &quot;Go!&quot; Очень многие функции в R работают именно с векторами. Например, функции sum() (считает сумму значений вектора) и mean() (считает среднее арифметическое всех значений в векторе): sum(1:10) ## [1] 55 mean(1:10) ## [1] 5.5 2.3.1 Приведение типов Что будет, если вы объедините два вектора с значениями разных типов? Ошибка? Мы уже обсуждали, что в atomic может быть только один тип данных. В некоторых языках программирования при операции с данными разных типов мы бы получили ошибку. А вот в R при несовпадении типов пройзойдет попытка привести типы к &quot;общему знаменателю&quot;, то есть конвертировать данные в более &quot;широкий&quot; тип. Например: c(FALSE, 2) ## [1] 0 2 FALSE превратился в 0 (а TRUE превратился бы в 1), чтобы оба значения можно было объединить в вектор. То же самое произошло бы в случае операций с векторами: 2 + TRUE ## [1] 3 Это называется неявным приведением типов (implicit coercion). Вот более сложный пример: c(TRUE, 3, &quot;Привет&quot;) ## [1] &quot;TRUE&quot; &quot;3&quot; &quot;Привет&quot; У R есть иерархия приведения типов: NULL &lt; raw &lt; logical &lt; integer &lt; double &lt; complex &lt; character &lt; list &lt; expression. Мы из этого списка еще многого не знаем, сейчас важно запомнить, что логические данные --- TRUE и FALSE --- превращаются в 0 и 1 соответственно, а 0 и 1 в строчки &quot;0&quot; и &quot;1&quot;. Если Вы боитесь полагаться на приведение типов, то можете воспользоваться функциями as.нужныйтипданных для явного приведения типов (explicit coercion): as.numeric(c(T, F, F)) ## [1] 1 0 0 as.character(as.numeric(c(T, F, F))) ## [1] &quot;1&quot; &quot;0&quot; &quot;0&quot; Можно превращать и обратно, например, строковые значения в числовые. Если среди числа встретится буква или другой неподходящий знак, то мы получим предупреждение NA --- пропущенное значение (мы очень скоро научимся с ними работать). as.numeric(c(&quot;1&quot;, &quot;2&quot;, &quot;три&quot;)) ## Warning: в результате преобразования созданы NA ## [1] 1 2 NA Один из распространенных примеров использования неявного приведения типов --- использования функций sum() и mean() для подсчета в логическом векторе количества и доли TRUE соответсвенно. Мы будем много раз пользоваться этим приемом в дальнейшем! 2.3.2 Векторизация Все те арифметические операторы, что мы использовали ранее, можно использовать с векторами одинаковой длины: n &lt;- 1:4 m &lt;- 4:1 n + m ## [1] 5 5 5 5 n - m ## [1] -3 -1 1 3 n * m ## [1] 4 6 6 4 n / m ## [1] 0.2500000 0.6666667 1.5000000 4.0000000 n ^ m + m * (n - m) ## [1] -11 5 11 7 Если применить операторы на двух векторах одинаковой длины, то мы получим результат поэлементного применения оператора к двум векторам. Это называется векторизацией (vectorization). Если после какого-нибудь MATLAB Вы привыкли, что по умолчанию операторы работают по правилам линейной алгебры и m*n будет давать скалярное произведение (dot product), то снова нет. Для скалярного произведения нужно использовать операторы с % по краям: n %*% m ## [,1] ## [1,] 20 Абсолютно так же и с операциями с матрицами в R, хотя про матрицы будет немного позже. В принципе, большинство функций в R, которые работают с отдельными значениями, так же хорошо работают и с целыми векторами. Скажем, Вы хотите извлечь корень из нескольких чисел, для этого не нужны никакие циклы (как это обычно делается в других языках программирования). Можно просто &quot;скормить&quot; вектор функции и получить результат применения функции к каждому элементу вектора: sqrt(1:10) ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427 ## [9] 3.000000 3.162278 Таких векторизованных функций в R очень много. Многие из них написаны на более низкоуровневых языках программирования (C, C++, FORTRAN), за счет чего использование таких функций приводит не только к более элегантному, лаконичному, но и к более быстрому коду. Векторизация в R --- это очень важная фишка, которая отличает этот язык программирования от многих других. Если вы уже имеете опыт программирования на другом языке, то вам во многих задачах захочется использовать циклы типа for и while ??. Не спешите этого делать! В очень многих случаях циклы можно заменить векторизацией. Тем не менее, векторизация --- это не единственный способ избавить от циклов типа for и while ??. 2.3.3 Ресайклинг Допустим мы хотим совершить какую-нибудь операцию с двумя векторами. Как мы убедились, с этим обычно нет никаких проблем, если они совпадают по длине. А что если вектора не совпадают по длине? Ничего страшного! Здесь будет работать правило ресайклинга (правило переписывания, recycling rule). Это означает, что если мы делаем операцию на двух векторах разной длины, то если короткий вектор кратен по длине длинному, короткий вектор будет повторяться необходимое количество раз: n &lt;- 1:4 m &lt;- 1:2 n * m ## [1] 1 4 3 8 А что будет, если совершать операции с вектором и отдельным значением? Можно считать это частным случаем ресайклинга: короткий вектор длиной 1 будет повторятся столько раз, сколько нужно, чтобы он совпадал по длине с длинным: n * 2 ## [1] 2 4 6 8 Если же меньший вектор не кратен большему (например, один из них длиной 3, а другой длиной 4), то R посчитает результат, но выдаст предупреждение. n + c(3,4,5) ## Warning in n + c(3, 4, 5): длина большего объекта не является произведением ## длины меньшего объекта ## [1] 4 6 8 7 Проблема в том, что эти предупреждения могут в неожиданный момент стать причиной ошибок. Поэтому не стоит полагаться на ресайклинг некратных по длине векторов. См. здесь. А вот ресайклинг кратных по длине векторов --- это очень удобная штука, которая используется очень часто. 2.3.4 Индексирование векторов Итак, мы подошли к одному из самых сложных моментов. И одному из основных. От того, как хорошо вы научись с этим работать, зависит весь ваш дальнейший успех на R-поприще! Речь пойдет об индексировании векторов. Задача, которую Вам придется решать каждые пять минут работы в R --- как выбрать из вектора (или же списка, матрицы и датафрейма) какую-то его часть. Для этого используются квадратные скобочки [] (не круглые --- они для функций!). Самое простое --- индексировать по номеру индекса, т.е. порядку значения в векторе. n &lt;- 1:10 n[1] ## [1] 1 n[10] ## [1] 10 Если вы знакомы с другими языками программирования (не MATLAB, там все так же) и уже научились думать, что индексация с 0 --- это очень удобно и очень правильно (ну или просто свыклись с этим), то в R Вам придется переучиться обратно. Здесь первый индекс --- это 1, а последний равен длине вектора --- ее можно узнать с помощью функции length(). С обоих сторон индексы берутся включительно. С помощью индексирования можно не только вытаскивать имеющиеся значения в векторе, но и присваивать им новые: n[3] &lt;- 20 n ## [1] 1 2 20 4 5 6 7 8 9 10 Конечно, можно использовать целые векторы для индексирования: n[4:7] ## [1] 4 5 6 7 n[10:1] ## [1] 10 9 8 7 6 5 4 20 2 1 Индексирование с минусом выдаст вам все значения вектора кроме выбранных: n[-1] ## [1] 2 20 4 5 6 7 8 9 10 n[c(-4, -5)] ## [1] 1 2 20 6 7 8 9 10 Минус здесь &quot;выключает&quot; выбранные значения из вектора, а не означает отсчет с конца как в Python. Более того, можно использовать логический вектор для индексирования. В этом случае нужен логический вектор такой же длины: n[c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE)] ## [1] 1 20 5 7 9 Логический вектор работает здесь как фильтр: пропускает только те значения, где на соответствующей позиции в логическом векторе для индексирования содержится TRUE, и не пропускает те значения, где на соответствующей позиции в логическом векторе для индексирования содержится FALSE. Ну а если эти два вектора (исходный вектор и логический вектор индексов) не равны по длине, то тут будет снова работать правило ресайклинга! n[c(TRUE, FALSE)] #то же самое - recycling rule! ## [1] 1 20 5 7 9 Есть еще один способ индексирования векторов, но он несколько более редкий: индексирование по имени. Дело в том, что для значений векторов можно (но не обязательно) присваивать имена: my_named_vector &lt;- c(first = 1, second = 2, third = 3) my_named_vector[&#39;first&#39;] ## first ## 1 А еще можно &quot;вытаскивать&quot; имена из вектора с помощью функции names() и присваивать таким образом новые имена. d &lt;- 1:4 names(d) &lt;- letters[1:4] d[&quot;a&quot;] ## a ## 1 letters --- это &quot;зашитая&quot; в R константа --- вектор букв от a до z. Иногда это очень удобно! Кроме того, есть константа LETTERS --- то же самое, но заглавными буквами. А еще в R есть названия месяцев на английском и числовая константа pi. Теперь посчитаем среднее вектора n: mean(n) ## [1] 7.2 А как вытащить все значения, которые больше среднего? Сначала получим логический вектор --- какие значения больше среднего: larger &lt;- n&gt;mean(n) larger ## [1] FALSE FALSE TRUE FALSE FALSE FALSE FALSE TRUE TRUE TRUE А теперь используем его для индексирования вектора n: n[larger] ## [1] 20 8 9 10 Можно все это сделать в одну строчку: n[n&gt;mean(n)] ## [1] 20 8 9 10 Предыдущая строчка отражает то, что мы будем постоянно делать в R: вычленять (subset) из данных отдельные куски на основании разных условий. 2.3.5 NA - пропущенные значения В реальных данных у нас часто чего-то не хватает. Например, из-за технической ошибки или невнимательности не получилось записать какое-то измерение. Для обозначения пропущенных значений в R есть специальное значение NA (расшифровывается как Not Available - недоступное значение). NA --- это не строка &quot;NA&quot;, не 0, не пустая строка &quot;&quot; и не FALSE. NA --- это NA. Большинство операций с векторами, содержащими NA будут выдавать NA: missed &lt;- NA missed == &quot;NA&quot; ## [1] NA missed == &quot;&quot; ## [1] NA missed == NA ## [1] NA Заметьте: даже сравнение NA c NA выдает NA! Иногда NA в данных очень бесит: n[5] &lt;- NA n ## [1] 1 2 20 4 NA 6 7 8 9 10 mean(n) ## [1] NA Что же делать? Наверное, надо сравнить вектор с NA и исключить этих пакостников. Давайте попробуем: n == NA ## [1] NA NA NA NA NA NA NA NA NA NA Ах да, мы ведь только что узнали, что даже сравнение NA c NA приводит к NA! Чтобы выбраться из этой непростой ситуации, используйте функцию is.na(): is.na(n) ## [1] FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE Результат выполнения is.na(n) выдает FALSE в тех местах, где у нас числа и TRUE там, где у нас NA. Чтобы вычленить из вектора n все значения кроме NA нам нужно, чтобы было наоборот: TRUE, если это не NA, FALSE, если это NA. Здесь нам понадобится логический оператор НЕ ! (мы его уже встречали), который инвертирует логические значения: n[!is.na(n)] ## [1] 1 2 20 4 6 7 8 9 10 Ура, мы можем считать среднее! mean(n[!is.na(n)]) ## [1] 7.444444 Теперь Вы понимаете, зачем нужно отрицание (!) Вообще, есть еще один из способов посчитать среднее, если есть NA. Для этого надо залезть в хэлп по функции mean(): ?mean() В хэлпе мы найдем параметр na.rm =, который по умолчанию FALSE. Вы знаете, что нужно делать! mean(n, na.rm = T) ## [1] 7.444444 NA может появляться в векторах других типов тоже. На самом деле, NA - это специальное значение в логических векторах, тогда как в векторах других типов NA появляется как NA_integer_, NA_real_, NA_complex_ или NA_character_, но R обычно сам все переводит в нужный формат и показывает как просто NA. Кроме NA есть еще NaN --- это разные вещи. NaN расшифровывается как Not a Number и получается в результате таких операций как 0 / 0. Тем не менее, функция is.na() выдает TRUE на NaN, а вот функция is.nan() выдает TRUE на NaN и FALSE на NA: is.na(NA) ## [1] TRUE is.na(NaN) ## [1] TRUE is.nan(NA) ## [1] FALSE is.nan(NaN) ## [1] TRUE 2.3.6 В любой непонятной ситуации --- гуглите Если вдруг вы не знаете, что искать в хэлпе, или хэлпа попросту недостаточно, то... гуглите! Нет ничего постыдного в том, чтобы гуглить решения проблем. Это абсолютно нормально. Используйте силу интернета во благо и да помогут вам Stackoverflow4 и бесчисленные R-туториалы! Computer Programming To Be Officially Renamed “Googling Stack Overflow”Source: http://t.co/xu7acfXvFF pic.twitter.com/iJ9k7aAVhd — Stack Exchange ((???)) July 20, 2015 Главное, помните: загуглить работающий ответ всегда недостаточно. Надо понять, как и почему решение работает. Иначе что-то обязательно пойдет не так. Кроме того, правильно загуглить проблему --- не так уж и просто. Does anyone ever get good at R or do they just get good at googling how to do things in R — 🔬🖤Lauren M. Seyler, Ph.D.❤️⚒ ((???)) May 6, 2019 Итак, с векторами мы более-менее разобрались. Помните, что вектора --- это один из краеугольных камней вашей работы в R. Если вы хорошо с ними разобрались, то дальше все будет довольно несложно. Тем не менее, вектора --- это не все. Есть еще два важных типа данных: списки (list) и матрицы (matrix). Их можно рассматривать как своеобразное &quot;расширение&quot; векторов, каждый в свою сторону. Ну а списки и матрицы нужны чтобы понять основной тип данных в R --- data.frame. 2.4 Матрицы (matrix) Если вдруг вас пугает это слово, то совершенно зря. Матрица --- это всего лишь &quot;двумерный&quot; вектор: вектор, у которого есть не только длина, но и ширина. Создать матрицу можно с помощью функции matrix() из вектора, указав при этом количество строк и столбцов. A &lt;- matrix(1:20, nrow=5,ncol=4) A ## [,1] [,2] [,3] [,4] ## [1,] 1 6 11 16 ## [2,] 2 7 12 17 ## [3,] 3 8 13 18 ## [4,] 4 9 14 19 ## [5,] 5 10 15 20 Заметьте, значения вектора заполняются следующим образом: сначала заполняется первый столбик сверху вниз, потом второй сверху вниз и так до конца, т.е. заполнение значений матрицы идет в первую очередь по вертикали. Это довольно стандартный способ создания матриц, характерный не только для R. Если мы знаем сколько значений в матрице и сколько мы хотим строк, то количество столбцов указывать необязательно: A &lt;- matrix(1:20, nrow=5) A ## [,1] [,2] [,3] [,4] ## [1,] 1 6 11 16 ## [2,] 2 7 12 17 ## [3,] 3 8 13 18 ## [4,] 4 9 14 19 ## [5,] 5 10 15 20 Все остальное так же как и с векторами: внутри находится данные только одного типа. Поскольку матрица --- это уже двумерный массив, то у него имеется два индекса. Эти два индекса разделяются запятыми. A[2,3] ## [1] 12 A[2:4, 1:3] ## [,1] [,2] [,3] ## [1,] 2 7 12 ## [2,] 3 8 13 ## [3,] 4 9 14 Первый индекс --- выбор строк, второй индекс --- выбор колонок. Если же мы оставляем пустое поле вместо числа, то мы выбираем все строки/колонки в зависимости от того, оставили мы поле пустым до или после запятой: A[, 1:3] ## [,1] [,2] [,3] ## [1,] 1 6 11 ## [2,] 2 7 12 ## [3,] 3 8 13 ## [4,] 4 9 14 ## [5,] 5 10 15 A[2:4, ] ## [,1] [,2] [,3] [,4] ## [1,] 2 7 12 17 ## [2,] 3 8 13 18 ## [3,] 4 9 14 19 A[, ] ## [,1] [,2] [,3] [,4] ## [1,] 1 6 11 16 ## [2,] 2 7 12 17 ## [3,] 3 8 13 18 ## [4,] 4 9 14 19 ## [5,] 5 10 15 20 Так же как и в случае с обычными векторами, часть матрицы можно переписать: A[2:4, 2:4] &lt;- 100 A ## [,1] [,2] [,3] [,4] ## [1,] 1 6 11 16 ## [2,] 2 100 100 100 ## [3,] 3 100 100 100 ## [4,] 4 100 100 100 ## [5,] 5 10 15 20 В принципе, это все, что нам нужно знать о матрицах. Матрицы используются в R довольно редко, особенно по сравнению, например, с MATLAB. Но вот индексировать матрицы хорошо бы уметь: это понадобится в работе с датафреймами. То, что матрица --- это просто двумерный вектор, не является метафорой: в R матрица --- это по сути своей вектор с дополнительными атрибутами dim и (опционально) dimnames. Атрибуты --- это свойства объектов, своего рода &quot;метаданные&quot;. Для всех объектов есть обязательные атрибуты типа и длины и могут быть любые необязательные атрибуты. Можно задавать свои атрибуты или удалять уже присвоенные: удаление атрибута dim у матрицы превратит ее в обычный вектор. Про атрибуты подробнее можно почитать здесь или на стр. 99-101 книги &quot;R in a Nutshell&quot; (Adler 2010). 2.5 Списки (list) Теперь представим себе вектор без ограничения на одинаковые данные внутри. И получим список! simple_list &lt;- list(42, &quot;Пам пам&quot;, TRUE) simple_list ## [[1]] ## [1] 42 ## ## [[2]] ## [1] &quot;Пам пам&quot; ## ## [[3]] ## [1] TRUE А это значит, что там могут содержаться самые разные данные, в том числе и другие списки и векторы! complex_list &lt;- list(c(&quot;Wow&quot;, &quot;this&quot;, &quot;list&quot;, &quot;is&quot;, &quot;so&quot;, &quot;big&quot;), &quot;16&quot;, simple_list) complex_list ## [[1]] ## [1] &quot;Wow&quot; &quot;this&quot; &quot;list&quot; &quot;is&quot; &quot;so&quot; &quot;big&quot; ## ## [[2]] ## [1] &quot;16&quot; ## ## [[3]] ## [[3]][[1]] ## [1] 42 ## ## [[3]][[2]] ## [1] &quot;Пам пам&quot; ## ## [[3]][[3]] ## [1] TRUE Если у нас сложный список, то есть очень классная функция, чтобы посмотреть, как он устроен, под названием str(): str(complex_list) ## List of 3 ## $ : chr [1:6] &quot;Wow&quot; &quot;this&quot; &quot;list&quot; &quot;is&quot; ... ## $ : chr &quot;16&quot; ## $ :List of 3 ## ..$ : num 42 ## ..$ : chr &quot;Пам пам&quot; ## ..$ : logi TRUE Представьте, что список - это такое дерево с ветвистой структурой. А на конце этих ветвей - листья-векторы. Как и в случае с векторами мы можем давать имена элементам списка: named_list &lt;- list(age = 24, PhDstudent = T, language = &quot;Russian&quot;) named_list ## $age ## [1] 24 ## ## $PhDstudent ## [1] TRUE ## ## $language ## [1] &quot;Russian&quot; К списку можно обращаться как с помощью индексов, так и по именам. Начнем с последнего: named_list$age ## [1] 24 А вот с индексами сложнее, и в этом очень легко запутаться. Давайте попробуем сделать так, как мы делали это раньше: named_list[1] ## $age ## [1] 24 Мы, по сути, получили элемент списка --- просто как часть списка, т.е. как список длиной один: class(named_list) ## [1] &quot;list&quot; class(named_list[1]) ## [1] &quot;list&quot; А вот чтобы добраться до самого элемента списка (и сделать с ним что-то хорошее) нам нужна не одна, а две квадратных скобочки: named_list[[1]] ## [1] 24 class(named_list[[1]]) ## [1] &quot;numeric&quot; Indexing lists in #rstats. Inspired by the Residence Inn pic.twitter.com/YQ6axb2w7t — Hadley Wickham ((???)) September 14, 2015 Как и в случае с вектором, к элементу списка можно обращаться по имени. named_list[[&#39;age&#39;]] ## [1] 24 Хотя последнее --- практически то же самое, что и использование знака $. Списки довольно часто используются в R, но реже, чем в Python. Со многими объектами в R, такими как результаты статистических тестов, удобно работать именно как со списками --- к ним все вышеописанное применимо. Кроме того, некоторые данные мы изначально получаем в виде древообразной структуры --- хочешь не хочешь, а придется работать с этим как со списком. Но обычно после этого стоит как можно скорее превратить список в датафрейм. 2.6 Датафрейм Итак, мы перешли к самому главному. Самому-самому. Датафреймы (data.frames). Более того, сейчас станет понятно, зачем нам нужно было разбираться со всеми предыдущими темами. Без векторов мы не смогли бы разобраться с матрицами и списками. А без последних мы не сможем понять, что такое датафрейм. name &lt;- c(&quot;Ivan&quot;, &quot;Eugeny&quot;, &quot;Lena&quot;, &quot;Misha&quot;, &quot;Sasha&quot;) age &lt;- c(26, 34, 23, 27, 26) student &lt;- c(F, F, T, T, T) df &lt;- data.frame(name, age, student) df str(df) ## &#39;data.frame&#39;: 5 obs. of 3 variables: ## $ name : chr &quot;Ivan&quot; &quot;Eugeny&quot; &quot;Lena&quot; &quot;Misha&quot; ... ## $ age : num 26 34 23 27 26 ## $ student: logi FALSE FALSE TRUE TRUE TRUE Вообще, очень похоже на список, не правда ли? Так и есть, датафрейм --- это что-то вроде проименованного списка, каждый элемент которого является atomic вектором фиксированной длины. Скорее всего, список Вы представляли &quot;горизонтально&quot;. Если это так, то теперь &quot;переверните&quot; его у себя в голове на 90 градусов. Так, чтоб названия векторов оказались сверху, а колонки стали столбцами. Поскольку длина всех этих векторов равна (обязательное условие!), то данные представляют собой табличку, похожую на матрицу. Но в отличие от матрицы, разные столбцы могут имет разные типы данных: первая колонка --- character, вторая колонка --- numeric, третья колонка --- logical. Тем не менее, обращаться с датафреймом можно и как с проименованным списком, и как с матрицей: df$age[2:3] ## [1] 34 23 Здесь мы сначала вытащили колонку age с помощью оператора $. Результатом этой операции является числовой вектор, из которого мы вытащили кусок, выбрав индексы 2 и 3. Используя оператор $ и присваивание можно создавать новые колонки датафрейма: df$lovesR &lt;- T #правило recycling - узнали? df Ну а можно просто обращаться с помощью двух индексов через запятую, как мы это делали с матрицей: df[3:5, 2:3] Как и с матрицами, первый индекс означает строчки, а второй --- столбцы. А еще можно использовать названия колонок внутри квадратных скобок: df[1:2,&quot;age&quot;] ## [1] 26 34 И здесь перед нами открываются невообразимые возможности! Узнаем, любят ли R те, кто моложе среднего возраста в группе: df[df$age &lt; mean(df$age), 4] ## [1] TRUE TRUE TRUE TRUE Эту же задачу можно выполнить другими способами: df$lovesR[df$age &lt; mean(df$age)] ## [1] TRUE TRUE TRUE TRUE df[df$age &lt; mean(df$age), &#39;lovesR&#39;] ## [1] TRUE TRUE TRUE TRUE В большинстве случаев подходят сразу несколько способов --- тем не менее, стоит овладеть ими всеми. Датафреймы удобно просматривать в RStudio. Для это нужно написать команду View(df) или же просто нажать на названии нужной переменной из списка вверху справа (там где Environment). Тогда увидите табличку, очень похожую на Excel и тому подобные программы для работы с таблицами. Там же есть и всякие возможности для фильтрации, сортировки и поиска...5 Но, конечно, интереснее все эти вещи делать руками, т.е. с помощью написания кода. На этом пора заканчивать с введением и приступать к работе с реальными данными. 2.7 Начинаем работу с реальными данными Итак, пришло время перейти к реальным данным. Мы начнем с использования датасета (так мы будем называть любой набор данных) по Игре Престолов, а точнее, по книгам цикла &quot;Песнь льда и пламени&quot; Дж. Мартина. Да, будут спойлеры, но сериал уже давно закончился и сильно разошелся с книгами... 2.7.1 Рабочая папка и проекты Для начала скачайте файл по ссылке Он, скорее всего, появился у Вас в папке &quot;Загрузки&quot;. Если мы будем просто пытаться прочитать этот файл (например, с помощью read.csv() --- мы к этой функцией очень скоро перейдем), указав его имя и разрешение, то наткнемся на такую ошибку: read.csv(&quot;character-deaths.csv&quot;) ## Warning in file(file, &quot;rt&quot;): не могу открыть файл &#39;character-deaths.csv&#39;: No ## such file or directory ## Error in file(file, &quot;rt&quot;): не могу открыть соединение Это означает, что R не может найти нужный файл. Вообще-то мы даже не сказали, где искать. Нам нужно как-то совместить место, где R ищет загружаемые файлы и сами файлы. Для этого есть несколько способов. Магомет идет к горе: перемещение файлов в рабочую папку. Для этого нужно узнать, какая папка является рабочей с помощью функции getwd() (без аргументов), найти эту папку в проводнике и переместить туда файл. После этого можно использовать просто название файла с разрешением: got &lt;- read.csv(&quot;character-deaths.csv&quot;) Гора идет к Магомету: изменение рабочей папки. Можно просто сменить рабочую папку с помощью setwd() на ту, где сейчас лежит файл, прописав путь до этой папки. Теперь файл находится в рабочей папке: got &lt;- read.csv(&quot;character-deaths.csv&quot;) Этот вариант использовать не рекомендуется. Как минимум, это сразу делает невозможным запустить скрипт на другом компьютере. Гора находит Магомета по месту прописки: указание полного пути файла. got &lt;- read.csv(&quot;/Users/Username/Some_Folder/character-deaths.csv&quot;) Этот вариант страдает теми же проблемами, что и предыдущий, поэтому тоже не рекомендуется. Для пользователей Windows есть дополнительная сложность: знак / является особым знаком для R, поэтому вместо него нужно использовать двойной //. Магомет использует кнопочный интерфейс: Import Dataset. Во вкладке Environment справа в окне RStudio есть кнопка Import Dataset. Возможно, у Вас возникло непреодолимое желание отдохнуть от написания кода и понажимать кнопочки --- сопротивляйтесь этому всеми силами, но не вините себя, если не сдержитесь. Гора находит Магомета в интернете. Многие функции в R, предназначенные для чтения файлов, могут прочитать файл не только на Вашем компьютере, но и сразу из интернета. Для этого просто используйте ссылку вместо пути: got &lt;- read.csv(&quot;https://raw.githubusercontent.com/Pozdniakov/stats/master/data/character-deaths.csv&quot;) Каждый Магомет получает по своей горе: использование проектов в RStudio. File - New Project..., Затем New Directory, New Project, выбираете подходящее Directory Name и нажимаете Create Project. На первый взгляд это кажется чем-то очень сложным, но это не так. Пользоваться проектами очень просто и ОЧЕНЬ удобно. При создании проекта создается отдельная папочка, где у Вас лежат данные, хранятся скрипты, вспомогательные файлы и отчеты. Если нужно вернуться к другому проекту --- просто открываете другой проект, с другими файлами и скриптами. Это еще помогает не пересекаться переменным из разных проектов --- а то, знаете, использование двух переменных data в разных скриптах чревато ошибками. Поэтому очень удобным решением будет выделение отдельного проекта под этот курс. А еще проекты очень удобно работают совместно с системами контроля версий, в частности, с Git. В RStudio есть для этого удобные инструменты. Самый простой способ --- при создании проекта File - New Project... выбрать Version Control, затем выбрать Git или Subversion и указать ссылку на репозиторий. После этого RStudio его склонирует и все сам настроит. Вот здесь есть подробный туториал по работе с Git и RStudio. 2.7.2 Импорт данных Как Вы уже поняли, импортирование данных --- одна из самых муторных и неприятных вещей в R. Если у Вас получится с этим справиться, то все остальное --- ерунда. Мы уже разобрались с первой частью этого процесса --- нахождением файла с данными, осталось научиться их читать. Здесь стоит сделать небольшую ремарку. Довольно часто данные представляют собой табличку. Или же их можно свести к табличке. Такая табличка, как мы уже выяснили, удобно репрезентируется в виде датафрейма. Но как эти данные хранятся на компьютере? Есть два варианта: в бинарном и в текстовом файле. Текстовый файл означает, что такой файл можно открыть в программе &quot;Блокнот&quot; или ее аналоге и увидеть напечатанный текст: скрипт, роман или упорядоченный набор цифр и букв. Нас сейчас интересует именно последний случай. Таблица может быть представлена как текст: отдельные строчки в файле будут разделять разные строчки таблицы, а какой-нибудь знак-разделитель отделет колонки друг от друга. Для чтения данных из текстового файла есть довольно удобная функция read.table(). Почитайте хэлп по ней и ужаснитесь: столько разных параметров на входе! Но там же вы увидете функции read.csv(), read.csv2() и некоторые другие --- по сути, это тот же read.table(), но с другими дефолтными параметрами, соответствующие формату файла, который мы загружаем. В данном случае используется формат .csv, что означает Comma Separated Values (Значения, Разделенные Запятыми). Это просто текстовый файл, в котором &quot;закодирована&quot; таблица: разные строчки разделяют разные строчки таблицы, а столбцы отделяются запятыми. С этим связана одна проблема: в некоторых странах (в т.ч. и России) принято использовать запятую для разделения дробной части числа, а не точку, как это делается в большинстве стран мира. Поэтому есть &quot;другой&quot; формат .csv, где значения разделены точкой с запятой (;), а дробные значения --- запятой (,). В этом и различие функций read.csv() и read.csv2() --- первая функция предназначена для &quot;международного&quot; формата, вторая --- для (условно) &quot;Российского&quot;. В первой строчке обычно содержатся названия столбцов --- и это чертовски удобно, функции read.csv() и read.csv2() по умолчанию считают первую строчку именно как название для колонок. Итак, прочитаем наш файл. Для этого используем только параметр file =, который идет первым, и для параметра stringsAsFactors = поставим значение FALSE: got &lt;- read.csv(&quot;data/character-deaths.csv&quot;, stringsAsFactors = FALSE) По умолчанию, функции семейства read.table() читают character переменные как фактор (factor). По сути, факторы --- это примерно то же самое, что и character, но закодированные числами. Когда-то это было придумано для экономии используемых времени и памяти: вместо того, чтобы хранить многократно &quot;male&quot; и &quot;female&quot;, можно закодировать их числами 1 и 2, записав отдельно, как расшифровывается 1 и 2. На сегодняшний день факторы обычно становится просто лишней морокой, хотя факторы могут быть удобным инструментом для контроля порядка значений при визуализации данных. Некоторые функции требуют именно character, некоторые factor, в большинстве случаев это без разницы. Но иногда непонимание может привести к дурацким ошибкам. В данном случае мы просто пока обойдемся без факторов. Можете проверить с помощью View(got): все работает! Если же вылезает какая-то странная ерунда или же просто ошибка --- попробуйте другие функции и покопаться с параметрами. Для этого читайте Help. Кроме .csv формата есть и другие варианты хранения таблиц в виде текста. Например, .tsv --- тоже самое, что и .csv, но разделитель --- знак табуляции. Для чтения таких файлов есть функция read.delim() и read.delim2(). Впрочем, даже если бы ее и не было, можно было бы просто подобрать нужные параметры для функции read.table(). Есть даже функции (например, fread() из пакета data.table --- мы ее будем использовать завтра!), которые пытаются сами &quot;угадать&quot; нужные параметры для чтения --- часто они справляются с этим довольно удачно. Но не всегда. Поэтому стоит научиться справляться с любого рода данными на входе. Тем не менее, далеко не всегда таблицы представлены в виде текстового файла. Самый распространенный пример таблицы в бинарном виде --- родные форматы Microsoft Excel. Если Вы попробуете открыть .xlsx файл в Блокноте, то увидите кракозябры. Это делает работу с этим файлами гораздо менее удобной, поэтому стоит избегать экселевских форматов и стараться все сохранять в .csv. Для работы с экселевскими файлами есть много пакетов: readxl, xlsx, openxlsx. Для чтения файлов SPSS, Stata, SAS есть пакет foreign. Что такое пакеты и как их устанавливать мы изучим позже. "]
]
