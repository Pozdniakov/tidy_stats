\documentclass[]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\PassOptionsToPackage{hyphens}{url} % url is loaded by hyperref
\usepackage[unicode=true]{hyperref}
\hypersetup{
            pdftitle={A Minimal Book Example},
            pdfauthor={Yihui Xie},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{natbib}
\bibliographystyle{apalike}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\usepackage{longtable,booktabs}
% Fix footnotes in tables (requires footnote package)
\IfFileExists{footnote.sty}{\usepackage{footnote}\makesavenoteenv{long table}}{}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\usepackage{booktabs}

\title{A Minimal Book Example}
\author{Yihui Xie}
\date{2020-09-16}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\chapter{Prerequisites}\label{prerequisites}

This is a \emph{sample} book written in \textbf{Markdown}. You can use
anything that Pandoc's Markdown supports, e.g., a math equation
\(a^2 + b^2 = c^2\).

The \textbf{bookdown} package can be installed from CRAN or Github:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"bookdown"}\NormalTok{)}
\CommentTok{# or the development version}
\CommentTok{# devtools::install_github("rstudio/bookdown")}
\end{Highlighting}
\end{Shaded}

Remember each Rmd file contains one and only one chapter, and a chapter
is defined by the first-level heading \texttt{\#}.

To compile this example to PDF, you need XeLaTeX. You are recommended to
install TinyTeX (which includes XeLaTeX):
\url{https://yihui.name/tinytex/}.

\chapter{День 1. Основы R}\label{intro}

\section{Знакомимся с самым базовым}\label{very_base}

\subsection{Установка R и Rstudio}\label{install}

Для работы с R необходимо его сначала скачать и установить.

\begin{itemize}
\tightlist
\item
  R

  \begin{itemize}
  \tightlist
  \item
    \href{https://cran.r-project.org/bin/windows/base/}{на Windows},
    найдите большую кнопку \textbf{Download R (номер версии) for
    Windows.}
  \item
    \href{https://cran.r-project.org/bin/macosx/}{на Mac}, если маку
    меньше, чем 5 лет, то смело ставьте *.pkg файл с последней версией.
    Если старше, то поищите на той же странице версию для вашей системы.
  \item
    \href{https://cran.rstudio.com/bin/linux/}{на Linux}, также можно
    добавить зеркало и установить из командной строки:
  \end{itemize}
\end{itemize}

\begin{verbatim}
sudo apt-get install r-cran-base
\end{verbatim}

В данной книге используется следующая версия R:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sessionInfo}\NormalTok{()}\OperatorTok{$}\NormalTok{R.version}\OperatorTok{$}\NormalTok{version.string}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "R version 3.6.0 (2019-04-26)"
\end{verbatim}

После установки R необходимо скачать и установить RStudio:

\begin{itemize}
\tightlist
\item
  \href{https://www.rstudio.com/products/rstudio/download/}{RStudio}
\end{itemize}

Если вдруг что-то установить не получается (или же вы просто не хотите
устанавливать на компьютер лишние программы), то можно работать в
облаке, делая все то же самое в веб-браузере:

\begin{itemize}
\tightlist
\item
  \href{https://rstudio.cloud/}{RStudio cloud}
\end{itemize}

Первый и вполне закономерный вопрос: зачем мы ставили R и отдельно еще
какой-то RStudio? Если опустить незначительные детали, то R --- это сам
язык программирования, а RStudio --- это среда (IDE), которая позволяет
в этом языке очень удобно работать.

\begin{quote}
RStudio --- это единственная среда для R, но, определенно, самая удобная
на сегодняшний день, у нее практически нет конкурентов. Почти все
пользуются именно ею и не стоит тратить время на поиск чего-то более
удобного и лучшего. Если же вы привыкли работать с Jupyter Notebook
\end{quote}

\begin{quote}
Естественно, RStudio --- не единственная среда для R, но, определенно,
самая крутая. Почти все пользуются именно ею и не стоит тратить время на
поиск чего-то более удобного и лучшего. Если Вы привыкли к Jupyter
Notebook, то здесь тоже есть ноутбуки (RNotebook --- хотя это и не
совсем то же самое), но еще есть и кое-что покруче --- RMarkdown. И с
этим мы тоже разберемся!
\end{quote}

\subsection{RStudio}\label{rstudio}

Так, давайте взглянем на то, что нам тут открылось:

\begin{figure}
\centering
\includegraphics{images/01_01_rstudio.png}
\caption{}
\end{figure}

В первую очередь нас интересуют два окна: \textbf{1 - Code Editor} (окно
для написания скриптов) \footnote{При первом запуске RStudio вы не
  увидите это окно. Для того, чтобы оно появилось, нужно нажать
  \texttt{File\ -\ New\ File\ -\ R\ Script}.} и \textbf{2 - R Console}
(консоль). Здесь можно писать команды и запускать их. При этом работа в
консоли и работа со скриптом немного различается.

В \textbf{2 - R Console} вы пишите команду и запускаете ее нажиманием
\texttt{Enter}. Иногда после запуска команды появляется какой-то
результат. Если нажимать стрелку вверх на клавиатуре, то можно выводить
в консоль предыдущие команды. Это очень удобно для запуска предыдущих
команд с небольшими изменениями.

В \textbf{1 - Code Editor} для запуска команды вы должны выделить ее и
нажать \texttt{Ctrl} + \texttt{Enter} (\texttt{Cmd} + \texttt{Enter} на
macOS). Если не нажать эту комбинацию клавиш, то команда не запустится.
Можно выделить и запустить сразу несколько команд или даже все команды
скрипта. Все команды скрипта можно выделить с помощью сочетания клавиш
\texttt{Ctrl} + \texttt{A} на Windows и Linux, \texttt{Cmd} + \texttt{A}
на macOS \footnote{В RStudio есть много удобных сочетаний горячих
  клавиш. Чтобы посмотреть их все, нажмите
  \texttt{Help\ -\ Keyboard\ Shortcuts\ Help}.}. Как только вы запустите
команду (или несколько команд), соответствующие строчки кода появятся в
\textbf{2 - R Console}, как будто бы вы запускали их прямо там.

Обычно в консоли удобно что-то писать, чтобы быстро что-то посчитать.
Скрипты удобнее при работе с длинными командами и как способ сохранения
написанного кода для дальнейшей работы. Для сохранения скрипта нажмите
\texttt{File\ -\ Save\ As...}. R скрипты сохраняются с разрешением
\emph{.R}, но по своей сути это просто текстовые файлы, которые можно
открыть и модифицировать в любом текстовом редакторе а-ля ``Блокнот''.

\textbf{3 - Workspace and History} --- здесь можно увидеть переменные.
Это поле будет автоматически обновляться по мере того, как Вы будете
запускать строчки кода и создавать новые переменные. Еще там есть
вкладка с историей всех команд, которые были запущены.

\textbf{4 - Plots and files}. Здесь есть очень много всего. Во-первых,
небольшой файловый менеджер, во-вторых, там будут появляться графики,
когда вы будете их рисовать. Там же есть вкладка с вашими пакетами
(\texttt{Packages}) и \texttt{Help} по функциям. Но об этом потом.

\subsection{R как калькулятор}\label{calc}

R --- полноценный язык программирования, который позволяет решать
широкий спектр задач. Но в первую очередь R используется для анализа
данных и статистических вычислений. Тем не менее, многими R до сих пор
воспринимается как просто продвинутый калькулятор. Ну что ж,
калькулятор, так калькулятор.

Давайте начнем с самого простого и попробуем использовать R как
калькулятор с помощью арифметических операторов \texttt{+}, \texttt{-},
\texttt{*}, \texttt{/}, \texttt{\^{}} (степень), \texttt{()} и т.д.

Просто запускайте в консоли пока не надоест:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{40}\OperatorTok{+}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 42
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{3}\OperatorTok{-}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5}\OperatorTok{*}\DecValTok{6}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 30
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{99}\OperatorTok{/}\DecValTok{9} \CommentTok{#деление}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 11
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2}\OperatorTok{^}\DecValTok{3} \CommentTok{#степень}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{13} \OperatorTok{%/%}\StringTok{ }\DecValTok{3} \CommentTok{#целочисленное деление}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{13} \OperatorTok{%%}\StringTok{ }\DecValTok{3} \CommentTok{#остаток от деления}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

Попробуйте самостоятельно посчитать что-нибудь с разными числами.

\begin{figure}
\centering
\includegraphics[width=4.16667in]{images/ThePracticalDev_2016-Apr-13.jpg}
\caption{}
\end{figure}

Ничего сложного, верно? Вводим выражение и получаем результат.

Вы могли заметить, что некоторые команды у меня заканчиваются знаком
решетки (\texttt{\#}). Все, что написано в строчке после \texttt{\#}
игнорируется R при выполнении команды. Написанные команды в скрипте
рекомендуется сопровождать комментариями, которые будут объяснять вам же
в будущем (или кому-то еще), что конкретно происходит в соответствующем
куске кода \footnote{Во время написания кода вам может казаться понятным
  то, что вы написали, но при возвращении к коду через некоторое время
  вы уже не будете этого помнить. Старайтесь писать комментарии как
  можно чаще!}. Кроме того, комментарии можно использовать в тех
случаях, когда вы хотите написать кусок кода по-другому, не стирая
полностью предыдущий код: достаточно ``закомментить'' нужные строчки -
поставить \texttt{\#} в начало каждой строки, которую вы хотите
переписать. Для этого есть специальное сочетание горячих клавиш:
\texttt{Ctrl} + \texttt{Shift} + \texttt{C} (\texttt{Cmd} +
\texttt{Shift} + \texttt{C} на macOS) --- во всех выделенных строчках
будет написан \texttt{\#} в начале.

Согласно данным навязчивых рекламных баннеров в интернете, только 14\%
россиян могут справиться с этим примером:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \OperatorTok{+}\StringTok{ }\DecValTok{2} \OperatorTok{*}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

На самом деле, разные языки программирования ведут себя
\href{https://www.quora.com/Do-all-computer-languages-with-operator-precedence-use-the-same-operator-precedence}{по-разному}
в таких ситуациях, поэтому ответ 6 (сначала умножаем, потом складываем)
не так очевиден.

Порядок выполнения арифметических операций (т.е. приоритет операторов,
\emph{operator precedence}) в R как в математике, так что не забывайте
про скобочки.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\DecValTok{2}\OperatorTok{+}\DecValTok{2}\NormalTok{)}\OperatorTok{*}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 8
\end{verbatim}

Если Вы не уверены в том, какие операторы имеют приоритет, то
используйте скобочки, чтобы точно обозначить, в каком порядке нужно
производить операции. Или же смотрите на таблицу приоритета операторов с
помощью команды \texttt{?Syntax}.

\subsection{Функции}\label{func}

Давайте теперь извлечем корень из какого-нибудь числа. В принципе, тем,
кто помнит школьный курс математики, возведения в степень вполне
достаточно:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{16}\OperatorTok{^}\FloatTok{0.5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

Ну а если нет, то можете воспользоваться специальной \textbf{функцией}:
это обычно какие-то буквенные символы с круглыми скобками сразу после
названия функции. Мы подаем на вход (внутрь скобочек) какие-то данные,
внутри этих функций происходят какие-то вычисления, которые выдает в
ответ какие-то другие данные (или же функция записывает файл, рисует
график и т.д.).

Вот, например, функция для корня:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sqrt}\NormalTok{(}\DecValTok{16}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

\begin{quote}
R --- case-sensitive язык, т.е. регистр важен. SQRT(16) не будет
работать.
\end{quote}

А вот так выглядит функция логарифма:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{log}\NormalTok{(}\DecValTok{8}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2.079442
\end{verbatim}

Так, вроде бы все нормально, но\ldots{} Если Вы еще что-то помните из
школьной математики, то должны понимать, что что-то здесь не так.

Здесь не хватает основания логарифма!

\begin{quote}
Логарифм --- показатель степени, в которую надо возвести число,
называемое основанием, чтобы получить данное число.
\end{quote}

То есть у логарифма 8 по основанию 2 будет значение 3:

\(\log_2 8 = 3\)

То есть если возвести 2 в степень 3 у нас будет 8:

\(2^3 = 8\)

Только наша функция считает все как-то не так.

Чтобы понять, что происходит, нам нужно залезть в хэлп этой функции:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?log}
\end{Highlighting}
\end{Shaded}

Справа внизу в RStudio появится вот такое окно:

\begin{figure}
\centering
\includegraphics[width=4.16667in]{images/help.png}
\caption{}
\end{figure}

Действительно, у этой функции есть еще аргумент \emph{\texttt{base\ =}}.
По дефолту он равен числу Эйлера (2.7182818\ldots{}), т.е. функция
считает натуральный логарифм. В большинстве функций R есть какой-то
основной инпут --- данные в том или ином формате, а есть и
дополнительные параметры, которые можно прописывать вручную, если
параметры по умолчанию нас не устраивают.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{log}\NormalTok{(}\DataTypeTok{x =} \DecValTok{8}\NormalTok{, }\DataTypeTok{base =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

\ldots{}или просто (если Вы уверены в порядке переменных):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{log}\NormalTok{(}\DecValTok{8}\NormalTok{,}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

Более того, Вы можете использовать оутпут одних функций как инпут для
других:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{log}\NormalTok{(}\DecValTok{8}\NormalTok{, }\KeywordTok{sqrt}\NormalTok{(}\DecValTok{4}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

Отличненько. Мы еще много раз будем возвращаться к функциям. Вообще,
функции --- это одна из важнейших штук в R (примерно так же как и в
Python). Мы будем создавать свои функции, использовать функции как инпут
для функций и многое-многое другое. В R очень крутые возможности работы
с функциями. Поэтому подружитесь с функциями, они клевые.

\begin{quote}
Арифметические знаки, которые мы использовали: \texttt{+}, \texttt{-} ,
\texttt{/}, \texttt{\^{}} и т.д. называются \textbf{операторами} и на
самом деле тоже являются функциями:
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{'+'}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7
\end{verbatim}

\subsection{Переменные}\label{variables}

Важная штука в программировании на практически любом языке ---
возможность сохранять значения в \textbf{переменных}. В R это обычно
делается с помощью вот этих символов: \texttt{\textless{}-} (но можно
использовать и обычное \texttt{=}, хотя это не очень принято). Для этого
есть удобное сочетание клавиш: нажмите одновременно \texttt{Alt} +
\texttt{-} (или \texttt{option} + \texttt{-} на macOS).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\DecValTok{2}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2
\end{verbatim}

Заметьте, при присвоении результат вычисления не выводится в консоль!
Если опустить детали, то обычно результат выполнения комманды либо
выводится в консоль, либо записывается в переменную.

После присвоения переменная появляется во вкладке \textbf{Environment} в
RStudio:

\begin{figure}
\centering
\includegraphics[width=4.16667in]{images/env.png}
\caption{}
\end{figure}

Можно использовать переменные в функциях и просто вычислениях:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b <-}\StringTok{ }\NormalTok{a }\OperatorTok{^}\StringTok{ }\NormalTok{a }\OperatorTok{+}\StringTok{ }\NormalTok{a }\OperatorTok{*}\StringTok{ }\NormalTok{a}
\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{log}\NormalTok{(b, a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

Вы можете сравнивать разные переменные:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{==}\StringTok{ }\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

Заметьте, что сравнивая две переменные мы используем два знака равно
\texttt{==}, а не один \texttt{=}. Иначе это будет означать присвоение.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a =}\StringTok{ }\NormalTok{b}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 8
\end{verbatim}

Теперь Вы сможете понять комикс про восстание роботов на следующей
странице (пусть он и совсем про другой язык программирования)

\begin{figure}
\centering
\includegraphics[width=4.16667in]{images/WaCM5x3mvQM.jpg}
\caption{}
\end{figure}

Этот комикс объясняет, как важно не путать присваивание и сравнение
\emph{(хотя я иногда путаю до сих пор =( )}.

Иногда нам нужно проверить на \emph{не}равенство:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\DecValTok{2}
\NormalTok{b <-}\StringTok{ }\DecValTok{3}

\NormalTok{a}\OperatorTok{==}\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a}\OperatorTok{!=}\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

Восклицательный язык в программировании вообще и в R в частности
стандартно означает отрицание.

Еще мы можем сравнивать на больше/меньше:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{>}\StringTok{ }\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{<}\StringTok{ }\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{>=}\StringTok{ }\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{<=}\StringTok{ }\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\section{Типы данных}\label{data_types}

До этого момента мы работали только с числами (numeric):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "numeric"
\end{verbatim}

\begin{quote}
Вообще, в R много типов numeric: integer (целые), double (с десятичной
дробью), complex (комплексные числа). Последние пишутся так:
\texttt{complexnumber\ \textless{}-\ 2+2i} Однако в R с этим обычно
можно вообще не заморачиваться, R сам будет конвертить между форматами
при необходимости. Немного подробностей здесь:
\end{quote}

\href{https://stackoverflow.com/questions/23660094/whats-the-difference-between-integer-class-and-numeric-class-in-r}{Разница
между numeric и integer},
\href{http://www.r-tutor.com/r-introduction/basic-data-types/complex}{Как
работать с комплексными числами в R}

Теперь же нам нужно ознакомиться с двумя другими важными типами данных в
R:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{character}: строки символов. Они должны выделяться кавычками.
  Можно использовать как \texttt{"}, так и \texttt{\textquotesingle{}}
  (что удобно, когда строчка внутри уже содержит какие-то кавычки).
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s <-}\StringTok{ "Всем привет!"}
\NormalTok{s}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Всем привет!"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(s)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "character"
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  \textbf{logical}: просто \texttt{TRUE} или \texttt{FALSE}.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t1 <-}\StringTok{ }\OtherTok{TRUE}
\NormalTok{f1 <-}\StringTok{ }\OtherTok{FALSE}

\NormalTok{t1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

Вообще, можно еще писать \texttt{T} и \texttt{F} (но не \texttt{True} и
\texttt{False}!)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t2 <-}\StringTok{ }\NormalTok{T}
\NormalTok{f2 <-}\StringTok{ }\NormalTok{F}
\end{Highlighting}
\end{Shaded}

Это дурная практика, так как R защищает от перезаписи переменные
\texttt{TRUE} и \texttt{FALSE}, но не защищает от этого \texttt{T} и
\texttt{F}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{TRUE}\NormalTok{ <-}\StringTok{ }\OtherTok{FALSE}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error in TRUE <- FALSE: неправильная (do_set) левая сторона в присвоении
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{TRUE}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{T <-}\StringTok{ }\OtherTok{FALSE}
\NormalTok{T}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

Теперь вы можете догадаться, что результаты сравнения, например,
числовых или строковых переменных вы можете сохранять в переменные тоже!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{comparison <-}\StringTok{ }\NormalTok{a }\OperatorTok{==}\StringTok{ }\NormalTok{b}
\NormalTok{comparison}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

Это нам очень понадобится, когда мы будем работать с реальными данными:
нам нужно будет постоянно вытаскивать какие-то данные из датасета, а это
как раз и построено на игре со сравнением переменных.

Чтобы этим хорошо уметь пользоваться, нам нужно еще освоить как работать
с логическими операторами. Про один мы немного уже говорили --- это не
(\texttt{!}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{!}\NormalTok{t1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{!!}\NormalTok{t1 }\CommentTok{#Двойное отрицание!}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

Еще есть И (выдаст \texttt{TRUE} только в том случае если обе переменные
\texttt{TRUE}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t1 }\OperatorTok{&}\StringTok{ }\NormalTok{t2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t1 }\OperatorTok{&}\StringTok{ }\NormalTok{f1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

А еще ИЛИ (выдаст \texttt{TRUE} в случае если хотя бы одна из переменных
\texttt{TRUE}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{t1 }\OperatorTok{|}\StringTok{ }\NormalTok{f1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1 }\OperatorTok{|}\StringTok{ }\NormalTok{f2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

Поздравляю, мы только что разобрались с самой занудной (но очень
важной!) частью. Пора переходить к важному и интересному. ВЕКТОРАМ!

\section{Вектор}\label{atomic}

Если у вас не было линейной алгебры (или у вас с ней было все плохо), то
просто запомните, что \textbf{вектор} (\textbf{atomic vector} или просто
\textbf{atomic}) --- это набор (столбик) чисел в определенном порядке.

Если вы привыкли из школьного курса физики считать вектора стрелочками,
то не спешите возмущаться и паниковать. Представьте стрелочки как точки
из нуля координат \{0,0\} до какой-то точки на координатной плоскости,
например, \{2,3\}:

\begin{figure}
\centering
\includegraphics[width=4.16667in]{images/coord_vector.png}
\caption{}
\end{figure}

Вот последние два числа и будем считать вектором. Попытайтесь теперь
мысленно стереть координатную плоскость и выбросить стрелочки из головы,
оставив только последовательность чисел \{2,3\}:

\begin{figure}
\centering
\includegraphics[width=4.16667in]{images/coord_vector_blur.png}
\caption{}
\end{figure}

На самом деле, мы уже работали с векторами в R, но, возможно, вы об этом
даже не догадывались. Дело в том, что в R нет как таковых скалярных
(т.е. одиночных) значений, \textbf{есть вектора длиной 1}. Такие дела!

Чтобы создать вектор из нескольких значений, нужно воспользоваться
функцией \emph{\texttt{c()}}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{,}\DecValTok{8}\NormalTok{,}\DecValTok{15}\NormalTok{,}\DecValTok{16}\NormalTok{,}\DecValTok{23}\NormalTok{,}\DecValTok{42}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  4  8 15 16 23 42
\end{verbatim}

Создавать вектора можно не только из \emph{numeric}, но также и из
\emph{character} и \emph{logical}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\StringTok{"Хэй"}\NormalTok{, }\StringTok{"Хэй"}\NormalTok{, }\StringTok{"Ха"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Хэй" "Хэй" "Ха"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  TRUE FALSE
\end{verbatim}

\begin{quote}
Одна из самых мерзких и раздражающих причин ошибок в коде --- это
использование \texttt{с} из кириллицы вместо \texttt{c} из латиницы.
Видите разницу? И я не вижу. А R видит.
\end{quote}

Для создания числовых векторов есть удобный \textbf{оператор} \texttt{:}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  2  3  4  5  6  7  8  9 10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{5}\OperatorTok{:-}\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  5  4  3  2  1  0 -1 -2 -3
\end{verbatim}

Этот оператор создает вектор от первого числа до второго с шагом 1. Вы
не представляете, как часто эта штука нам пригодится\ldots{} Если же
нужно сделать вектор с другим шагом, то есть функция \texttt{seq()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DecValTok{10}\NormalTok{,}\DecValTok{100}\NormalTok{, }\DataTypeTok{by =} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  10  20  30  40  50  60  70  80  90 100
\end{verbatim}

Кроме того, можно задавать не шаг, а длину вектора. Тогда шаг функция
\texttt{seq()} посчитает сама:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{13}\NormalTok{, }\DataTypeTok{length.out =} \DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1  5  9 13
\end{verbatim}

Другая функция --- \texttt{rep()} --- позволяет создавать вектора с
повторяющимися значениями. Первый аргумент --- значение, которое нужно
повторять, а второй аргумент --- сколько раз повторять.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 1 1 1 1
\end{verbatim}

И первый, и второй аргумент могут быть векторами!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3 1 2 3 1 2 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 2 3 3 3
\end{verbatim}

Еще можно объединять вектора (что мы, по сути, и делали, просто с
векторами длиной 1):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v1 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Hey"}\NormalTok{, }\StringTok{"Ho"}\NormalTok{)}
\NormalTok{v2 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Let's"}\NormalTok{, }\StringTok{"Go!"}\NormalTok{)}
\KeywordTok{c}\NormalTok{(v1, v2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Hey"   "Ho"    "Let's" "Go!"
\end{verbatim}

Очень многие функции в R работают именно с векторами. Например, функции
\texttt{sum()} (считает сумму значений вектора) и \texttt{mean()}
(считает среднее арифметическое всех значений в векторе):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 55
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5.5
\end{verbatim}

\subsection{Приведение типов}\label{coercion}

Что будет, если вы объедините два вектора с значениями разных типов?
Ошибка?

Мы уже обсуждали, что в \emph{atomic} может быть только один тип данных.
В некоторых языках программирования при операции с данными разных типов
мы бы получили ошибку. А вот в R при несовпадении типов пройзойдет
попытка привести типы к ``общему знаменателю'', то есть конвертировать
данные в более ``широкий'' тип.

Например:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\OtherTok{FALSE}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0 2
\end{verbatim}

\texttt{FALSE} превратился в \texttt{0} (а \texttt{TRUE} превратился бы
в \texttt{1}), чтобы оба значения можно было объединить в вектор. То же
самое произошло бы в случае операций с векторами:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \OperatorTok{+}\StringTok{ }\OtherTok{TRUE}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

Это называется \textbf{неявным приведением типов (implicit coercion)}.

Вот более сложный пример:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\DecValTok{3}\NormalTok{, }\StringTok{"Привет"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "TRUE"   "3"      "Привет"
\end{verbatim}

У R есть иерархия коэрсинга:

\texttt{NULL\ \textless{}\ raw\ \textless{}\ logical\ \textless{}\ integer\ \textless{}\ double\ \textless{}\ complex\ \textless{}\ character\ \textless{}\ list\ \textless{}\ expression}.

Мы из этого списка еще многого не знаем, сейчас важно запомнить, что
логические данные --- \texttt{TRUE} и \texttt{FALSE} --- превращаются в
\texttt{0} и \texttt{1} соответственно, а \texttt{0} и \texttt{1} в
строчки \texttt{"0"} и \texttt{"1"}.

Если Вы боитесь полагаться на приведение типов, то можете
воспользоваться функциями \texttt{as.нужныйтипданных} для явного
приведения типов (\textbf{explicit coercion}):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.numeric}\NormalTok{(}\KeywordTok{c}\NormalTok{(T, F, F))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 0 0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.character}\NormalTok{(}\KeywordTok{as.numeric}\NormalTok{(}\KeywordTok{c}\NormalTok{(T, F, F)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "1" "0" "0"
\end{verbatim}

Можно превращать и обратно, например, строковые значения в числовые.
Если среди числа встретится буква или другой неподходящий знак, то мы
получим предупреждение \texttt{NA} --- пропущенное значение (мы очень
скоро научимся с ними работать).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.numeric}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"1"}\NormalTok{, }\StringTok{"2"}\NormalTok{, }\StringTok{"три"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: в результате преобразования созданы NA
\end{verbatim}

\begin{verbatim}
## [1]  1  2 NA
\end{verbatim}

\begin{quote}
Один из распространенных примеров использования неявного приведения
типов --- использования функций \texttt{sum()} и \texttt{mean()} для
подсчета в логическом векторе количества и доли \texttt{TRUE}
соответсвенно. Мы будем много раз пользоваться этим приемом в
дальнейшем!
\end{quote}

\subsection{Векторизация}\label{vector_op}

Все те арифметические операторы, что мы использовали ранее, можно
использовать с векторами одинаковой длины:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{4}
\NormalTok{m <-}\StringTok{ }\DecValTok{4}\OperatorTok{:}\DecValTok{1}
\NormalTok{n }\OperatorTok{+}\StringTok{ }\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5 5 5 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{-}\StringTok{ }\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -3 -1  1  3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{*}\StringTok{ }\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4 6 6 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{/}\StringTok{ }\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.2500000 0.6666667 1.5000000 4.0000000
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{^}\StringTok{ }\NormalTok{m }\OperatorTok{+}\StringTok{ }\NormalTok{m }\OperatorTok{*}\StringTok{ }\NormalTok{(n }\OperatorTok{-}\StringTok{ }\NormalTok{m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -11   5  11   7
\end{verbatim}

Если применить операторы на двух векторах одинаковой длины, то в мы
получим результат поэлементного применения оператора к двум векторам.
Это называется \textbf{векторизацией} (\textbf{vectorization}).

\begin{quote}
Если после какого-нибудь MATLAB Вы привыкли, что по умолчанию операторы
работают по правилам линейной алгебры и \texttt{m*n} будет давать
скалярное произведение (\emph{dot product}), то снова нет. Для
скалярного произведения нужно использовать операторы с \texttt{\%} по
краям:
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{%*%}\StringTok{ }\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1]
## [1,]   20
\end{verbatim}

\begin{quote}
Абсолютно так же и с операциями с матрицами в R, хотя про матрицы будет
немного позже.
\end{quote}

В принципе, большинство функций в R, которые работают с отдельными
значениями, так же хорошо работают и с целыми векторами. Скажем, Вы
хотите извлечь корень из нескольких чисел, для этого не нужны никакие
циклы (как это обычно делается в других языках программирования). Можно
просто ``скормить'' вектор функции и получить результат применения
функции к каждому элементу вектора:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sqrt}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427
##  [9] 3.000000 3.162278
\end{verbatim}

Таких векторизованных функций в R очень много. Многие из них написаны на
более низкоуровневых языках программирования (C, C++, FORTRAN), за счет
чего использование таких функций приводит не только к более элегантному,
лаконичному, но и к более быстрому коду.

\begin{quote}
Векторизация в R --- это очень важная фишка, которая отличает этот язык
программирования от многих других. Если вы уже имеете опыт
программирования на другом языке, то вам во многих задачах захочется
использовать циклы типа \texttt{for} и \texttt{while} \ref{for}. Не
спешите этого делать! В очень многих случаях циклы можно заменить
векторизацией. Тем не менее, векторизация --- это не единственный способ
избавить от циклов типа \texttt{for} и \texttt{while} \ref{apply}.
\end{quote}

\subsection{Recycling}\label{recycling}

Допустим мы хотим совершить какую-нибудь операцию с двумя векторами. Как
мы убедились, с этим обычно нет никаких проблем, если они совпадают по
длине. А что если вектора не совпадают по длине? Ничего страшного! Здесь
будет работать правило \textbf{ресайклинга} (\emph{правило
переписывания, recycling rule}). Это означает, что если мы делаем
операцию на двух векторах разной длины, то если короткий вектор кратен
по длине длинному, короткий вектор будет повторяться необходимое
количество раз:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{4}
\NormalTok{m <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{2}
\NormalTok{n }\OperatorTok{*}\StringTok{ }\NormalTok{m}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 4 3 8
\end{verbatim}

А что будет, если совершать операции с вектором и отдельным значением?
Можно считать это частным случаем ресайклинга: короткий вектор длиной 1
будет повторятся столько раз, сколько нужно, чтобы он совпадал по длине
с длинным:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{*}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 4 6 8
\end{verbatim}

Если же меньший вектор не кратен большему (например, один из них длиной
3, а другой длиной 4), то R посчитает результат, но выдаст
предупреждение.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{+}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in n + c(3, 4, 5): длина большего объекта не является произведением
## длины меньшего объекта
\end{verbatim}

\begin{verbatim}
## [1] 4 6 8 7
\end{verbatim}

Проблема в том, что эти предупреждения могут в неожиданный момент стать
причиной ошибок. Поэтому не стоит полагаться на ресайклинг некратных по
длине векторов.
\href{https://stackoverflow.com/questions/6555651/under-what-circumstances-does-r-recycle}{См.
здесь}. А вот ресайклинг кратных по длине векторов --- это очень удобная
штука, которая используется очень часто.

\subsection{Индексирование векторов}\label{index_atomic}

Итак, мы подошли к одному из самых сложных моментов. И одному из
основных. От того, как хорошо вы научись с этим работать, зависит весь
ваш дальнейший успех на R-поприще!

Речь пойдет об \textbf{индексировании} векторов. Задача, которую Вам
придется решать каждые пять минут работы в R --- как выбрать из вектора
(или же списка, матрицы и датафрейма) какую-то его часть. Для этого
используются квадратные скобочки \texttt{{[}{]}} (не круглые --- они для
функций!).

Самое простое --- индексировать по номеру индекса, т.е. порядку значения
в векторе.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\NormalTok{n[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[}\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 10
\end{verbatim}

\begin{quote}
Если вы знакомы с другими языками программирования (не MATLAB, там все
так же) и уже научились думать, что индексация с 0 --- это очень удобно
и очень правильно (ну или просто свыклись с этим), то в R Вам придется
переучиться обратно. Здесь первый индекс --- это 1, а последний равен
длине вектора --- ее можно узнать с помощью функции \texttt{length()}. С
обоих сторон индексы берутся включительно.
\end{quote}

С помощью индексирования можно не только вытаскивать имеющиеся значения
в векторе, но и присваивать им новые:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[}\DecValTok{3}\NormalTok{] <-}\StringTok{ }\DecValTok{20}
\NormalTok{n}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  2 20  4  5  6  7  8  9 10
\end{verbatim}

Конечно, можно использовать целые векторы для индексирования:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[}\DecValTok{4}\OperatorTok{:}\DecValTok{7}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4 5 6 7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[}\DecValTok{10}\OperatorTok{:}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 10  9  8  7  6  5  4 20  2  1
\end{verbatim}

Индексирование с минусом выдаст вам все значения вектора кроме
выбранных:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[}\OperatorTok{-}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  2 20  4  5  6  7  8  9 10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[}\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\DecValTok{4}\NormalTok{, }\OperatorTok{-}\DecValTok{5}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1  2 20  6  7  8  9 10
\end{verbatim}

Более того, можно использовать логический вектор для индексирования. В
этом случае нужен логический вектор такой же длины:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[}\KeywordTok{c}\NormalTok{(T,F,T,F,T,F,T,F,T,F)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1 20  5  7  9
\end{verbatim}

Ну а если они не равны, то тут будет снова работать правило ресайклинга!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[}\KeywordTok{c}\NormalTok{(T,F)] }\CommentTok{#то же самое - recycling rule!}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1 20  5  7  9
\end{verbatim}

Есть еще один способ индексирования векторов, но он несколько более
редкий: индексирование по имени. Дело в том, что для значений векторов
можно (но не обязательно) присваивать имена:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_named_vector <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{first =} \DecValTok{1}\NormalTok{, }\DataTypeTok{second =} \DecValTok{2}\NormalTok{, }\DataTypeTok{third =} \DecValTok{3}\NormalTok{)}
\NormalTok{my_named_vector[}\StringTok{'first'}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## first 
##     1
\end{verbatim}

А еще можно ``вытаскивать'' имена из вектора с помощью функции
\texttt{names()} и присваивать таким образом новые.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{d <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{4}
\KeywordTok{names}\NormalTok{(d) <-}\StringTok{ }\NormalTok{letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{]}
\NormalTok{d[}\StringTok{"a"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## a 
## 1
\end{verbatim}

\begin{quote}
\texttt{letters} --- это ``зашитая'' в R константа --- вектор букв от a
до z. Иногда это очень удобно! Кроме того, есть константа
\texttt{LETTERS} --- то же самое, но заглавными буквами. А еще есть
названия месяцев на английском и числовая константа \texttt{pi}.
\end{quote}

Теперь посчитаем среднее вектора \texttt{n}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(n)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7.2
\end{verbatim}

А как вытащить все значения, которые больше среднего?

Сначала получим логический вектор --- какие значения больше среднего:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{larger <-}\StringTok{ }\NormalTok{n}\OperatorTok{>}\KeywordTok{mean}\NormalTok{(n)}
\NormalTok{larger}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE
\end{verbatim}

А теперь используем его для индексирования вектора \texttt{n}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[larger]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 20  8  9 10
\end{verbatim}

Можно все это сделать в одну строчку:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[n}\OperatorTok{>}\KeywordTok{mean}\NormalTok{(n)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 20  8  9 10
\end{verbatim}

Предыдущая строчка отражает то, что мы будем постоянно делать в R:
вычленять (subset) из данных отдельные куски на основании разных
условий.

\subsection{NA - пропущенные значения}\label{na}

В реальных данных у нас часто чего-то не хватает. Например, из-за
технической ошибки или невнимательности не получилось записать какое-то
измерение. Для этого в R есть \texttt{NA} (расшифровывается как
\emph{Not Available} - недоступное значение). \texttt{NA} --- это не
строка \texttt{"NA"}, не \texttt{0}, не пустая строка \texttt{""} и не
\texttt{FALSE}. \texttt{NA} --- это \texttt{NA}. Большинство операций с
векторами, содержащими \texttt{NA} будут выдавать \texttt{NA}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{missed <-}\StringTok{ }\OtherTok{NA}
\NormalTok{missed }\OperatorTok{==}\StringTok{ "NA"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NA
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{missed }\OperatorTok{==}\StringTok{ ""}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NA
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{missed }\OperatorTok{==}\StringTok{ }\OtherTok{NA}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NA
\end{verbatim}

Заметьте: даже сравнение \texttt{NA} c \texttt{NA} выдает \texttt{NA}!

Иногда \texttt{NA} в данных очень бесит:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[}\DecValTok{5}\NormalTok{] <-}\StringTok{ }\OtherTok{NA}
\NormalTok{n}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  2 20  4 NA  6  7  8  9 10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(n)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] NA
\end{verbatim}

Что же делать?\\
Наверное, надо сравнить вектор с \texttt{NA} и исключить этих
пакостников. Давайте попробуем:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{==}\StringTok{ }\OtherTok{NA}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] NA NA NA NA NA NA NA NA NA NA
\end{verbatim}

Ах да, мы ведь только что узнали, что даже сравнение \texttt{NA} c
\texttt{NA} приводит к \texttt{NA}\ldots{}

Чтобы выбраться из этой непростой ситуации, используйте функцию
\texttt{is.na()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.na}\NormalTok{(n)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE
\end{verbatim}

Результат выполнения \texttt{is.na(n)} выдает \texttt{FALSE} в тех
местах, где у нас числа и \texttt{TRUE} там, где у нас \texttt{NA}. Нам
нужно сделать наоборот. Здесь нам понадобится оператор \texttt{!} (мы
его уже встречали), который инвертирует логические значения:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n[}\OperatorTok{!}\KeywordTok{is.na}\NormalTok{(n)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  1  2 20  4  6  7  8  9 10
\end{verbatim}

Ура, мы можем считать среднее!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(n[}\OperatorTok{!}\KeywordTok{is.na}\NormalTok{(n)])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7.444444
\end{verbatim}

Теперь Вы понимаете, зачем нужно отрицание (\texttt{!})

Вообще, есть еще один из способов посчитать среднее, если есть
\texttt{NA}. Для этого надо залезть в хэлп по функции \emph{mean()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?}\KeywordTok{mean}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

В хэлпе мы найдем параметр \texttt{na.rm\ =}, который по дефолту
\texttt{FALSE}. Вы знаете, что нужно делать!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(n, }\DataTypeTok{na.rm =}\NormalTok{ T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7.444444
\end{verbatim}

Еееее!

\begin{quote}
\texttt{NA} может появляться в векторах других типов тоже. Более того,
на самом деле, это все разные \texttt{NA}: логический \texttt{NA},
\texttt{NA\_integer\_}, \texttt{NA\_real\_}, \texttt{NA\_complex\_} and
\texttt{NA\_character\_}.
\end{quote}

\begin{quote}
Кроме \texttt{NA} есть еще \texttt{NaN} --- это разные вещи.
\texttt{NaN} расшифровывается как \emph{Not a Number} и получается в
результате таких операций как \texttt{0\ /\ 0}. Тем не менее, функция
\texttt{is.na()} выдает \texttt{TRUE} на \texttt{NaN}, а вот функция
\texttt{is.nan()} выдает \texttt{TRUE} на \texttt{NaN} и \texttt{FALSE}
на \texttt{NA}:
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.na}\NormalTok{(}\OtherTok{NA}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.na}\NormalTok{(}\OtherTok{NaN}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.nan}\NormalTok{(}\OtherTok{NA}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.nan}\NormalTok{(}\OtherTok{NaN}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\subsection{В любой непонятной ситуации --- гуглите}\label{google}

Если вдруг вы не знаете, что искать в хэлпе, или хэлпа попросту
недостаточно, то\ldots{} гуглите!

\begin{figure}
\centering
\includegraphics[width=4.16667in]{images/2AmXWgVoULk.jpg}
\caption{}
\end{figure}

Нет ничего постыдного в том, чтобы гуглить решения проблем. Это
абсолютно нормально. Используйте силу интернета во благо и да помогут
Вам \emph{Stackoverflow}\footnote{Stackoverflow --- это сайт с вопросами
  и ответами. Эдакий аналог \emph{Quora}, \emph{The Question}, ну или
  \emph{Ответы Mail.ru} в мире программирования.} и бесчисленные
R-туториалы!

Computer Programming To Be Officially Renamed ``Googling Stack
Overflow''Source: http://t.co/xu7acfXvFF pic.twitter.com/iJ9k7aAVhd

--- Stack Exchange (\citet{StackExchange}) July 20, 2015

\begin{figure}
\centering
\includegraphics[width=4.16667in]{images/doctors-googling-stuff-online-does-not-make-you-a-doctor-programmers-confused.jpg}
\caption{}
\end{figure}

Главное, помните: загуглить работающий ответ всегда недостаточно. Надо
понять, как и почему решение работает. Иначе что-то обязательно пойдет
не так.

Кроме того, правильно загуглить проблему --- не так уж и просто.

Does anyone ever get good at R or do they just get good at googling how
to do things in R

--- 🔬🖤Lauren M. Seyler, Ph.D.❤️⚒ (\citet{mousquemere}) May 6, 2019

Итак, с векторами мы более-менее разобрались. Помните, что вектора ---
это один из краеугольных камней вашей работы в R. Если вы хорошо с ними
разобрались, то дальше все будет довольно несложно. Тем не менее,
вектора --- это не все. Есть еще два важных типа данных: списки
(\textbf{list}) и матрицы (\textbf{matrix}). Их можно рассматривать как
своеобразное ``расширение'' векторов, каждый в свою сторону. Ну а списки
и матрицы нужны чтобы понять основной тип данных в R ---
\textbf{data.frame}.

\begin{figure}
\centering
\includegraphics[width=4.16667in]{images/New-Mind-Map.jpg}
\caption{}
\end{figure}

\section{Матрицы (matrix)}\label{matrix}

Если вдруг вас пугает это слово, то совершенно зря. Матрица --- это
всего лишь ``двумерный'' вектор: вектор, у которого есть не только
длина, но и ширина. Создать матрицу можно с помощью функции
\texttt{matrix()} из вектора, указав при этом количество строк и
столбцов.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{20}\NormalTok{, }\DataTypeTok{nrow=}\DecValTok{5}\NormalTok{,}\DataTypeTok{ncol=}\DecValTok{4}\NormalTok{)}
\NormalTok{A}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20
\end{verbatim}

Если мы знаем сколько значений в матрице и сколько мы хотим строк, то
количество столбцов указывать необязательно:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{20}\NormalTok{, }\DataTypeTok{nrow=}\DecValTok{5}\NormalTok{)}
\NormalTok{A}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20
\end{verbatim}

Все остальное так же как и с векторами: внутри находится данные только
одного типа. Поскольку матрица --- это уже двумерный массив, то у него
имеется два индекса. Эти два индекса разделяются запятыми.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A[}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 12
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A[}\DecValTok{2}\OperatorTok{:}\DecValTok{4}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    2    7   12
## [2,]    3    8   13
## [3,]    4    9   14
\end{verbatim}

Первый индекс --- выбор строк, второй индекс --- выбор колонок. Если же
мы оставляем пустое поле вместо числа, то мы выбираем все строки/колонки
в зависимости от того, оставили мы поле пустым до или после запятой:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A[, }\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## [1,]    1    6   11
## [2,]    2    7   12
## [3,]    3    8   13
## [4,]    4    9   14
## [5,]    5   10   15
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A[}\DecValTok{2}\OperatorTok{:}\DecValTok{4}\NormalTok{, ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    2    7   12   17
## [2,]    3    8   13   18
## [3,]    4    9   14   19
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A[, ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2    7   12   17
## [3,]    3    8   13   18
## [4,]    4    9   14   19
## [5,]    5   10   15   20
\end{verbatim}

Так же как и в случае с обычными векторами, часть матрицы можно
переписать:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A[}\DecValTok{2}\OperatorTok{:}\DecValTok{4}\NormalTok{, }\DecValTok{2}\OperatorTok{:}\DecValTok{4}\NormalTok{] <-}\StringTok{ }\DecValTok{100}
\NormalTok{A}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    6   11   16
## [2,]    2  100  100  100
## [3,]    3  100  100  100
## [4,]    4  100  100  100
## [5,]    5   10   15   20
\end{verbatim}

В принципе, это все, что нам нужно знать о матрицах. Матрицы
используются в R довольно редко, особенно по сравнению, например, с
MATLAB. Но вот индексировать матрицы хорошо бы уметь: это понадобится в
работе с датафреймами.

\begin{quote}
То, что матрица --- это просто двумерный вектор, не является метафорой:
в R матрица --- это по сути своей вектор с дополнительными
\emph{атрибутами} \texttt{dim} и (опционально) \texttt{dimnames}.
Атрибуты --- это свойства объектов, своего рода ``метаданные''. Для всех
объектов есть обязательные атрибуты типа и длины и могут быть любые
необязательные атрибуты. Можно задавать свои атрибуты или удалять уже
присвоенные: удаление атрибута \texttt{dim} у матрицы превратит ее в
обычный вектор. Про атрибуты подробнее можно почитать
\href{https://perso.esiee.fr/~courivad/R/06-objects.html}{здесь} или на
стр. 99-101 книги ``R in a Nutshell'' \citep{adler2010r}.
\end{quote}

\section{Списки (list)}\label{list}

Теперь представим себе вектор без ограничения на одинаковые данные
внутри. И получим список!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{42}\NormalTok{, }\StringTok{"Пам пам"}\NormalTok{, T)}
\NormalTok{l}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 42
## 
## [[2]]
## [1] "Пам пам"
## 
## [[3]]
## [1] TRUE
\end{verbatim}

А это значит, что там могут содержаться самые разные данные, в том числе
и другие списки и векторы!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{lbig <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Wow"}\NormalTok{, }\StringTok{"this"}\NormalTok{, }\StringTok{"list"}\NormalTok{, }\StringTok{"is"}\NormalTok{, }\StringTok{"so"}\NormalTok{, }\StringTok{"big"}\NormalTok{), }\StringTok{"16"}\NormalTok{, l)}
\NormalTok{lbig}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] "Wow"  "this" "list" "is"   "so"   "big" 
## 
## [[2]]
## [1] "16"
## 
## [[3]]
## [[3]][[1]]
## [1] 42
## 
## [[3]][[2]]
## [1] "Пам пам"
## 
## [[3]][[3]]
## [1] TRUE
\end{verbatim}

Если у нас сложный список, то есть очень классная функция, чтобы
посмотреть, как он устроен, под названием \texttt{str()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(lbig)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## List of 3
##  $ : chr [1:6] "Wow" "this" "list" "is" ...
##  $ : chr "16"
##  $ :List of 3
##   ..$ : num 42
##   ..$ : chr "Пам пам"
##   ..$ : logi TRUE
\end{verbatim}

\begin{quote}
Представьте, что список - это такое дерево с ветвистой структурой. А на
конце этих ветвей - листья-векторы.
\end{quote}

Как и в случае с векторами мы можем давать имена элементам списка:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{namedl <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{age =} \DecValTok{24}\NormalTok{, }\DataTypeTok{PhDstudent =}\NormalTok{ T, }\DataTypeTok{language =} \StringTok{"Russian"}\NormalTok{)}
\NormalTok{namedl}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $age
## [1] 24
## 
## $PhDstudent
## [1] TRUE
## 
## $language
## [1] "Russian"
\end{verbatim}

К списку можно обращаться как с помощью индексов, так и по именам.
Начнем с последнего:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{namedl}\OperatorTok{$}\NormalTok{age}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 24
\end{verbatim}

А вот с индексами сложнее, и в этом очень легко запутаться. Давайте
попробуем сделать так, как мы делали это раньше:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{namedl[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $age
## [1] 24
\end{verbatim}

Мы, по сути, получили элемент списка --- просто как часть списка, т.е.
как список длиной один:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(namedl)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "list"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(namedl[}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "list"
\end{verbatim}

А вот чтобы добраться до самого элемента списка (и сделать с ним что-то
хорошее) нам нужна не одна, а две квадратных скобочки:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{namedl[[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 24
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(namedl[[}\DecValTok{1}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "numeric"
\end{verbatim}

Indexing lists in \#rstats. Inspired by the Residence Inn
pic.twitter.com/YQ6axb2w7t

--- Hadley Wickham (\citet{hadleywickham}) September 14, 2015

Как и в случае с вектором, к элементу списка можно обращаться по имени.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{namedl[[}\StringTok{'age'}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 24
\end{verbatim}

Хотя последнее --- практически то же самое, что и использование знака
\$.

\begin{quote}
Списки довольно часто используются в R, но реже, чем в Python. Со
многими объектами в R, такими как результаты статистических тестов,
удобно работать именно как со списками --- к ним все вышеописанное
применимо. Кроме того, некоторые данные мы изначально получаем в виде
древообразной структуры --- хочешь не хочешь, а придется работать с этим
как со списком. Но обычно после этого стоит как можно скорее превратить
список в датафрейм.
\end{quote}

\section{Data.frame}\label{df}

Итак, мы перешли к самому главному. Самому-самому. Датафреймы
(\textbf{data.frames}). Более того, сейчас станет понятно, зачем нам
нужно было разбираться со всеми предыдущими темами.

Без векторов мы не смогли бы разобраться с матрицами и списками. А без
последних мы не сможем понять, что такое датафрейм.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{name <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Ivan"}\NormalTok{, }\StringTok{"Eugeny"}\NormalTok{, }\StringTok{"Lena"}\NormalTok{, }\StringTok{"Misha"}\NormalTok{, }\StringTok{"Sasha"}\NormalTok{) }
\NormalTok{age <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{26}\NormalTok{, }\DecValTok{34}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{27}\NormalTok{, }\DecValTok{26}\NormalTok{) }
\NormalTok{student <-}\StringTok{ }\KeywordTok{c}\NormalTok{(F, F, T, T, T) }
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(name, age, student)  }
\NormalTok{df}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     name age student
## 1   Ivan  26   FALSE
## 2 Eugeny  34   FALSE
## 3   Lena  23    TRUE
## 4  Misha  27    TRUE
## 5  Sasha  26    TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    5 obs. of  3 variables:
##  $ name   : Factor w/ 5 levels "Eugeny","Ivan",..: 2 1 3 4 5
##  $ age    : num  26 34 23 27 26
##  $ student: logi  FALSE FALSE TRUE TRUE TRUE
\end{verbatim}

Вообще, очень похоже на список, не правда ли? Так и есть, датафрейм ---
это что-то вроде проименованного списка, каждый элемент которого
является \emph{atomic} вектором фиксированной длины. Скорее всего,
список Вы представляли ``горизонтально''. Если это так, то теперь
``переверните'' его у себя в голове на 90 градусов. Так, чтоб названия
векторов оказались сверху, а колонки стали столбцами. Поскольку длина
всех этих векторов равна (обязательное условие!), то данные представляют
собой табличку, похожую на матрицу. Но в отличие от матрицы, разные
столбцы могут имет разные типы данных: первая колонка ---
\texttt{character}, вторая колонка --- \texttt{numeric}, третья колонка
--- \texttt{logical}. Тем не менее, обращаться с датафреймом можно и как
с проименованным списком, и как с матрицей:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df}\OperatorTok{$}\NormalTok{age[}\DecValTok{2}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 34 23
\end{verbatim}

Здесь мы сначала вытащили колонку \texttt{age} с помощью оператора
\texttt{\$}. Результатом этой операции является числовой вектор, из
которого мы вытащили кусок, выбрав индексы \texttt{2} и \texttt{3}.

Используя оператор \texttt{\$} и присваивание можно создавать новые
колонки датафрейма:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df}\OperatorTok{$}\NormalTok{lovesR <-}\StringTok{ }\NormalTok{T }\CommentTok{#правило recycling - узнали? }
\NormalTok{df}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     name age student lovesR
## 1   Ivan  26   FALSE   TRUE
## 2 Eugeny  34   FALSE   TRUE
## 3   Lena  23    TRUE   TRUE
## 4  Misha  27    TRUE   TRUE
## 5  Sasha  26    TRUE   TRUE
\end{verbatim}

Ну а можно просто обращаться с помощью двух индексов через запятую, как
мы это делали с матрицей:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[}\DecValTok{3}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DecValTok{2}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   age student
## 3  23    TRUE
## 4  27    TRUE
## 5  26    TRUE
\end{verbatim}

Как и с матрицами, первый индекс означает строчки, а второй --- столбцы.

А еще можно использовать названия колонок внутри квадратных скобок:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{,}\StringTok{"age"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 26 34
\end{verbatim}

И здесь перед нами открываются невообразимые возможности! Узнаем, любят
ли R те, кто моложе среднего возраста в группе:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[df}\OperatorTok{$}\NormalTok{age }\OperatorTok{<}\StringTok{ }\KeywordTok{mean}\NormalTok{(df}\OperatorTok{$}\NormalTok{age), }\DecValTok{4}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE TRUE TRUE TRUE
\end{verbatim}

Эту же задачу можно выполнить другими способами:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df}\OperatorTok{$}\NormalTok{lovesR[df}\OperatorTok{$}\NormalTok{age }\OperatorTok{<}\StringTok{ }\KeywordTok{mean}\NormalTok{(df}\OperatorTok{$}\NormalTok{age)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE TRUE TRUE TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[df}\OperatorTok{$}\NormalTok{age }\OperatorTok{<}\StringTok{ }\KeywordTok{mean}\NormalTok{(df}\OperatorTok{$}\NormalTok{age), }\StringTok{'lovesR'}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE TRUE TRUE TRUE
\end{verbatim}

В большинстве случаев подходят сразу несколько способов --- тем не
менее, стоит овладеть ими всеми.

Датафреймы удобно просматривать в RStudio. Для это нужно написать
команду \texttt{View(df)} или же просто нажать на названии нужной
переменной из списка вверху справа (там где Environment). Тогда увидите
табличку, очень похожую на Excel и тому подобные программы для работы с
таблицами. Там же есть и всякие возможности для фильтрации, сортировки и
поиска\ldots{}\footnote{Все, что вы нажмете в этом окошке, никак не
  повлияет на исходную переменную. Так что можете смело использовать эти
  функции для исследования содержимого датафрейма.}

\begin{figure}
\centering
\includegraphics[width=2.08333in]{images/View.png}
\caption{}
\end{figure}

Но, конечно, интереснее все эти вещи делать руками, т.е. с помощью
написания кода.

На этом пора заканчивать с введением и приступать к работе с реальными
данными.

\section{Начинаем работу с реальными данными}\label{real_data}

Итак, пришло время перейти к реальным данным. Мы начнем с использования
датасета (так мы будем называть любой набор данных) по Игре Престолов, а
точнее, по книгам цикла \emph{``Песнь льда и пламени''} Дж. Мартина. Да,
будут спойлеры, но сериал уже давно закончился и сильно разошелся с
книгами\ldots{}

\subsection{Рабочая папка и проекты}\label{wd}

Для начала скачайте файл по
\href{https://raw.githubusercontent.com/Pozdniakov/stats/master/data/character-deaths.csv}{ссылке}

Он, скорее всего, появился у Вас в папке ``Загрузки''. Если мы будем
просто пытаться прочитать этот файл (например, с помощью
\texttt{read.csv()} --- мы к этой функцией очень скоро перейдем), указав
его имя и разрешение, то наткнемся на такую ошибку:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{read.csv}\NormalTok{(}\StringTok{"character-deaths.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in file(file, "rt"): не могу открыть файл 'character-deaths.csv': No
## such file or directory
\end{verbatim}

\begin{verbatim}
## Error in file(file, "rt"): не могу открыть соединение
\end{verbatim}

Это означает, что R не может найти нужный файл. Вообще-то мы даже не
сказали, где искать. Нам нужно как-то совместить место, где R ищет
загружаемые файлы и сами файлы. Для этого есть несколько способов.

\begin{itemize}
\tightlist
\item
  Магомет идет к горе: \emph{перемещение файлов в рабочую папку.}
\end{itemize}

Для этого нужно узнать, какая папка является рабочей с помощью функции
\texttt{getwd()} (без аргументов), найти эту папку в проводнике и
переместить туда файл. После этого можно использовать просто название
файла с разрешением:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"character-deaths.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Гора идет к Магомету: \emph{изменение рабочей папки.}
\end{itemize}

Можно просто сменить рабочую папку с помощью \texttt{setwd()} на ту, где
сейчас лежит файл, прописав путь до этой папки. Теперь файл находится в
рабочей папке:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"character-deaths.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Этот вариант использовать не рекомендуется. Как минимум, это сразу
делает невозможным запустить скрипт на другом компьютере.

\begin{itemize}
\tightlist
\item
  Гора находит Магомета по месту прописки: \emph{указание полного пути
  файла.}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"/Users/Username/Some_Folder/character-deaths.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Этот вариант страдает теми же проблемами, что и предыдущий, поэтому тоже
не рекомендуется.

\begin{quote}
Для пользователей Windows есть дополнительная сложность: знак \texttt{/}
является особым знаком для R, поэтому вместо него нужно использовать
двойной \texttt{//}.
\end{quote}

\begin{itemize}
\tightlist
\item
  Магомет использует кнопочный интерфейс: \emph{Import Dataset.}
\end{itemize}

Во вкладке Environment справа в окне RStudio есть кнопка \emph{Import
Dataset}. Возможно, у Вас возникло непреодолимое желание отдохнуть от
написания кода и понажимать кнопочки --- сопротивляйтесь этому всеми
силами, но не вините себя, если не сдержитесь.

\begin{itemize}
\tightlist
\item
  Гора находит Магомета \emph{в интернете.}
\end{itemize}

Многие функции в R, предназначенные для чтения файлов, могут прочитать
файл не только на Вашем компьютере, но и сразу из интернета. Для этого
просто используйте ссылку вместо пути:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"https://raw.githubusercontent.com/Pozdniakov/stats/master/data/character-deaths.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Каждый Магомет получает по своей горе: \emph{использование проектов в
  RStudio.}
\end{itemize}

\texttt{File\ -\ New\ Project...}, Затем \texttt{New\ Directory},
\texttt{New\ Project}, выбираете подходящее \texttt{Directory\ Name} и
нажимаете \texttt{Create\ Project}.

На первый взгляд это кажется чем-то очень сложным, но это не так.
Пользоваться проектами очень просто и ОЧЕНЬ удобно. При создании проекта
создается отдельная папочка, где у Вас лежат данные, хранятся скрипты,
вспомогательные файлы и отчеты. Если нужно вернуться к другому проекту
--- просто открываете другой проект, с другими файлами и скриптами. Это
еще помогает не пересекаться переменным из разных проектов --- а то,
знаете, использование двух переменных \texttt{data} в разных скриптах
чревато ошибками. Поэтому очень удобным решением будет выделение
отдельного проекта под этот курс.

\begin{quote}
А еще проекты очень удобно работают совместно с системами контроля
версий, в частности, с Git. В RStudio есть для этого удобные
инструменты. Самый простой способ --- при создании проекта
\texttt{File\ -\ New\ Project...} выбрать \texttt{Version\ Control},
затем выбрать Git или Subversion и указать ссылку на репозиторий. После
этого RStudio его склонирует и все сам настроит. Вот
\href{https://happygitwithr.com}{здесь} есть подробный туториал по
работе с Git и RStudio.
\end{quote}

\subsection{Импорт данных}\label{import}

Как Вы уже поняли, импортирование данных --- одна из самых муторных и
неприятных вещей в R. Если у Вас получится с этим справиться, то все
остальное --- ерунда. Мы уже разобрались с первой частью этого процесса
--- нахождением файла с данными, осталось научиться их читать.

Здесь стоит сделать небольшую ремарку. Довольно часто данные
представляют собой табличку. Или же их можно свести к табличке. Такая
табличка, как мы уже выяснили, удобно репрезентируется в виде
датафрейма. Но как эти данные хранятся на компьютере? Есть два варианта:
в \emph{бинарном} и в \emph{текстовом} файле.

Текстовый файл означает, что такой файл можно открыть в программе
``Блокнот'' или ее аналоге и увидеть напечатанный текст: скрипт, роман
или упорядоченный набор цифр и букв. Нас сейчас интересует именно
последний случай. Таблица может быть представлена как текст: отдельные
строчки в файле будут разделять разные строчки таблицы, а какой-нибудь
знак-разделитель отделет колонки друг от друга.

Для чтения данных из текстового файла есть довольно удобная функция
\texttt{read.table()}. Почитайте хэлп по ней и ужаснитесь: столько
разных параметров на входе! Но там же вы увидете функции
\texttt{read.csv()}, \texttt{read.csv2()} и некоторые другие --- по
сути, это тот же \texttt{read.table()}, но с другими дефолтными
параметрами, соответствующие формату файла, который мы загружаем. В
данном случае используется формат .csv, что означает \emph{Comma
Separated Values} (Значения, Разделенные Запятыми). Это просто текстовый
файл, в котором ``закодирована'' таблица: разные строчки разделяют
разные строчки таблицы, а столбцы отделяются запятыми. С этим связана
одна проблема: в некоторых странах (в т.ч. и России) принято
использовать запятую для разделения дробной части числа, а не точку, как
это делается в большинстве стран мира. Поэтому есть ``другой'' формат
.csv, где значения разделены точкой с запятой (\texttt{;}), а дробные
значения --- запятой (\texttt{,}). В этом и различие функций
\texttt{read.csv()} и \texttt{read.csv2()} --- первая функция
предназначена для ``международного'' формата, вторая --- для (условно)
``Российского''.

В первой строчке обычно содержатся названия столбцов --- и это чертовски
удобно, функции \texttt{read.csv()} и \texttt{read.csv2()} по умолчанию
считают первую строчку именно как название для колонок.

Итак, прочитаем наш файл. Для этого используем только параметр
\texttt{file\ =}, который идет первым, и для параметра
\texttt{stringsAsFactors\ =} поставим значение \texttt{FALSE}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"data/character-deaths.csv"}\NormalTok{, }\DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{quote}
По умолчанию, функции семейства \texttt{read.table()} читают
\emph{character} переменные как фактор (\emph{factor}). По сути, факторы
--- это примерно то же самое, что и character, но закодированные
числами. Когда-то это было придумано для экономии используемых времени и
памяти: вместо того, чтобы хранить многократно ``male'' и ``female'',
можно закодировать их числами 1 и 2, записав отдельно, как
расшифровывается 1 и 2. На сегодняшний день факторы обычно становится
просто лишней морокой, хотя факторы могут быть удобным инструментом для
контроля порядка значений при визуализации данных. Некоторые функции
требуют именно \emph{character}, некоторые \emph{factor}, в большинстве
случаев это без разницы. Но иногда непонимание может привести к дурацким
ошибкам. В данном случае мы просто пока обойдемся без факторов.
\end{quote}

Можете проверить с помощью \texttt{View(got)}: все работает! Если же
вылезает какая-то странная ерунда или же просто ошибка --- попробуйте
другие функции и покопаться с параметрами. Для этого читайте
\emph{Help.}

Кроме .csv формата есть и другие варианты хранения таблиц в виде текста.
Например, .tsv --- тоже самое, что и .csv, но разделитель --- знак
табуляции. Для чтения таких файлов есть функция \texttt{read.delim()} и
\texttt{read.delim2()}. Впрочем, даже если бы ее и не было, можно было
бы просто подобрать нужные параметры для функции \texttt{read.table()}.
Есть даже функции (например, \texttt{fread()} из пакета
\texttt{data.table} --- мы ее будем использовать завтра!), которые
пытаются сами ``угадать'' нужные параметры для чтения --- часто они
справляются с этим довольно удачно. Но не всегда. Поэтому стоит
научиться справляться с любого рода данными на входе.

Тем не менее, далеко не всегда таблицы представлены в виде текстового
файла. Самый распространенный пример таблицы в бинарном виде --- родные
форматы \emph{Microsoft Excel}. Если Вы попробуете открыть .xlsx файл в
Блокноте, то увидите кракозябры. Это делает работу с этим файлами
гораздо менее удобной, поэтому стоит избегать экселевских форматов и
стараться все сохранять в .csv.

\begin{quote}
Для работы с экселевскими файлами есть много пакетов: \emph{readxl,
xlsx, openxlsx.} Для чтения файлов \emph{SPSS, Stata, SAS} есть пакет
\emph{foreign}. Что такое пакеты и как их устанавливать мы изучим позже.
\end{quote}

\chapter{День 2. Работа с реальными данными в R}\label{real}

\section{Препроцессинг данных в R}\label{prep}

Вчера мы узнали про основы языка R, про то, как работать с векторами,
списками, матрицами и, наконец, датафреймами. Мы закончили день на
загрузке данных, с чего мы и начнем сегодня:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"data/character-deaths.csv"}\NormalTok{, }\DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

После загрузки данных стоит немного ``осмотреть'' получившийся датафрейм
\texttt{got}.

\subsection{Исследование данных}\label{explore}

Ок, давайте немного поизучаем датасет. Обычно мы привыкли глазами
пробегать по данным, листая строки и столбцы - и это вполне правильно и
логично, от этого не нужно отучаться. Но мы можем дополнить наш базовый
зрительнопоисковой инструментарий несколькими полезными командами.

Во-первых, вспомним другую полезную функцию \texttt{str()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(got)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    917 obs. of  13 variables:
##  $ Name              : chr  "Addam Marbrand" "Aegon Frey (Jinglebell)" "Aegon Targaryen" "Adrack Humble" ...
##  $ Allegiances       : chr  "Lannister" "None" "House Targaryen" "House Greyjoy" ...
##  $ Death.Year        : int  NA 299 NA 300 NA NA 300 300 NA NA ...
##  $ Book.of.Death     : int  NA 3 NA 5 NA NA 4 5 NA NA ...
##  $ Death.Chapter     : int  NA 51 NA 20 NA NA 35 NA NA NA ...
##  $ Book.Intro.Chapter: int  56 49 5 20 NA NA 21 59 11 0 ...
##  $ Gender            : int  1 1 1 1 1 1 1 0 1 1 ...
##  $ Nobility          : int  1 1 1 1 1 1 1 1 1 0 ...
##  $ GoT               : int  1 0 0 0 0 0 1 1 0 0 ...
##  $ CoK               : int  1 0 0 0 0 1 0 1 1 0 ...
##  $ SoS               : int  1 1 0 0 1 1 1 1 0 1 ...
##  $ FfC               : int  1 0 0 0 0 0 1 0 1 0 ...
##  $ DwD               : int  0 0 1 1 0 0 0 1 0 0 ...
\end{verbatim}

Давайте разберемся с переменными в датафрейме:

Колонка \texttt{Name} - здесь все понятно. Важно, что эти имена записаны
абсолютно по-разному: где-то с фамилией, где-то без, где-то в скобочках
есть пояснения. Колонка \texttt{Allegiances} - к какому дому принадлежит
персонаж. С этим сложно, иногда они меняют дома, здесь путаются сами
семьи и персонажи, лояльные им. Особой разницы между \texttt{Stark} и
\texttt{House\ Stark} нет. Следующие колонки - \texttt{Death\ Year},
\texttt{Book.of.Death}, \texttt{Death.Chapter},
\texttt{Book.Intro.Chapter} - означают номер главы, в которой персонаж
впервые появляется, а так же номер книги, глава и год (от завоевания
Вестероса Эйгоном Таргариеном), в которой персонаж умирает.
\texttt{Gender} - \texttt{1} для мужчин, \texttt{0} для женщин.
\texttt{Nobility} - дворянское происхождение персонажа. Последние 5
столбцов содержат информацию, появлялся ли персонаж в книге (всего книг
пока что 5).

Другая полезная функция для больших таблиц - функция \texttt{head()}:
она выведет первые несколько (по дефолту 6) строчек датафрейма.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(got)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                      Name     Allegiances Death.Year Book.of.Death
## 1          Addam Marbrand       Lannister         NA            NA
## 2 Aegon Frey (Jinglebell)            None        299             3
## 3         Aegon Targaryen House Targaryen         NA            NA
## 4           Adrack Humble   House Greyjoy        300             5
## 5          Aemon Costayne       Lannister         NA            NA
## 6         Aemon Estermont       Baratheon         NA            NA
##   Death.Chapter Book.Intro.Chapter Gender Nobility GoT CoK SoS FfC DwD
## 1            NA                 56      1        1   1   1   1   1   0
## 2            51                 49      1        1   0   0   1   0   0
## 3            NA                  5      1        1   0   0   0   0   1
## 4            20                 20      1        1   0   0   0   0   1
## 5            NA                 NA      1        1   0   0   1   0   0
## 6            NA                 NA      1        1   0   1   1   0   0
\end{verbatim}

Есть еще функция \texttt{tail()}. Догадайтесь сами, что она делает.

Для некоторых переменных полезно посмотреть таблицы частотности с
помощью функции \texttt{table()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{table}\NormalTok{(got}\OperatorTok{$}\NormalTok{Allegiances)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##           Arryn       Baratheon         Greyjoy     House Arryn House Baratheon 
##              23              56              51               7               8 
##   House Greyjoy House Lannister   House Martell     House Stark House Targaryen 
##              24              21              12              35              19 
##     House Tully    House Tyrell       Lannister         Martell   Night's Watch 
##               8              11              81              25             116 
##            None           Stark       Targaryen           Tully          Tyrell 
##             253              73              17              22              15 
##        Wildling 
##              40
\end{verbatim}

Уау! Очень просто и удобно, не так ли? Функция \texttt{table()} может
принимать сразу несколько столбцов. Это удобно для получения
\emph{таблиц сопряженности}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{table}\NormalTok{(got}\OperatorTok{$}\NormalTok{Allegiances, got}\OperatorTok{$}\NormalTok{Gender)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                  
##                     0   1
##   Arryn             3  20
##   Baratheon         6  50
##   Greyjoy           4  47
##   House Arryn       3   4
##   House Baratheon   0   8
##   House Greyjoy     1  23
##   House Lannister   2  19
##   House Martell     7   5
##   House Stark       6  29
##   House Targaryen   5  14
##   House Tully       0   8
##   House Tyrell      4   7
##   Lannister        12  69
##   Martell           7  18
##   Night's Watch     0 116
##   None             51 202
##   Stark            21  52
##   Targaryen         1  16
##   Tully             2  20
##   Tyrell            6   9
##   Wildling         16  24
\end{verbatim}

\subsection{Subsetting}\label{subset}

Как мы обсуждали на прошлом занятии, мы можем сабсеттить (т.е. выделять
часть датафрейма) датафрейм, обращаясь к нему и как к матрице:
\emph{датафрейм{[}вектор\_с\_номерами\_строк,
вектор\_с\_номерами\_колонок{]}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got[}\DecValTok{100}\OperatorTok{:}\DecValTok{115}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                 Name   Allegiances
## 100        Blue Bard  House Tyrell
## 101    Bonifer Hasty     Lannister
## 102           Borcas Night's Watch
## 103  Boremund Harlaw       Greyjoy
## 104     Boros Blount     Baratheon
## 105           Borroq      Wildling
## 106      Bowen Marsh Night's Watch
## 107       Bran Stark   House Stark
## 108   Brandon Norrey         Stark
## 109          Brenett          None
## 110 Brienne of Tarth         Stark
## 111            Bronn     Lannister
## 112    Brown Bernarr Night's Watch
## 113           Brusco          None
## 114   Bryan Fossoway     Baratheon
## 115      Bryce Caron     Baratheon
\end{verbatim}

и используя имена колонок:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got[}\DecValTok{508}\OperatorTok{:}\DecValTok{515}\NormalTok{, }\StringTok{"Name"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Mance Rayder"    "Mandon Moore"    "Maric Seaworth"  "Marei"          
## [5] "Margaery Tyrell" "Marillion"       "Maris"           "Marissa Frey"
\end{verbatim}

и даже используя вектора названий колонок!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got[}\DecValTok{508}\OperatorTok{:}\DecValTok{515}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\StringTok{"Name"}\NormalTok{, }\StringTok{"Allegiances"}\NormalTok{, }\StringTok{"Gender"}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                Name     Allegiances Gender
## 508    Mance Rayder        Wildling      1
## 509    Mandon Moore       Baratheon      1
## 510  Maric Seaworth House Baratheon      1
## 511           Marei            None      0
## 512 Margaery Tyrell    House Tyrell      0
## 513       Marillion           Arryn      1
## 514           Maris        Wildling      0
## 515    Marissa Frey            None      0
\end{verbatim}

Мы можем вытаскивать отдельные колонки как векторы:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{houses <-}\StringTok{ }\NormalTok{got}\OperatorTok{$}\NormalTok{Allegiances}
\KeywordTok{unique}\NormalTok{(houses) }\CommentTok{#посмотреть все уникальные значения - почти как с помощью table()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Lannister"       "None"            "House Targaryen" "House Greyjoy"  
##  [5] "Baratheon"       "Night's Watch"   "Arryn"           "House Stark"    
##  [9] "House Tyrell"    "Tyrell"          "Stark"           "Greyjoy"        
## [13] "House Lannister" "Martell"         "House Martell"   "Wildling"       
## [17] "Targaryen"       "House Arryn"     "House Tully"     "Tully"          
## [21] "House Baratheon"
\end{verbatim}

Итак, давайте решим нашу первую задачу - вытащим в отдельный датасет
всех представителей Ночного Дозора. Для этого нам нужно создать вектор
логических значений - результат сравнений колонки \texttt{Allegiances}
со значением \texttt{"Night\textquotesingle{}s\ Watch"} и использовать
его как вектор индексов для датафрейма.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vectornight <-}\StringTok{ }\NormalTok{got}\OperatorTok{$}\NormalTok{Allegiances }\OperatorTok{==}\StringTok{ "Night's Watch"}
\KeywordTok{head}\NormalTok{(vectornight)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE FALSE FALSE FALSE FALSE FALSE
\end{verbatim}

Теперь этот вектор с \texttt{TRUE} и \texttt{FALSE} нам надо
использовать для индексирования строк. Но что со столбцами? Если мы
хотем сохранить все столбцы, то после запятой внутри квадратных скобок
нам не нужно ничего указывать:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nightswatch <-}\StringTok{ }\NormalTok{got[vectornight, ]}
\KeywordTok{head}\NormalTok{(nightswatch)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                                 Name   Allegiances Death.Year Book.of.Death
## 7  Aemon Targaryen (son of Maekar I) Night's Watch        300             4
## 10                            Aethan Night's Watch         NA            NA
## 13                     Alan of Rosby Night's Watch        300             5
## 16                            Albett Night's Watch         NA            NA
## 24                    Alliser Thorne Night's Watch         NA            NA
## 49                             Arron Night's Watch         NA            NA
##    Death.Chapter Book.Intro.Chapter Gender Nobility GoT CoK SoS FfC DwD
## 7             35                 21      1        1   1   0   1   1   0
## 10            NA                  0      1        0   0   0   1   0   0
## 13             4                 18      1        1   0   1   1   0   1
## 16            NA                 26      1        0   1   0   0   0   0
## 24            NA                 19      1        0   1   1   1   0   1
## 49            NA                 75      1        0   0   0   1   0   1
\end{verbatim}

Вуаля! Все это можно сделать проще и в одну строку:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nightswatch <-}\StringTok{ }\NormalTok{got[got}\OperatorTok{$}\NormalTok{Allegiances }\OperatorTok{==}\StringTok{ "Night's Watch"}\NormalTok{, ]}
\end{Highlighting}
\end{Shaded}

И не забывайте про запятую!

Теперь попробуем вытащить одновременно всех Одичалых (\texttt{Wildling})
и всех представителей Ночного Дозора. Это можно сделать, используя
оператор \texttt{\textbar{}} (ИЛИ) при выборе колонок:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nightwatch_wildling <-}
\StringTok{  }\NormalTok{got[got}\OperatorTok{$}\NormalTok{Allegiances }\OperatorTok{==}\StringTok{ "Night's Watch"} \OperatorTok{|}\StringTok{ }\NormalTok{got}\OperatorTok{$}\NormalTok{Allegiances }\OperatorTok{==}\StringTok{ "Wildling"}\NormalTok{, ]}

\KeywordTok{head}\NormalTok{(nightwatch_wildling)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                                 Name   Allegiances Death.Year Book.of.Death
## 7  Aemon Targaryen (son of Maekar I) Night's Watch        300             4
## 10                            Aethan Night's Watch         NA            NA
## 13                     Alan of Rosby Night's Watch        300             5
## 16                            Albett Night's Watch         NA            NA
## 24                    Alliser Thorne Night's Watch         NA            NA
## 49                             Arron Night's Watch         NA            NA
##    Death.Chapter Book.Intro.Chapter Gender Nobility GoT CoK SoS FfC DwD
## 7             35                 21      1        1   1   0   1   1   0
## 10            NA                  0      1        0   0   0   1   0   0
## 13             4                 18      1        1   0   1   1   0   1
## 16            NA                 26      1        0   1   0   0   0   0
## 24            NA                 19      1        0   1   1   1   0   1
## 49            NA                 75      1        0   0   0   1   0   1
\end{verbatim}

\begin{quote}
Кажется очевидным следующий вариант:
\texttt{got{[}got\$Allegiances\ ==\ c("Night\textquotesingle{}s\ Watch",\ "Wildling"),{]}}.
Однако это выдаст не совсем то, что нужно, хотя результат может
показаться верным на первый взгляд. Попробуйте самостоятельно ответить
на вопрос, что происходит в данном случае и чем результат отличается от
предполагаемого. Подсказка: вспомните правило recycling.
\end{quote}

Для таких случаев есть удобный оператор \texttt{\%in\%}, который
позволяет сравнить каждое значение вектора с целым набором значений.
Если значение вектора хотя бы один раз встречается в векторе справа от
\texttt{\%in\%}, то результат - \texttt{TRUE}:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\OperatorTok{:}\DecValTok{6} \OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  TRUE FALSE FALSE  TRUE  TRUE FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nightwatch_wildling <-}\StringTok{ }\NormalTok{got[got}\OperatorTok{$}\NormalTok{Allegiances }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Night's Watch"}\NormalTok{, }\StringTok{"Wildling"}\NormalTok{), ]}
\KeywordTok{head}\NormalTok{(nightwatch_wildling)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                                 Name   Allegiances Death.Year Book.of.Death
## 7  Aemon Targaryen (son of Maekar I) Night's Watch        300             4
## 10                            Aethan Night's Watch         NA            NA
## 13                     Alan of Rosby Night's Watch        300             5
## 16                            Albett Night's Watch         NA            NA
## 24                    Alliser Thorne Night's Watch         NA            NA
## 49                             Arron Night's Watch         NA            NA
##    Death.Chapter Book.Intro.Chapter Gender Nobility GoT CoK SoS FfC DwD
## 7             35                 21      1        1   1   0   1   1   0
## 10            NA                  0      1        0   0   0   1   0   0
## 13             4                 18      1        1   0   1   1   0   1
## 16            NA                 26      1        0   1   0   0   0   0
## 24            NA                 19      1        0   1   1   1   0   1
## 49            NA                 75      1        0   0   0   1   0   1
\end{verbatim}

\subsection{Создание новых колонок}\label{newcol}

Давайте создадим новую колонку, которая будет означать, жив ли еще
персонаж (по книгам). Заметьте, что в этом датасете, хоть он и посвящен
смертям персонажей, нет нужной колонки. Мы можем попытаться ``вытащить''
эту информацию. В колонках \texttt{Death.Year}, \texttt{Death.Chapter} и
\texttt{Book.of.Death} стоит \texttt{NA} у многих персонажей. Например,
у \texttt{"Arya\ Stark"}, которая и по книгам, и по сериалу живее всех
живых и мертвых:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got[got}\OperatorTok{$}\NormalTok{Name }\OperatorTok{==}\StringTok{ "Arya Stark"}\NormalTok{, ]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##          Name Allegiances Death.Year Book.of.Death Death.Chapter
## 56 Arya Stark       Stark         NA            NA            NA
##    Book.Intro.Chapter Gender Nobility GoT CoK SoS FfC DwD
## 56                  2      0        1   1   1   1   1   1
\end{verbatim}

Следовательно, если в \texttt{Book.of.Death} стоит \texttt{NA}, мы можем
предположить, что Джордж Мартин еще не занес своей карающей руки над
этим героем.

Мы можем создать новую колонку \texttt{Is.Alive}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got}\OperatorTok{$}\NormalTok{Is.Alive <-}\StringTok{ }\KeywordTok{is.na}\NormalTok{(got}\OperatorTok{$}\NormalTok{Book.of.Death)}
\end{Highlighting}
\end{Shaded}

Готово! Как легко, просто и элегантно, не так ли? Но в жизни часто
бывает все сложнее, поэтому давайте научимся еще некоторым важным
инструментам.

\section{Циклы, условия, создание функций}\label{loopsetc}

\subsection{If, else, else if}\label{ifelse}

Как и во всех ``нормальных'' языках программирования, в R есть if-else
statements.

Например:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{na_slovah <-}\StringTok{ "Лев Толстой"}
\ControlFlowTok{if}\NormalTok{ (na_slovah }\OperatorTok{==}\StringTok{ "Лев Толстой"}\NormalTok{)\{}
\NormalTok{  na_dele =}\StringTok{ "Парень простой"}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{na_dele =}\StringTok{ }\NormalTok{na_slovah\} }

\NormalTok{na_dele}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Парень простой"
\end{verbatim}

В круглых скобках после \texttt{if} - условие. Если оно \texttt{TRUE},
то выполняется то, что внутри последующих фигурных. Если не выполняется,
то выполняется то, что в фигурных скобках после \texttt{else} (если
\texttt{else} вообще присутствует).

Можно использовать несколько условий:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{na_slovah <-}\StringTok{ "Алексей Толстой"}
\ControlFlowTok{if}\NormalTok{ (na_slovah }\OperatorTok{==}\StringTok{ "Лев Толстой"}\NormalTok{)\{}
\NormalTok{  na_dele =}\StringTok{ "Парень простой"}
\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (na_slovah }\OperatorTok{==}\StringTok{ "Алексей Толстой"}\NormalTok{) \{}
\NormalTok{  na_dele =}\StringTok{ "Лев Толстой"}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{na_dele =}\StringTok{ }\NormalTok{na_slovah\}}

\NormalTok{na_dele}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Лев Толстой"
\end{verbatim}

Тем не менее, с \texttt{if}, \texttt{else}, \texttt{else\ if} есть одна
серьезная проблема - на входе нельзя дать вектор, можно только
единственное значение. Какая боль! Для решения этой проблемы можно
воспользоваться функцией \texttt{ifelse()} или циклами.

\subsection{Функция ifelse()}\label{ifelse}

Функция \texttt{ifelse()} принимает три аргумента - 1) условие (т.е., по
сути, логический вектор, состоящий из \texttt{TRUE} и \texttt{FALSE}),
2) что выдавать в случае \texttt{TRUE}, 3) что выдавать в случае
\texttt{FALSE}. Вот это как раз мы можем применить уже к нашим данным.

Давайте сначала сотрем созданную колонку \texttt{Is.Alive}. Для этого
присвоим ей значение \texttt{NULL}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got}\OperatorTok{$}\NormalTok{Is.Alive <-}\StringTok{ }\OtherTok{NULL}
\end{Highlighting}
\end{Shaded}

Затем создадим ее заново, но уже как текстовую с помощью ifelse():

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got}\OperatorTok{$}\NormalTok{Is.Alive <-}\StringTok{ }\KeywordTok{ifelse}\NormalTok{(}\KeywordTok{is.na}\NormalTok{(got}\OperatorTok{$}\NormalTok{Book.of.Death), }\StringTok{"Alive"}\NormalTok{, }\StringTok{"Dead"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{quote}
К сожалению, аналога \texttt{else\ if} в этой функции нет. Но если у вас
больше, чем два варианта, то никто не мешает использовать
\texttt{ifelse()} внутри \texttt{ifelse()}
\end{quote}

\subsection{For loops}\label{for}

Во многих других языках программирования циклы (типа \texttt{for} и
\texttt{while}) - это основа основ. Но не в R. В R они, конечно, есть,
но использовать их не рекомендуется. Векторизированные операции в R
экономнее - как в плане более короткого и читаемого кода, так и в плане
скорости.

\begin{quote}
Векторизованные функции часто написаны на более низкоуровневом языке
(например, С), которые быстрее R.
\end{quote}

Поэтому дважды подумайте, прежде чем делать то, что я сейчас покажу!
Почти всегда в R можно обойтись без циклов.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got}\OperatorTok{$}\NormalTok{Is.Alive <-}\StringTok{ }\OtherTok{NULL}
\NormalTok{got}\OperatorTok{$}\NormalTok{Is.Alive <-}\StringTok{ }\KeywordTok{character}\NormalTok{(}\KeywordTok{nrow}\NormalTok{(got)) }\CommentTok{#сделаем вектор, заполненный пустыми строками}

\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\KeywordTok{nrow}\NormalTok{(got)) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is.na}\NormalTok{(got}\OperatorTok{$}\NormalTok{Book.of.Death[i])) \{}
\NormalTok{  got}\OperatorTok{$}\NormalTok{Is.Alive[i] <-}\StringTok{ "Alive"}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{  got}\OperatorTok{$}\NormalTok{Is.Alive[i] <-}\StringTok{ "Dead"}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Ужас какой! Да еще и легко ошибиться. К тому, чтобы НЕ использовать
циклы обычно получается приучиться не сразу у тех, кто пришел из других
языков программирования. Часто кажется, что именно в данном случае без
циклов не обойтись, но в подавляющем числе случаев это не так. Дело в
том, что обычно мы работаем в R с датафреймами, которые представляют
собой множество относительно независимых наблюдений. Если мы хотим
провести какие-нибудь операции с этими наблюдениями, то они обычно могут
быть выполнены параллельно. Скажем, вы хотите для каждого испытуемого
пересчитать его массу из фунтов в килограммы. Этот пересчет
осуществляется по одинаковой формуле для каждого испытуемого. Эта
формула не изменится из-за того, что какой-то испытуемый слишком большой
или слишком маленький - для следующего испытуемого формула будет
прежняя. Если Вы встречаете подобную задачу (где функцию можно применить
независимо для всех значений), то без цикла \texttt{for} вполне можно
обойтись.

\begin{quote}
После этих объяснений кому-то может показаться странным, что я вообще
упоминаю про эти циклы. Но для кого-то циклы \texttt{for} настолько
привычны, что их полное отсутствие в курсе может показаться еще более
странным. Поэтому лучше от меня, чем на улице.
\end{quote}

Бывают случаи, в которых расчет значения в строчке все-таки зависит от
предыдущих, но и тогда можно обойтись без циклов! Например, для подсчета
кумулятивной суммы можно использовать функцию \texttt{cumsum()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cumsum}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  3  6 10 15 21 28 36 45 55
\end{verbatim}

Существуют и исключения - некоторые функции не векторизованы. Но и тогда
можно обойтись без \texttt{for}. В R есть ``скрытые'' циклы - семейство
функций \texttt{apply()}. Но сначала нам нужно научиться создавать
собственные функции.

\begin{quote}
Вообще, если писать циклы \texttt{for} корректно, то они не такие уж и
медленные. Главное --- заранее создавать переменную нужного размера и не
изменять размер объекта при каждой итерации цикла. Это основная причина
``тормознутости'' циклов в R. Тем не менее, циклов следует избегать по
той причине, что они со скрипом вписываются в логику функционального
программирования в R, поэтому решения без циклов \texttt{for} обычно
оказываются проще и элегантнее.
\end{quote}

\subsection{Создание функций}\label{newfun}

Поздравляю, сейчас мы выйдем на качественно новый уровень владения R.
Вместо того, чтобы пользоваться теми функциями, которые уже написали за
нас, мы можем сами создавать свои функции! В этом нет ничего сложного.
Функция - это такой же объект в R, как и остальные. Давайте разберем на
примере создания функции \texttt{sumofsquares()}, которая будет считать
сумму квадратичных отклонений от среднего:
\(Sum of squares = \sum_{i=1}^{n}(x_i - \bar{x})^2\)

Эта формула будет нам часто встречаться, когда мы перейдем к статистике!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sumofsquares <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  centralized_x <-}\StringTok{ }\NormalTok{x }\OperatorTok{-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x)}
\NormalTok{  squares <-}\StringTok{ }\NormalTok{centralized_x }\OperatorTok{^}\StringTok{ }\DecValTok{2}
\NormalTok{  sum_of_squares <-}\StringTok{ }\KeywordTok{sum}\NormalTok{(squares)}
  \KeywordTok{return}\NormalTok{(sum_of_squares)}
\NormalTok{\}}
\KeywordTok{sumofsquares}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 82.5
\end{verbatim}

Синтаксис создания функции внешне похож на создание циклов. Мы пишем
ключевое слово \texttt{function}, в круглых скобках обозначаем
переменные, с которыми собираемся что-то делать. Внутри фигурных скобок
пишем выражения, которые будут выполняться при запуске функции. У
функции есть свое собственное окружение --- место, где хранятся
переменные. Вот именно те объекты, которые мы передаем в скобочках, и
будут в окружении, так же как и ``обычные'' переменные для нас в
глобальном окружении. Это означает, что функция будет искать переменные
в первую очередь среди объектов, которые переданы в круглых скобочках. С
ними функция и будет работать. На выходе функция выдаст то, что будет
закинуто в \texttt{return()}. Однако функция \texttt{return()} часто
опускается: если ее нет, то функция будет выводить результат последнего
выражения \footnote{Если в последней строчке будет присвоение, то
  функция ничего не вернет обратно. Это очень распространенная ошибка:
  функция вроде бы работает правильно, но ничего не возвращает. Нужно
  писать так, как будто бы в последней строчке результат выполнения
  выводится в консоль.}. Таким образом, нашу функцию можно написать
короче:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sumofsquares <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\NormalTok{  centralized_x <-}\StringTok{ }\NormalTok{x }\OperatorTok{-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x)}
\NormalTok{  squares <-}\StringTok{ }\NormalTok{centralized_x }\OperatorTok{^}\StringTok{ }\DecValTok{2}
  \KeywordTok{sum}\NormalTok{(squares)}
\NormalTok{\}}
\KeywordTok{sumofsquares}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 82.5
\end{verbatim}

Можно еще сократить функцию:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sumofsquares <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
  \KeywordTok{sum}\NormalTok{((x }\OperatorTok{-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x)) }\OperatorTok{^}\StringTok{ }\DecValTok{2}\NormalTok{)}
\NormalTok{\}}
\KeywordTok{sumofsquares}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 82.5
\end{verbatim}

На самом деле, если функция занимает всего одну строчку, то фигурные
скобки и не нужны.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sumofsquares <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{sum}\NormalTok{((x }\OperatorTok{-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x)) }\OperatorTok{^}\StringTok{ }\DecValTok{2}\NormalTok{)}

\KeywordTok{sumofsquares}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 82.5
\end{verbatim}

Вообще, фигурные скобки используются для того, чтобы выполнить серию
выражений, но вернуть только результат выполнения последнего выражения.
Это можно использовать, чтобы не создавать лишних временных переменных в
глобальном окружении.

Когда стоит создавать функции? Существует
\href{https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)}{``правило
трех''} - если у вас есть три куска очень похожего кода, то самое время
превратить код в функцию. Это очень условное правило, но, действительно,
стоит избегать копипастинга в коде. В этом случае очень легко ошибиться,
код становится нечитаемым.

Но есть и другой подход к созданию функций. Их стоит создавать не
столько для того, чтобы использовать тот же код снова, сколько для
абстрагирования от того, что происходит в отдельных строчках кода. Если
несколько строчек кода были написаны для того, чтобы решить одну задачу,
которой можно дать понятное название (например, подсчет какой-то
особенной метрики, для которой нет готовой функции в R), то этот код
стоит обернуть в функцию. Если функция работает корректно, то теперь не
нужно думать над тем, что происходит внутри нее. Вы ее можете мысленно
представить как операцию, которая имеет определенный вход и выход ---
как и встроенные функции в R.

The reason for writing a function is not to reuse its code, but to name
the operation it performs.

--- Tim ``Agile Otter'' Ottinger (\citet{tottinge}) January 22, 2013

\subsection{Cемейство функций apply()}\label{apply}

Семейство? Да, их целое множество: \texttt{apply()},
\texttt{lapply()},\texttt{sapply()},
\texttt{vapply()},\texttt{tapply()},\texttt{mapply()},
\texttt{rapply()}\ldots{} Ладно, не пугайтесь, всех их знать не
придется. Обычно достаточно первых двух-трех. Проще всего пояснить как
они работают на простой матрице с числами:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{A <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{12}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{)}
\NormalTok{A }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    4    7   10
## [2,]    2    5    8   11
## [3,]    3    6    9   12
\end{verbatim}

Теперь представим, что нам нужно посчитать что-нибудь (например, сумму)
по каждой из строк. С помощью функции \texttt{apply()} вы можете в
буквальном смысле ``применить'' какую либо функцию к матрице или
датафрейму. Правда, эта функция будет пытаться превратить датафрейм в
матрицу, так что будьте осторожны. Синтаксис такой:
\texttt{apply(X,\ MARGIN,\ FUN,\ ...)}, где \texttt{X} --- Ваши данные,
\texttt{MARGIN} это \texttt{1} (для строк), \texttt{2} (для колонок),
\texttt{c(1,2)} для строк и колонок (т.е. для каждого элемента по
отдельности), а \texttt{FUN} --- это функция, которую вы хотите
применить, но без скобок \texttt{()}! \texttt{apply()} будет брать
строки/колонки из \texttt{X} в качестве первого аргумента для функции.

\begin{figure}
\centering
\includegraphics[width=4.16667in]{images/Apply_function.png}
\caption{apply}
\end{figure}

Давайте разберем на примере:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(A, }\DecValTok{1}\NormalTok{, sum) }\CommentTok{#сумма по каждой строчке}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 22 26 30
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(A, }\DecValTok{2}\NormalTok{, sum) }\CommentTok{#сумма по каждой колонке}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  6 15 24 33
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(A, }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{), sum) }\CommentTok{#кхм... сумма каждого элемента}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    4    7   10
## [2,]    2    5    8   11
## [3,]    3    6    9   12
\end{verbatim}

Заметьте, мы вставляем функцию (а не ее аутпут!) как инпут в функцию.

\begin{figure}
\centering
\includegraphics[width=4.16667in]{images/monitor.jpg}
\caption{}
\end{figure}

\subsection{Анонимные функции}\label{anon}

Если вдумаетесь, то тут возникает определенная сложность: функция
\texttt{apply()} будет работать только в том случае, если функция
принимает первым аргументом именно то, что мы ей даем\ldots{} А если это
не так? Тогда мы можем создать \emph{анонимные функции}!

\begin{quote}
Еще можно написать нужные аргументы через запятую после аргумента FUN:
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(A, }\DecValTok{1}\NormalTok{, weighted.mean, }\DataTypeTok{w =} \KeywordTok{c}\NormalTok{(}\FloatTok{0.2}\NormalTok{, }\FloatTok{0.4}\NormalTok{, }\FloatTok{0.3}\NormalTok{, }\FloatTok{0.1}\NormalTok{)) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4.9 5.9 6.9
\end{verbatim}

Анонимные функции - это функциии, которые будут использоваться один раз
и без названия.

\begin{quote}
Питонистам знакомо понятие \emph{лямбда-функций}. Да, это то же самое
\end{quote}

Например, мы можем посчитать сумму квадратичных отклонений от среднего
без называния этой функции:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(A, }\DecValTok{1}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{sum}\NormalTok{((x}\OperatorTok{-}\KeywordTok{mean}\NormalTok{(x))}\OperatorTok{^}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 45 45 45
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(A, }\DecValTok{2}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{sum}\NormalTok{((x}\OperatorTok{-}\KeywordTok{mean}\NormalTok{(x))}\OperatorTok{^}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2 2 2 2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(A, }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{), }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{sum}\NormalTok{((x}\OperatorTok{-}\KeywordTok{mean}\NormalTok{(x))}\OperatorTok{^}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    0    0    0    0
## [2,]    0    0    0    0
## [3,]    0    0    0    0
\end{verbatim}

Как и в случае с обычной функцией, в качестве \texttt{x} выступает
объект, с которым мы хотим что-то сделать, а дальше следует функция,
которую мы собираемся применить к \texttt{х}. Можно использовать не
\texttt{х}, а что угодно, как и в обычных функциях:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(A, }\DecValTok{1}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(whatevername) }\KeywordTok{sum}\NormalTok{((whatevername}\OperatorTok{-}\KeywordTok{mean}\NormalTok{(whatevername))}\OperatorTok{^}\DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 45 45 45
\end{verbatim}

Ок, с \texttt{apply()} разобрались. А что с остальными? Некоторые из них
еще проще и не требуют индексов, например, \texttt{lapply} (для
применения к каждому элементу списка) и \texttt{sapply()} - упрощенная
версия \texttt{lapply()}, которая пытается по возможности ``упростить''
результат до вектора или матрицы. Давайте теперь сделаем то же самое,
что мы и делали (создание колонки \texttt{got\$Is.Alive}), но с помощью
\texttt{sapply()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got}\OperatorTok{$}\NormalTok{Is.Alive <-}\StringTok{ }\OtherTok{NA}
\NormalTok{got}\OperatorTok{$}\NormalTok{Is.Alive <-}\StringTok{ }\KeywordTok{sapply}\NormalTok{(got}\OperatorTok{$}\NormalTok{Book.of.Death, }\ControlFlowTok{function}\NormalTok{ (x) }\KeywordTok{ifelse}\NormalTok{(}\KeywordTok{is.na}\NormalTok{(x), }\StringTok{"Alive"}\NormalTok{, }\StringTok{"Dead"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Можно применять функции \texttt{lapply()} и \texttt{sapply()} на
датафреймах. Поскольку фактически датафрейм - это список из векторов
одинаковой длины (см. \ref{df}), то итерироваться эти функции будут по
колонкам:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lapply}\NormalTok{(got, class)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $Name
## [1] "character"
## 
## $Allegiances
## [1] "character"
## 
## $Death.Year
## [1] "integer"
## 
## $Book.of.Death
## [1] "integer"
## 
## $Death.Chapter
## [1] "integer"
## 
## $Book.Intro.Chapter
## [1] "integer"
## 
## $Gender
## [1] "integer"
## 
## $Nobility
## [1] "integer"
## 
## $GoT
## [1] "integer"
## 
## $CoK
## [1] "integer"
## 
## $SoS
## [1] "integer"
## 
## $FfC
## [1] "integer"
## 
## $DwD
## [1] "integer"
## 
## $Is.Alive
## [1] "character"
\end{verbatim}

Еще одна функция из семейства \texttt{apply()} - функция
\texttt{replicate()} - самый простой способ повторить одну и ту же
операцию много раз. Обычно это используется при симуляции данных и
моделировании. Например, давайте сделаем выборку из логнормального
распределения:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{1}\NormalTok{) }\CommentTok{#Это сделает выбор случайных чисел воспроизводимым}
\NormalTok{samp <-}\StringTok{ }\KeywordTok{rlnorm}\NormalTok{(}\DecValTok{30}\NormalTok{)}
\KeywordTok{hist}\NormalTok{(samp)}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-128-1.pdf}

А теперь давайте сделаем 1000 таких выборок и из каждой возьмем среднее:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sampdist <-}\StringTok{ }\KeywordTok{replicate}\NormalTok{(}\DecValTok{1000}\NormalTok{, }\KeywordTok{mean}\NormalTok{(}\KeywordTok{rlnorm}\NormalTok{(}\DecValTok{30}\NormalTok{)))}
\KeywordTok{hist}\NormalTok{(sampdist)}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-129-1.pdf}

\begin{quote}
Про функции для генерации случайных чисел и про визуализацию мы
поговорим в следующие дни.
\end{quote}

Если хотите познакомиться с семейством \texttt{apply()} чуточку ближе,
то рекомендую
\href{https://www.datacamp.com/community/tutorials/r-tutorial-apply-family}{вот
этот туториал}.

\section{Работа с текстом}\label{text}

Работа с текстом - это отдельная и сложная задача. И у R есть мощные
инструменты для этого!. Для более-менее продвинутой работы с текстом
придется выучить специальный язык - ``регулярные выражения''
(\emph{regular expressions, regex, regexp}). Регулярные выражения
реализованы на многих языках, в том числе в R. Но мы пока обойдемся
наиболее простыми функциями, которые покроют большую часть того, что нам
нужно уметь делать при работе с текстом.

У нас есть две текстовые переменные - \texttt{Name} (имя персонажа) и
\texttt{Allegiances} (дом, которому персонаж принадлежит/лоялен).
Давайте попробуем вытащить всех персонажей, лояльных Старкам - как тех,
у которых в \texttt{Allegiances} стоит \texttt{"House\ Stark"}, так и
тех, у кого стоит \texttt{"Stark"}. В этом нам поможет функция
\texttt{grep()}. Заметьте, что в этой функции необычного - первым ее
аргументом является паттерн, который мы ищем, а не данные (как обычно).

\begin{quote}
Я рекомендую пока что ставить параметр \texttt{fixed\ =\ TRUE}. Иначе он
будет искать по правилам регулярных выражений (да, R по умолчанию
работает именно с регулярными выражениями). Сейчас это не создаст нам
проблем, а вот если будете искать что-то с математическими или другими
знаками - проблемы будут возникать. Регулярные выражения - это
специальный язык поиска сложных паттернов в тексте. Типа ``Хочу все
первые три знака после второго дефиса''. Он выглядит страшным и
совершенно не читаемым, но в нем нет ничего сложного. Если Вам нужно
много работать с текстом, то уделите один день освоению ``регулярок''!
По умолчанию с помощью функции grep() идет поиск именно по регулярным
выражениям. Чтобы это отключить, мы и используем параметр fixed = TRUE.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{grep}\NormalTok{(}\StringTok{"Stark"}\NormalTok{, got}\OperatorTok{$}\NormalTok{Allegiances, }\DataTypeTok{fixed =} \OtherTok{TRUE}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   [1]  17  25  29  30  47  53  56  65  69  85  90  91 107 108 110 127 128 133
##  [19] 141 155 161 175 183 194 198 200 209 217 218 227 250 260 262 265 272 286
##  [37] 326 328 340 342 343 346 348 353 362 367 381 392 397 398 405 411 413 414
##  [55] 417 419 448 464 465 467 471 489 500 518 533 534 539 550 561 570 576 581
##  [73] 590 607 613 623 645 647 664 686 697 698 699 702 705 706 709 713 717 726
##  [91] 744 775 783 789 799 817 820 856 872 876 879 881 894 896 897 898 899 912
\end{verbatim}

Результат --- индексы, которые мы можем использовать, чтобы вытащить
всех Старков:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{starks <-}\StringTok{ }\NormalTok{got[}\KeywordTok{grep}\NormalTok{(}\StringTok{"Stark"}\NormalTok{, got}\OperatorTok{$}\NormalTok{Allegiances, }\DataTypeTok{fixed =} \OtherTok{TRUE}\NormalTok{), ]}
\KeywordTok{table}\NormalTok{(starks}\OperatorTok{$}\NormalTok{Allegiances)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## House Stark       Stark 
##          35          73
\end{verbatim}

Остались только Старки!

\begin{quote}
Если вы вдруг при чтении файла не поставили
\texttt{stringsAsFactors\ =\ FALSE}, то в полученной таблице останутся
другие дома, пусть и с нулевыми значениями. Так работают факторы в R.
Чтобы избавиться от ``пустых'' уровней факторов (иногда это нужно),
можно воспользоваться простой функцией \texttt{droplevels()}. С
character колонками такой магии не нужно.
\end{quote}

Хорошо, как находить что-то в текстовых переменных --- разобрались. А
как заменять? У нас здесь есть очевидная задача: cовместить все
\texttt{"House\ Stark"} и просто \texttt{"Stark"}, но для всех домов в
оригинальном датасете. Для этого можно поменять все \texttt{"House\ "}
на пустую строку \texttt{""} с помощью функции \texttt{gsub()}. Она
работает примерно так же как и \texttt{grep()}, но сначала ищет искомый
паттерн (\texttt{"House\ "}), затем то, на что мы его меняем
(\texttt{""}), потом наш вектор. На выходе мы получим новый вектор,
который можно подставить взамен старой колонки \texttt{got\$Allegiances}
(или создать новую колонку \texttt{got\$Houses}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got}\OperatorTok{$}\NormalTok{Houses <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{"House "}\NormalTok{, }\StringTok{""}\NormalTok{, got}\OperatorTok{$}\NormalTok{Allegiances, }\DataTypeTok{fixed =} \OtherTok{TRUE}\NormalTok{)}
\KeywordTok{table}\NormalTok{(got}\OperatorTok{$}\NormalTok{Allegiances)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##           Arryn       Baratheon         Greyjoy     House Arryn House Baratheon 
##              23              56              51               7               8 
##   House Greyjoy House Lannister   House Martell     House Stark House Targaryen 
##              24              21              12              35              19 
##     House Tully    House Tyrell       Lannister         Martell   Night's Watch 
##               8              11              81              25             116 
##            None           Stark       Targaryen           Tully          Tyrell 
##             253              73              17              22              15 
##        Wildling 
##              40
\end{verbatim}

Другая важная функция для работы с текстом: \texttt{nchar()} -
количество знаков. Давайте найдем самое длинное имя в книгах Джорджа
Мартина про лед, пламя, насилие и инцест:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{max}\NormalTok{(}\KeywordTok{nchar}\NormalTok{(got}\OperatorTok{$}\NormalTok{Name))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 33
\end{verbatim}

33 символа! Интересно, у кого же это?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{longest <-}\StringTok{ }\KeywordTok{which.max}\NormalTok{(}\KeywordTok{nchar}\NormalTok{(got}\OperatorTok{$}\NormalTok{Name)) }\CommentTok{#index of the longest name}
\NormalTok{got[longest, }\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                                Name   Allegiances
## 7 Aemon Targaryen (son of Maekar I) Night's Watch
\end{verbatim}

А, ну, конечно, вот это вот пояснение в скобочках все испортило. Давайте
его уберем.

Для этого нам понадобится функция \texttt{substr()}. Она работает как
``ножницы'': Сначала берем вектор значений, а потом два числа: откуда и
покуда будем вырезать нужный кусок:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{aemon <-}\StringTok{ }\KeywordTok{substr}\NormalTok{(got}\OperatorTok{$}\NormalTok{Name[longest], }\DecValTok{1}\NormalTok{, }\DecValTok{15}\NormalTok{)}
\NormalTok{aemon}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Aemon Targaryen"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got}\OperatorTok{$}\NormalTok{Name[longest] <-}\StringTok{ }\NormalTok{aemon }
\end{Highlighting}
\end{Shaded}

Ну и, конечно, нам нужно знать как объединять строки. Не в вектор, а в
одно значение. Для этого есть простые функции \texttt{paste()} и
\texttt{paste0()}. Для \texttt{paste()} можно выбрать разделить
\texttt{sep\ =}, который по умолчанию является пробелом, а
\texttt{paste0()} - это функция \texttt{paste()} с пустым разделителем
по умолчанию:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{paste}\NormalTok{(}\StringTok{"R"}\NormalTok{, }\StringTok{"is"}\NormalTok{, }\StringTok{"love"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "R is love"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{paste0}\NormalTok{(}\StringTok{"R"}\NormalTok{, }\StringTok{"is"}\NormalTok{, }\StringTok{"love"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Rislove"
\end{verbatim}

Обратите внимание: функция \texttt{paste()} принимает в качестве
аргуметов векторы, чтобы соединить их в один вектор. Если нужно
превратить один строковый вектор в одно значение, то можно поставить
какое-нибудь значение параметра \texttt{collapse\ =} (по дефолту это
\texttt{NULL}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{phrase <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"All"}\NormalTok{, }\StringTok{"you"}\NormalTok{, }\StringTok{"need"}\NormalTok{, }\StringTok{"is"}\NormalTok{, }\StringTok{"love"}\NormalTok{), }\DataTypeTok{collapse =} \StringTok{" <3 "}\NormalTok{)}
\NormalTok{phrase}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "All <3 you <3 need <3 is <3 love"
\end{verbatim}

Функция \texttt{strsplit()} делает наоборот - она разбирает значение на
вектор с выбранным разделителем:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{strsplit}\NormalTok{(phrase, }\DataTypeTok{split =} \StringTok{" <3 "}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] "All"  "you"  "need" "is"   "love"
\end{verbatim}

\begin{quote}
Для тех, кто привык к C format (printf-style formatting), в R это можно
сделать с помощью функции \texttt{sprintf()}:
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sprintf}\NormalTok{(}\StringTok{"%i на кроссовки; Трачу деньги на %s и трачу их без остановки"}\NormalTok{, }\DecValTok{20000}\NormalTok{, }\StringTok{"ерунду"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "20000 на кроссовки; Трачу деньги на ерунду и трачу их без остановки"
\end{verbatim}

Пока что этого будет нам достаточно для работы с текстом. В принципе,
этих функций достаточно в большинстве случаев. Если же вдруг нужно
копнуть глубже - придется освоить язык регулярных выражений. Он кажется
страшным, но это займет у Вас всего пару часов с вот этим
\href{https://regexone.com/}{удобным онлайн туториалом} и
\href{https://regex101.com/}{этим онлайн инструментом}. Для базовой
работы с текстом в R есть вот
\href{http://gastonsanchez.com/Handling_and_Processing_Strings_in_R.pdf}{эта
немного занудная, но короткая книжка}. В ней примерно все то же самое,
что мы сегодня разобрали, но на более глубоком уровне.

\section{Работа с дополнительными пакетами}\label{new_pack}

Пакеты в R - это обычно набор функций (иногда датасетов и т.п.) с
документацией по ним. Они нужны для того, чтобы выйти за рамки
функциональности базового R или же просто для того, чтобы сделать работу
в R еще удобнее. Для R есть более 15000 пакетов (по данным на февраль
2020 года), которые вы можете скачать с зеркал Comprehensive R Archive
Network (CRAN) с помощью простой функции \texttt{install.packages()},
где в качестве основного аргумента используется вектор имен скачиваемых
пакетов.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"data.table"}\NormalTok{, }\StringTok{"dplyr"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Для установки пакетов нужен интернет!

Эти 15000+ пакетов содержат в себе уйму всякого. Некоторые представляют
собой буквально одну удобную функцию, некоторые посвящены какой-то
узкоспециализированной теме (например, работе с текстом), есть даже
просто наборы всякой всячины от того или иного разработчика (например,
пакет \texttt{Hmisc}). Кроме того, можно устанавливать пакеты из других
источников и делать собственные.\\
После установки пакета Вы увидете его во вкладке Packages справа внизу

\begin{figure}
\centering
\includegraphics[width=4.16667in]{images/packages.PNG}
\caption{}
\end{figure}

Затем нужно ``присоединить'' этот пакет. Запомните: устанавливаете пакет
всего один раз, а присоединяете его в каждой новой сессии.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"dplyr"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}
\centering
\includegraphics[width=4.16667in]{images/pack2.PNG}
\caption{}
\end{figure}

\section{Решейпинг данных}\label{reshape}

Теперь мы возьмем данные по битвам из книг про Игру Престолов. Каждая
строчка означает какую-то битву, описанную в книгах нашего любомого
пухляша-бородача. Подробную информацию про набор данных можно найти
\href{https://www.kaggle.com/mylesoneill/game-of-thrones}{здесь}.
Скачать данные можно
\href{https://raw.githubusercontent.com/Pozdniakov/stats/master/data/character-deaths.csv}{здесь}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bat <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"data/battles.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

После освоения базовых возможностей датафрейма, становится понятно, что
чего-то не хватает. Допустим, мы хотим узнать, в каких годах были
наиболее эпичные битвы. Нам нужно посчитать среднее количество бойцов
атакующей армии по годам. Зная все года битв, можно сделать так:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(bat[bat}\OperatorTok{$}\NormalTok{year }\OperatorTok{==}\StringTok{ }\DecValTok{298}\NormalTok{, }\StringTok{"attacker_size"}\NormalTok{], }\DataTypeTok{na.rm =}\NormalTok{ T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 11175
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(bat[bat}\OperatorTok{$}\NormalTok{year }\OperatorTok{==}\StringTok{ }\DecValTok{299}\NormalTok{, }\StringTok{"attacker_size"}\NormalTok{], }\DataTypeTok{na.rm =}\NormalTok{ T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5134.308
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(bat[bat}\OperatorTok{$}\NormalTok{year }\OperatorTok{==}\StringTok{ }\DecValTok{300}\NormalTok{, }\StringTok{"attacker_size"}\NormalTok{], }\DataTypeTok{na.rm =}\NormalTok{ T)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 19333.33
\end{verbatim}

Всякий раз, когда у Вас возникает желание сделать что-нибудь с помощью
священного копипаста - задумайтесь: разве ради этого Вы пришли на курс?
Конечно, нет! Как говорилось ранее, если появляется желание копипастить
одни и те же строчки, это означает, что, скорее всего, это можно сделать
быстрее, проще и лучше.

Конечно, стандартными возможностями R, которые мы уже освоили, нашу
задачу можно выполнить, но довольно неудобно:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sapply}\NormalTok{(}\KeywordTok{unique}\NormalTok{(bat}\OperatorTok{$}\NormalTok{year), }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{mean}\NormalTok{(bat}\OperatorTok{$}\NormalTok{attacker_size[bat}\OperatorTok{$}\NormalTok{year }\OperatorTok{==}\StringTok{ }\NormalTok{x], }\DataTypeTok{na.rm =}\NormalTok{ T))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 11175.000  5134.308 19333.333
\end{verbatim}

\begin{quote}
В принципе, есть много других способов сделать то же самое - функция
\texttt{aggregate()}, \texttt{split()}, но мы на них останавливаться не
будем.
\end{quote}

Тем не менее, задача аггрегации данных - это то, что необходимо
постоянно. Усреднить значения по каждому испытуемому, получить средние
значения по каждому из уровней всех переменных\ldots{} А если нужно не
усреднять, а делать что-то более сложное? Очевидно, что тут нам нужны
какие-то новые инструменты, которых мы еще не знаем. И здесь у нас
появляется важная развилка - есть два разных пакета, которые позволяют
удобно делать агрегацию и другие операции, о которых мы говорили раньше
(например, сабсеттинг) и о которых мы еще поговорим позднее.

\subsection{data.table vs.~dplyr}\label{holywar}

\begin{figure}
\centering
\includegraphics{images/New-Mind-Map_1.jpg}
\caption{}
\end{figure}

Начнем с пакета \textbf{\texttt{dplyr}} от создателя \texttt{ggplot2} (а
еще \texttt{tidyr}, \texttt{stringr}, \texttt{lubridate},
\texttt{devtools}, \texttt{httr}, \texttt{readr} и много других
популярных пакетов для R) Хэдли Уиэкхэма.

\begin{quote}
Сейчас этот парень работает в RStudio, следы чего вы можете обнаружить.
Например, откройте Help - Cheatsheets: Вы обнаружите читшиты для dplyr.
Но не для data.table =)
\end{quote}

Этот подход сильно перерабатывает синтаксис R, отличается понятностью и
читаемостью. Более того, он очень популярен, многие пакеты предполагают,
что Вы именно с ним работаете и хорошо им владеете.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"dplyr"}\NormalTok{)}
\NormalTok{bat }\OperatorTok{%>%}\StringTok{ }\KeywordTok{group_by}\NormalTok{(year) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{summarise}\NormalTok{(}\KeywordTok{mean}\NormalTok{(attacker_size, }\DataTypeTok{na.rm =}\NormalTok{ T))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `summarise()` ungrouping output (override with `.groups` argument)
\end{verbatim}

\begin{verbatim}
## # A tibble: 3 x 2
##    year `mean(attacker_size, na.rm = T)`
##   <int>                            <dbl>
## 1   298                           11175 
## 2   299                            5134.
## 3   300                           19333.
\end{verbatim}

Просто попытайтесь догадаться, что значат эти строчки: берем датафрейм,
группируем по году, выводим какую-то суммирующию информацию по каждой
группе.

\begin{quote}
Оператор \%\textgreater{}\% называется ``пайпом'' (pipe), т.е.
``трубой''. Он означает, что следующая функция принимает на вход в
качестве первого аргумента аутпут предыдущей. Фактически, это примерно
то же самое, что и вставлять аутпут функции как первый инпут в другую
функцию. Просто выглядит это красивее и читабельнее. Как будто данные
пропускаются через трубы функций или конвеерную ленту на заводе, если
хотите. А то, что первый параметр функции - это почти всегда данные,
работает нам на руку. Этот оператор взят из пакета magrittr. Возможно,
даже если вы не захотите пользоваться dplyr, использование пайпов Вам
понравится. Ну а если нет, то тогда вперед к data.table!
\end{quote}

Множество пакетов, опирающихся и дополняющих \texttt{dplyr}
(\texttt{magrittr}, \texttt{purrr}, \texttt{stringr}, \texttt{readr},
\texttt{tidyr}, \texttt{tibble} и т.д.), называют ``tidyverse''. Эти
пакеты предлагают альтернативные варианты для многих операций в R.
Например, \texttt{stringr} дает удобные функции для работы со строковыми
данными (фактически заменяя стандартные), пакет \texttt{readr} заменяет
стандартный импорт данных, а \texttt{purrr} - функции типа
\texttt{apply()}. Выходит, что это уже практически новый язык!

Другой подход - пакет \textbf{\texttt{data.table}}. Он не так сильно
перерабатывает стиль работы в R, но изменяет датафреймы,
``совершенствуя'' их. Этот пакет сильно повышает скорость обработки
данных, поскольку написан с использованием более совершенных алгоритмов.
\texttt{data.table} обладает более ``суровым'' и лаконичным синтаксисом:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"data.table"}\NormalTok{)}
\NormalTok{batdt <-}\StringTok{ }\KeywordTok{as.data.table}\NormalTok{(bat)}
\NormalTok{batdt[,}\KeywordTok{mean}\NormalTok{(attacker_size, }\DataTypeTok{na.rm =}\NormalTok{ T), by =}\StringTok{ }\NormalTok{year]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    year        V1
## 1:  298 11175.000
## 2:  299  5134.308
## 3:  300 19333.333
\end{verbatim}

Внешне все очень похоже на работу с обычным data.frame, но если
приглядитесь, то увидите, что появился непонятный \emph{by =} - это как
раз-таки группировка. Более того, мы делаем анализ прямо в том месте,
где раньше просто выбирали столбцы. Да и столбцы эти (как и строчки) мы
выбираем без кавычек.

\subsection{Так что же выбрать?}\label{what}

Мы остановимся на data.table. В принципе, если Вы освоили один пакет, то
альтернативный пакет уже не нужен - про это можете почитать
замечательную дискуссию от создателей пакетов. Основной вывод - оба
пакета позволяют делать нужные нам вещи, но
\href{https://stackoverflow.com/questions/21435339/data-table-vs-dplyr-can-one-do-something-well-the-other-cant-or-does-poorly}{разными
способами}.

\subsection{data.table}\label{dt}

Мы начнем с очень милой функции под названием \texttt{fread()}. Эта
функция похожа на функцию \texttt{read.table()}, но быстрее (воистину!)
и автоматически подбирает параметры чтения файлов (обычно правильно). В
большинстве случаев Вы можете просто использовать эту функцию без
задания каких-либо параметров для чтения таблицы - и готово!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{batdt <-}\StringTok{ }\KeywordTok{fread}\NormalTok{(}\StringTok{"data/battles.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Ну, на этом датасете Вы едва ли заметите разницу в скорости, а вот если
у вас датасет побольше, скажем, на несколько десятков мегабайт, то
разница будет заметна.
\end{quote}

Заметьте, теперь это уже не совсем датафрейм:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(batdt)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "data.table" "data.frame"
\end{verbatim}

Одновременно датафрейм и дататейбл! Это означает, что почти все, что мы
умеем делать с датафреймом, мы можем делать так же и с дататейблом, но
теперь нам открываются новые возможности (и новый синтаксис).

\begin{quote}
Некоторые используют пакет data.table только для того, чтобы быстрее
загружать данные. Если Вы захотите пойти этим путем, то нужно поставить
параметр \texttt{data.table\ =\ FALSE} - тогда данные загрузятся как
``чистый'' датафрейм. Кроме того, в R можно использовать функцию, не
подключая весь пакет с помощью оператора \texttt{::}. То есть вот так:
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{batdataframe <-}\StringTok{ }\NormalTok{data.table}\OperatorTok{::}\KeywordTok{fread}\NormalTok{(}\StringTok{"data/battles.csv"}\NormalTok{, }\DataTypeTok{data.table =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Этот оператор \texttt{::} еще рекомендуется использовать, если у Вас
есть есть несколько одноименных функций для одного и того же из разных
пакетов, и есть риск запутаться в том, какой именно пакет вы
используете.
\end{quote}

\subsubsection{Основы data.table}\label{base_dt}

data.table обладает своим синтаксисом, напоминающим SQL (если Вы не
знаете, что это, то Вы счастливый человек; ну а если знаете, то быстрее
освоитесь). Главная формула звучит так:

\texttt{DT{[}i,\ j,\ by{]}}

Здесь \texttt{i} - это то, какие Вы выбираете строки. Очень похоже на
обычный data.frame, не так ли? \texttt{j} - это то, что Вы считаете. Это
тоже похоже на датафрейм - Вы выбираете колонки. Но тут есть важное
различие - можно что-то считать прямо внутри \texttt{j}, т.е. внутри
квадратных скобочек! \texttt{by} - это аггрегация по подгруппам.

\begin{quote}
``General form: DT{[}i, j, by{]} ``Take DT, subset rows using
\texttt{i}, then calculate \texttt{j} grouped by \texttt{by}'' (из
читшита по data.table). Если проводить аналогии с SQL, то i = WHERE, j =
SELECT \textbar{} UPDATE, by = GROUP BY.
\end{quote}

Естественно, далеко не всегда используются сразу все три \texttt{i},
\texttt{j} и \texttt{by}. Но это дает прекрасные возможности делать
сложные операции с данными в одну строчку. Как и в датафрейме, если Вы
хотите выбрать все строчки, просто оставляете поле перед первой запятой
пустым. Если не хотите делать группировку, то можете просто не писать
вторую запятую. Если же не писать вообще запятых внутри квадратных
скобок, то все внутри будет считаться как \texttt{i}, т.е. Вы будете
выбирать только строки. Но я советую все-таки ставить одну запятую,
чтобы не запутаться с тем, где выбираются строки (\texttt{i}), а где
производятся манипуляции с колонками (\texttt{j}).

Скажем, мы хотим посчитать средний размер защищающихся армий только для
битв, где победили атакующие, группируя по регионам:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{batdt[attacker_outcome }\OperatorTok{==}\StringTok{ "win"}\NormalTok{, }\KeywordTok{mean}\NormalTok{(attacker_size, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{), by =}\StringTok{ }\NormalTok{region]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##             region       V1
## 1: The Westerlands 9000.000
## 2:  The Riverlands 4425.000
## 3:       The North 1107.667
## 4:  The Stormlands 3500.000
## 5:       The Reach      NaN
\end{verbatim}

Готово!

Давайте разберем этот пример подробнее:

\begin{itemize}
\tightlist
\item
  \texttt{i}: выбираем только те строки, где \texttt{attacker\_outcome}
  равен \texttt{"win"}. Заметьте, мы тут используем не вектор (как если
  бы это была переменная), а название колонки и без кавычек!
\item
  \texttt{j}: прямо в \texttt{j} считаем средний размер атакующей армии.
  Опять же - без кавычек используем название столбца.
\item
  \texttt{by}: группируем по региону. То есть как бы делим дататейбл на
  пять дататейблов и применяем функцию среднего для каждого.
\end{itemize}

В итоге мы получили новый дататейбл!

По умолчанию новому столбцу будет присваиваться название \texttt{V1} (а
если такая колонка есть, то \texttt{V2} и т.д.), но можно присвоить и
свое название колонки. Для этого используйте круглые скобки и точку
перед ними:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{batdt[attacker_outcome }\OperatorTok{==}\StringTok{ "win"}\NormalTok{, }
\NormalTok{      .(}\DataTypeTok{mean_attack =} \KeywordTok{mean}\NormalTok{(attacker_size, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)), }
\NormalTok{      by =}\StringTok{ }\NormalTok{region]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##             region mean_attack
## 1: The Westerlands    9000.000
## 2:  The Riverlands    4425.000
## 3:       The North    1107.667
## 4:  The Stormlands    3500.000
## 5:       The Reach         NaN
\end{verbatim}

\begin{quote}
.() - это то же самое, что и list(). То есть мы создаем список, а это
значит, что мы можем сделать сразу несколько операций:
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{batdt[attacker_outcome }\OperatorTok{==}\StringTok{ "win"}\NormalTok{, }
\NormalTok{      .(}\DataTypeTok{mean_attack =} \KeywordTok{mean}\NormalTok{(attacker_size, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{), }
        \DataTypeTok{max_attacker =} \KeywordTok{max}\NormalTok{(attacker_size, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)), }
\NormalTok{      by =}\StringTok{ }\NormalTok{region]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning in gmax(attacker_size, na.rm = TRUE): No non-missing values found in at
## least one group. Coercing to numeric type and returning 'Inf' for such groups to
## be consistent with base
\end{verbatim}

\begin{verbatim}
##             region mean_attack max_attacker
## 1: The Westerlands    9000.000        15000
## 2:  The Riverlands    4425.000        15000
## 3:       The North    1107.667         4500
## 4:  The Stormlands    3500.000         5000
## 5:       The Reach         NaN         -Inf
\end{verbatim}

Чтобы аггрегировать по двум условиям, нужно использовать конструкцию с
\texttt{.()} в \texttt{by}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{batdt[,.(}\DataTypeTok{mean_attack =} \KeywordTok{mean}\NormalTok{(attacker_size, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)), by =}\StringTok{ }\NormalTok{.(region, attacker_outcome)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##             region attacker_outcome mean_attack
## 1: The Westerlands              win    9000.000
## 2:  The Riverlands              win    4425.000
## 3:  The Riverlands             loss   19000.000
## 4:       The North              win    1107.667
## 5:  The Stormlands              win    3500.000
## 6:  The Crownlands             loss   12000.000
## 7: Beyond the Wall             loss  100000.000
## 8:       The Reach              win         NaN
## 9:       The North                     5000.000
\end{verbatim}

\subsubsection{Создание новых колонок}\label{new_col_dt}

В data.table есть специальный оператор \texttt{:=} для создания новых
колонок.

Давайте создадим новую колонку, по которой будет проще понять, кто
победил в битве:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{batdt[,outcome}\OperatorTok{:}\ErrorTok{=}\KeywordTok{ifelse}\NormalTok{(attacker_outcome }\OperatorTok{==}\StringTok{ "win"}\NormalTok{, }
                       \StringTok{"Победа атакующих"}\NormalTok{, }
                       \KeywordTok{ifelse}\NormalTok{(attacker_outcome }\OperatorTok{==}\StringTok{ "loss"}\NormalTok{, }
                              \StringTok{"Победа защищающихся"}\NormalTok{, }
                              \StringTok{"Исход неизвестен"}\NormalTok{))]}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Оператор \texttt{:=} создает поверхностную копию, т.е. не копирует
физически данные.
\end{quote}

Заметьте, мы даже не присваиваем результат выполнения этой операции
новой переменной: просто в нашем batdt появилась новая колонка.

\begin{quote}
Если мы хотим создать сразу несколько столбцов за раз, то можно
использовать оператор \texttt{:=} как функцию:
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{batdt[, }\StringTok{':='}\NormalTok{(}\DataTypeTok{all_army =}\NormalTok{ attacker_size }\OperatorTok{+}\StringTok{ }\NormalTok{defender_size, }
             \DataTypeTok{ratio_army =}\NormalTok{ attacker_size }\OperatorTok{/}\StringTok{ }\NormalTok{defender_size)]}
\end{Highlighting}
\end{Shaded}

\subsubsection{Chaining}\label{chaining}

\emph{Chaining} (формирование цепочки) - это что-то вроде альтернативы
пайпам. В принципе, это можно делать и с обычным датафреймом или
матрицей, но именно с data.table это становится удобным и клевым
инструментом. А также способом ``сделать весь анализ в одну очень
длинную строчку''. Все просто - результатом вычислений в data.table
обычно является новый data.table. И ничто не мешает нам делать несколько
квадратных скобочек, превращая код в паравозик со множеством вагонов.
Это позволяет избежать промежуточных присвоений переменных, как и в
случае с пайпами.

Давайте шаг за шагом создадим такой паровозик для того, чтобы сделать
таблицу частот битв по регионам.

Для начала нам нужно посчитать длину столбцов. Для этого в data.table
есть \texttt{.N}, и это гораздо удобнее, чем считать \texttt{length()}
какого-нибудь столбца:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{batdt[.N,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                   name year battle_number     attacker_king
## 1: Siege of Winterfell  300            38 Stannis Baratheon
##               defender_king attacker_1 attacker_2 attacker_3 attacker_4
## 1: Joffrey/Tommen Baratheon  Baratheon   Karstark    Mormont     Glover
##    defender_1 defender_2 defender_3 defender_4 attacker_outcome battle_type
## 1:     Bolton       Frey         NA         NA                             
##    major_death major_capture attacker_size defender_size attacker_commander
## 1:          NA            NA          5000          8000  Stannis Baratheon
##    defender_commander summer   location    region note          outcome
## 1:       Roose Bolton      0 Winterfell The North      Исход неизвестен
##    all_army ratio_army
## 1:    13000      0.625
\end{verbatim}

\begin{quote}
Заметьте, мы используем \texttt{.N} в j (т.е. после первой запятой).
Если мы используем \texttt{.N} в \texttt{i}, то получим просто последнюю
строчку дататейбла.
\end{quote}

Если же мы аггрегируем по регионам, то получим таблицу частот регионов -
что нам и нужно:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{batdt[,.N, by =}\StringTok{ }\NormalTok{region]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##             region  N
## 1: The Westerlands  3
## 2:  The Riverlands 17
## 3:       The North 10
## 4:  The Stormlands  3
## 5:  The Crownlands  2
## 6: Beyond the Wall  1
## 7:       The Reach  2
\end{verbatim}

Отличная альтернатива функции \texttt{table()}!

Можно было сохранить результат в новой переменной, а можно просто
продолжить работать с получившимся дататейблом, ``дописывая'' его.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{batdt[,.N, by =}\StringTok{ }\NormalTok{region][}\KeywordTok{order}\NormalTok{(}\OperatorTok{-}\NormalTok{N),]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##             region  N
## 1:  The Riverlands 17
## 2:       The North 10
## 3: The Westerlands  3
## 4:  The Stormlands  3
## 5:  The Crownlands  2
## 6:       The Reach  2
## 7: Beyond the Wall  1
\end{verbatim}

Теперь мы отсортировали регионы по количеству битв. Мы используем
функцию \texttt{order()}, чтобы посчитать ранг каждого значения нового
столбца \texttt{N}, а потом использовать значения этого столбца для
выбора строк в нужном порядке. Добавление минуса позволяет
``инвертировать'' этот порядок, чтобы получилось от большего к меньшему.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{batdt[,.N, by =}\StringTok{ }\NormalTok{region][}\KeywordTok{order}\NormalTok{(}\OperatorTok{-}\NormalTok{N),][N}\OperatorTok{>}\DecValTok{2}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##             region  N
## 1:  The Riverlands 17
## 2:       The North 10
## 3: The Westerlands  3
## 4:  The Stormlands  3
\end{verbatim}

Продолжая наш паровозик, мы ``отрезали'' от получившегося дататейбла
только те регионы, где \texttt{N} больше двух.

Для лучшей читаемости можно организовать цепочку таким образом:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{batdt[,.N, by =}\StringTok{ }\NormalTok{region}
\NormalTok{      ][}\KeywordTok{order}\NormalTok{(}\OperatorTok{-}\NormalTok{N),}
\NormalTok{        ][N}\OperatorTok{>}\DecValTok{2}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##             region  N
## 1:  The Riverlands 17
## 2:       The North 10
## 3: The Westerlands  3
## 4:  The Stormlands  3
\end{verbatim}

\subsection{Широкий и длинный форматы данных}\label{long_wide}

Что если есть несколько измерений по одному испытуемому? Например, вес
до и после прохождения курса. Как это лучше записать - как два числовых
столбца (один испытуемый - одна строка) или же создать отдельную
``группирующую'' колонку, в которой будет написано время измерения, а в
другой - измеренные значения (одно измерение - одна строка)? На самом
деле, оба варианта приемлимы, оба варианта возможны в реальных данных, а
разные функции и статистические пакеты могут требовать от вас как
``длинный'', так и ``широкий'' форматы.

\subsubsection{\texorpdfstring{``Широкий''
формат}{Широкий формат}}\label{wide_f}

\begin{longtable}[]{@{}lll@{}}
\toprule
Студент & До курса по R & После курса по R\tabularnewline
\midrule
\endhead
Маша & 70 & 63\tabularnewline
Рома & 80 & 74\tabularnewline
Антонина & 86 & 71\tabularnewline
\bottomrule
\end{longtable}

\subsubsection{\texorpdfstring{``Длинный''
формат}{Длинный формат}}\label{long_f}

\begin{longtable}[]{@{}lll@{}}
\toprule
Студент & Время измерения & Вес (кг)\tabularnewline
\midrule
\endhead
Маша & До курса по R & 70\tabularnewline
Рома & До курса по R & 80\tabularnewline
Антонина & До курса по R & 86\tabularnewline
Маша & После курса по R & 63\tabularnewline
Рома & После курса по R & 74\tabularnewline
Антонина & После курса по R & 71\tabularnewline
\bottomrule
\end{longtable}

\subsection{Решейпинг в data.table: melt() и dcast()}\label{melt_dcast}

Таким образом, нам нужно научиться переводить из широкого формата в
длинный и наоборот. Это может показаться довольно сложной задачей, но
для это в data.table есть специальные функции:

\begin{itemize}
\item
  \texttt{melt()} (= ``плавление''): из \emph{широкого} в \emph{длинный}
  формат
\item
  \texttt{dcast()}(= ``литье''): из \emph{длинного} в \emph{широкий}
  формат
\end{itemize}

\subsubsection{Пример 1: melt() для размера армий}\label{melt}

В нашем дататейбле \texttt{batdt} у нас есть две колонки, которые
содержат информацию про размер армий: \texttt{attacker\_size} и
\texttt{defender\_size}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(batdt[, .(name, year, attacker_size, defender_size)])}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                             name year attacker_size defender_size
## 1:    Battle of the Golden Tooth  298         15000          4000
## 2:   Battle at the Mummer's Ford  298            NA           120
## 3:            Battle of Riverrun  298         15000         10000
## 4:      Battle of the Green Fork  298         18000         20000
## 5: Battle of the Whispering Wood  298          1875          6000
## 6:           Battle of the Camps  298          6000         12625
\end{verbatim}

Это пример широкого формата: у нас два измерения на каждую битву.
Допустим, мы хотим сделать длинный формат. В новом дататейбле будет
``группирующая'' колонка \texttt{battle\_role}, а все размеры армий
будут в новой колонке \texttt{army\_size}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{batlong <-}\StringTok{ }\KeywordTok{melt}\NormalTok{(batdt, }
                \DataTypeTok{measure.vars =} \KeywordTok{c}\NormalTok{(}\StringTok{"attacker_size"}\NormalTok{, }\StringTok{"defender_size"}\NormalTok{),}
                \DataTypeTok{variable.name =} \StringTok{"battle_role"}\NormalTok{, }
                \DataTypeTok{value.name =} \StringTok{"army_size"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Теперь новый дататейбл batlong в два раза длиннее оригинального, а
названия колонок \texttt{attacker\_size} и \texttt{defender\_size}
превратились в значения колонки \texttt{battle\_role}.

Важные параметры функции \texttt{melt()}:

\begin{itemize}
\item
  \texttt{data} - Ваш data.table
\item
  \texttt{id.vars} - вектор имен id. Можно не ставить, если у нас
  ``чистый'' длинный формат.
\item
  \texttt{measure.vars} - вектор названий колонок (т.е. в кавычках!),
  которые содержат измерения \emph{Note:} \texttt{melt()} удалит в новом
  дататейбле все колонки, которые вы написали в \texttt{id.vars} и
  \texttt{measure.vars}.
\item
  \texttt{variable.name} - название новой ``группирующей'' колонки
\item
  \texttt{value.name} - название новой колонки с измерениями
\end{itemize}

\subsubsection{Пример 2: dcast() для размера армий}\label{dcast}

А теперь обратно к широкому формату!

Функция \texttt{dcast()} использует формулы. Это новый для нас тип
данных, но мы с ним еще столкнемся, когда перейдем к статистическим
тестам и моделям, поэтому давайте немного ознакомимся с ними.
Собственно, для задания статистических моделей формулы в R и существуют,
но иногда они используются и в других случаях.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class}\NormalTok{(y }\OperatorTok{~}\StringTok{ }\NormalTok{x1 }\OperatorTok{+}\StringTok{ }\NormalTok{x2 }\OperatorTok{*}\StringTok{ }\NormalTok{x3)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "formula"
\end{verbatim}

В формуле обязательно присутствует тильда (\texttt{\textasciitilde{}} -
в клавиатуре на кнопке ``ё''), которая разделяет левую и правую часть.

Давайте вернемся к \texttt{dcast()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{batwide <-}\StringTok{ }\KeywordTok{dcast}\NormalTok{(batlong,  }
\NormalTok{                 ... }\OperatorTok{~}\StringTok{ }\NormalTok{battle_role, }
                 \DataTypeTok{value.var =} \StringTok{"army_size"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Мы практически вернулись к исходному \texttt{batdt}, разве что колонки в
другой последовательности.

\subsection{Объединение с помощью rbind(), cbind() и
merge()}\label{join_merge}

Допустим, у нас есть два дататейбла. Мы создадим немного искусственную
ситуацию, разделив длинный дататейбл на два:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bat_at <-}\StringTok{ }\NormalTok{batlong[battle_role }\OperatorTok{==}\StringTok{ "attacker_size"}\NormalTok{,]}
\NormalTok{bat_def <-}\StringTok{ }\NormalTok{batlong[battle_role }\OperatorTok{==}\StringTok{ "defender_size"}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

Ну а теперь попробуем склеить их обратно!

Для этого есть три замечательные функции: \texttt{rbind()},
\texttt{cbind()} и \texttt{merge()}.

\begin{figure}
\centering
\includegraphics{images/R_rbind_cbind.png}
\caption{}
\end{figure}

С первымии двумя все просто. \texttt{rbind()} соединяет вертикально, а
\texttt{cbind()} - горизонтально.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{verylong_bat <-}\KeywordTok{cbind}\NormalTok{(bat_at, bat_def) }\CommentTok{#c stands for columns}
\end{Highlighting}
\end{Shaded}

\texttt{h\_bat} это результат вертикального соединения. По сути, мы
почти вернулись к \texttt{batlong}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{verywide_bat <-}\StringTok{ }\KeywordTok{rbind}\NormalTok{(bat_at, bat_def) }\CommentTok{#r stands for rows}
\end{Highlighting}
\end{Shaded}

А теперь мы сделали горизонтальное соединение, получив ооочень широкий
дататейбл с повторяющимися колонками.

Самое сложное (и самое интересное!) - это \texttt{merge()}.

На практике часто случается, что нужно объединить два датасета.
Например, поведенческие данные с какими-нибудь метриками ЭЭГ. Скажем,
время реакции на задачу и мощность альфа-ритма. Или, например, мы хотим
добавить в набор данных информацию о поле и возрасте, которая у нас
хранится в отдельной табличке. Все, что объединяет два датасета - это
\emph{id} испытуемых, по которым нужно составить новую табличку.

Другая проблема может возникнуть, когда мы сделали какой-то анализ с
данными, что-то аггрегировали, посчитали, а теперь это нужно вставить в
оригинальный датасет. Давайте решим такую задачу: создадим сабсет из
нашего \texttt{batdt}, в котором будут только битвы, которые проходили в
регионах, где было больше двух битв.

Первую часть этой задачи мы уже делали сегодня: считали частоты по
регионам, а потом оставляли только регионы с больше чем двумя битвами:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{batdt[,.N, by =}\StringTok{ }\NormalTok{region][}\KeywordTok{order}\NormalTok{(}\OperatorTok{-}\NormalTok{N),][N}\OperatorTok{>}\DecValTok{2}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##             region  N
## 1:  The Riverlands 17
## 2:       The North 10
## 3: The Westerlands  3
## 4:  The Stormlands  3
\end{verbatim}

Сохраним этот результат в переменную \texttt{hot\_regions}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hot_regions <-}\StringTok{ }\NormalTok{batdt[,.N, by =}\StringTok{ }\NormalTok{region][}\KeywordTok{order}\NormalTok{(}\OperatorTok{-}\NormalTok{N),][N}\OperatorTok{>}\DecValTok{2}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

Теперь воспользуемся \texttt{merge()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{subset_batdt <-}\StringTok{ }\KeywordTok{merge}\NormalTok{(hot_regions, batdt, }
      \DataTypeTok{by =} \StringTok{"region"}\NormalTok{, }
      \DataTypeTok{all.x =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{all.y =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Получилось! А теперь чуть подробнее, о том, что мы сделали.

Первые два аргумента в \texttt{merge()} - это дататейблы. \texttt{by\ =}
это тот самый айди, который должен совпадать у обоих дататейблов. Это
может быть не одна, а сразу несколько колонок. В качестве значения по
умолчанию используются все общие колонки двух дататейблов. Если названия
не совпадают, то их можно прописать в \texttt{by.x\ =} и
\texttt{by.y\ =} отдельно.

Следующие важные варианты - это \texttt{all.x\ =} и \texttt{all.y\ =}. С
помощью этих параметров мы прописываем, что нужно сделать, если список
айдишников (в нашем случае - регионов) не совпадает. Они могут принимать
значения \texttt{TRUE} и \texttt{FALSE}, в зависимости от этого есть 4
варианта:

\begin{itemize}
\tightlist
\item
  \texttt{all\ =\ T}: добавит новые строки, если в каком-то из
  дататейблов каких-то значений нет. Что-то вроде логического ``ИЛИ''
  для выбора строк: если хотя бы в одном дататейбле есть строки с
  каким-то айди, то они добавятся в получившийся дататейбл.\\
\item
  \texttt{all.x\ =\ T,\ all.y\ =\ F}: возьмет все строки из первого
  дататейбла, но проигнорирует все строки с айдишниками, которых нет во
  втором дататейбле.\\
\item
  \texttt{all.x\ =\ F,\ all.y\ =\ T}: возьмет все строки из второго
  дататейбла, но проигнорирует лишние строки из первого.\\
\item
  \texttt{all.x\ =\ F,\ all.y\ =\ F}: возьмет только строчки, айдишники
  которых пересекаются в обоих дататейблах.
\end{itemize}

Мы взяли именно второй вариант. Взяли все регионы из
\texttt{hot\_regions} и проигнорировали те регионы, что встречаются
только в \texttt{batdt}.

\section{Заключение}\label{day2_con}

Итак, мы научились делать самые сложные штуки в R (из тех, которые
жизненно необходимы вне зависимости от данных). Сабсетить данные,
агрегировать, вертеть их, соединять\ldots{} На самом деле, подобные вещи
отнимают большую часть времени, и они не раз нам понадобятся в будущем.
С другой стороны, какие-то сложные вещи, например, \texttt{melt()},
\texttt{dcast()} и \texttt{merge()} сложно запомнить сразу. И это
нормально, главное - понимать, в какую сторону гуглить и какие заметки
смотреть в случае необходимости.

\begin{quote}
Кстати говоря, для более глубокого погружения в data.table есть
замечательный
\href{https://bookdown.org/statist_/DataTableManual/01_data.table_intro.html}{туториал,
переведенный на русский язык}.
\end{quote}

\chapter{День 3. Описательная статистика и визуализация}\label{vis}

\section{Описательная статистика}\label{desc}

Статистика делится на \textbf{описательную статистику}
(\emph{descriptive statistics}) и \textbf{статистику вывода}
(\emph{inferential statistics}). Описательная статистика пытается
описать нашу \textbf{выборку} (\emph{sample}, т.е. те данные, что у нас
на руках) различными способами. Проблема в том, что описательная
статистика может описать только то, что у нас есть, но не позволяет
сделать выводы о \textbf{генеральной совокупности} (\emph{population}) -
это уже цель статистики вывода. Цель описательной статистики - ``ужать''
данные для их обобщенного понимания с помощью \emph{статистик}.

\begin{quote}
Заметьте, у выборки (\textbf{s}ample) мы считаем статистики
(\textbf{s}tatistics), а у генеральной совокупности
(\textbf{P}opulation) есть параметры (\textbf{P}arameters). Вот такая
вот мнемотехника.
\end{quote}

Статистики часто выступают в роли \emph{точечной оценки} (point
estimators) параметров, так что в этом легко запутаться. Например,
среднее (в выборке) - это оценка среднего (в генеральной совокупности).
Да, можно свихнуться. Мы это будем разбирать подробнее в следующие
занятия (это действительно важно, поверьте), пока что остановимся только
на описании выборки.

\begin{figure}
\centering
\includegraphics[width=4.16667in]{images/sample2.png}
\caption{}
\end{figure}

Сегодня мы будем работать с пакетом \texttt{survival}, в котором есть
датасет \texttt{pbc}. Мы его сразу превратим в \texttt{data.table}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(survival)}
\KeywordTok{library}\NormalTok{(data.table)}

\KeywordTok{data}\NormalTok{(pbc)}
\NormalTok{pbcdt <-}\StringTok{ }\KeywordTok{as.data.table}\NormalTok{(pbc)}
\end{Highlighting}
\end{Shaded}

Это данные 424 пациентов с первичным билиарным циррозом - редким
аутоимунным заболеванием печени. При поступлении в клинику у них
измерили разные медицинские показатели, определели в экспериментальную и
контрольную группу. В наборе данных есть информация о том, что стало с
этими испытуемыми.

\begin{quote}
``This data is from the Mayo Clinic trial in primary biliary cirrhosis
(PBC) of the liver conducted between 1974 and 1984. A total of 424 PBC
patients, referred to Mayo Clinic during that ten-year interval, met
eligibility criteria for the randomized placebo controlled trial of the
drug D-penicillamine. The first 312 cases in the data set participated
in the randomized trial and contain largely complete data.''
\end{quote}

Подробнее про датасет можно почитать
\href{https://stat.ethz.ch/R-manual/R-devel/RHOME/library/survival/html/pbc.html}{здесь}
или в \texttt{Help}.

Эти данные часто используются в качестве примера для анализа
выживаемости. Они уже в достаточно упорядоченном виде и не нуждаются в
предобработке (что, к сожалению, случай малореалистичный).

Для простоты мы удалим все пропущенные значения. Мы уже знакомы с
функцией \texttt{is.na()}, теперь познакомимся с еще одной функцией:
\texttt{complete.cases()} возвращает вектор, равный длине датафрейма, с
\texttt{FALSE} для строчек, где есть хотя бы один \texttt{NA}, и
\texttt{TRUE} если пропущенных значений нет.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pbcdt <-}\StringTok{ }\NormalTok{pbcdt[}\KeywordTok{complete.cases}\NormalTok{(pbc),]}
\end{Highlighting}
\end{Shaded}

Пока что мы будем использовать только данные о возрасте испытуемых. Для
краткости обозначим это вектором \texttt{a}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\NormalTok{pbcdt}\OperatorTok{$}\NormalTok{age}
\end{Highlighting}
\end{Shaded}

\subsection{Меры центральной тенденции}\label{cent_tend}

Мера центральной тенденции - это число для описания \emph{центра}
распределения.

\subsubsection{Арифметическое среднее}\label{mean}

Самая распространенная мера центральных тенденций -
\textbf{арифметическое среднее}, то самое, которые мы считаем с помощью
функции \texttt{mean()}.

\[\overline{x}= \frac{\sum\limits_{i=1}^{n} x_{i}} {n}\]

Не пугайтесь значка \[\sum\limits_{i=1}^{n}\] - это означает сумму от i
= 1 до n. Что-то вроде цикла \texttt{for}!

В качестве упражнения попробуйте самостоятельно превратить эту формулу в
функцию \texttt{mymean()} c помощью \texttt{sum()} и \texttt{length()}.
Можете убирать \texttt{NA} по дефолту! Сравните с результатом функции
\texttt{mean()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 49.79966
\end{verbatim}

\subsubsection{Медиана}\label{median}

\textbf{Медиана} - это \emph{середина} распределения. Представим, что мы
расставили значения по порядку (от меньшего к большему) и взяли значение
по середине. Если у нас четное количество значений, то берется среднее
значение между теми двумя, что по середине. Для расчета медианы есть
функция \texttt{median()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{median}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 49.70979
\end{verbatim}

Разница медианы со средним не очень существенная. Это значит, что
распределение довольно ``симметричное''. Но бывает и по-другому.

Представьте себе, что кто-то говорит про среднюю зарплату в Москве. Но
ведь эта средняя зарплата становится гораздо больше, если учитывать
относительно небольшое количество мультимиллионеров и миллиардеров! А
вот медианная зарплата будет гораздо меньше.

Представьте себе, что в эту клинику с циррозом печени пришел 8000-летний
Король Ночи из Игры Престолов. Тогда арифметическое среднее станет
гораздо больше:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(}\KeywordTok{c}\NormalTok{(a, }\DecValTok{8000}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 78.50075
\end{verbatim}

А вот медиана останется почти той же.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{median}\NormalTok{(}\KeywordTok{c}\NormalTok{(a, }\DecValTok{8000}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 49.76318
\end{verbatim}

Таким образом, экстремально большие или маленькие значения оказывают
сильное влияние на арифметическое среднее, но не на медиану. Поэтому
медиана считается более ``робастной'' оценкой, т.е. более устойчивой к
выбросам и крайним значениям.

\subsubsection{Усеченное среднее (trimmed mean)}\label{trim}

Если про среднее и медиану слышали все, то про усеченное (тримленное)
среднее известно гораздо меньше. Тем не менее, на практике это довольно
удобная штука, потому что представляет собой некий компромисс между
арифметическим средним и медианой.

В усеченном среднем значения ранжируются так же, как и для медианы, но
отбрасывается только какой-то процент крайних значений. Усеченное
среднее можно посчитать с помощью обычной функции mean(), поставив
нужное значение параметра \texttt{trim\ =}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(a, }\DataTypeTok{trim =} \FloatTok{0.1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 49.57392
\end{verbatim}

\texttt{trim\ =\ 0.1} означает, что мы отбросили 10\% слева и 10\%
справа. \texttt{trim} может принимать значения от 0 до 0.5. Что будет,
если \texttt{trim\ =\ 0}?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(a, }\DataTypeTok{trim =} \DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 49.79966
\end{verbatim}

Обычное арифметическое среднее! А если \texttt{trim\ =\ 0.5}?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(a, }\DataTypeTok{trim =} \FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 49.70979
\end{verbatim}

Медиана!

\subsubsection{Мода}\label{mode}

\textbf{Мода} \emph{(mode)} - это самое \emph{частое} значение. Обычно
используется для номинальных переменных. Например, можно посчитать моду
для регионов, в которых происходили битвы. Что интересно, в R нет
встроенной функции для подсчета моды. Обычно она и не нужна: мы можем
посчитать таблицу частот и даже проранжировать ее (и мы уже умеем это
делать разными способами). На случай если Вы все-таки хотите создать
свою функцию для моды, можно попробовать что-то такое:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mymode <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x)\{}\KeywordTok{names}\NormalTok{(}\KeywordTok{which.max}\NormalTok{(}\KeywordTok{table}\NormalTok{(x)))\}}
\KeywordTok{mymode}\NormalTok{(pbcdt}\OperatorTok{$}\NormalTok{sex)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "f"
\end{verbatim}

\subsection{Меры рассеяния}\label{vary}

\begin{quote}
Начинающий статистик пытался перейти в брод реку, средняя глубина
которой 1 метр. И утонул.\\
В чем была его ошибка? Он не учитывал разброс значений глубины!
\end{quote}

Мер центральной тенденции недостаточно, чтобы описать выборку.
Необходимо знать ее вариабельность.

\subsubsection{Размах
\{range\}}\label{ux440ux430ux437ux43cux430ux445-range}

Самое очевидное - посчитать \textbf{размах} \emph{(range)}, то есть
разницу между минимальным и максимальным значением. В R есть функция для
вывода максимального и минимального значений:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{range}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 26.27789 78.43943
\end{verbatim}

Осталось посчитать разницу между ними:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{diff}\NormalTok{(}\KeywordTok{range}\NormalTok{(a))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 52.16153
\end{verbatim}

Естественно, крайние значения очень сильно влияют на этот размах,
поэтому на практике он не очень-то используется.

\subsubsection{Дисперсия}\label{var}

\textbf{Дисперсия} \emph{(variance)} вычисляется по следующей формуле:

\[s^2= \frac{\sum\limits_{i=1}^{n} (x_{i} - \overline{x})^2} {n}\]

Попробуйте превратить это в функцию \texttt{myvar()}!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{myvar <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{mean}\NormalTok{((x }\OperatorTok{-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x))}\OperatorTok{^}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Естественно, в R уже есть готовая функция \texttt{var()}. Но, заметьте,
ее результат немного отличается от нашего:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{myvar}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 110.334
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{var}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 110.7353
\end{verbatim}

Дело в том, что встроенная функция \texttt{var()} делит не на \(n\), а
на \(n-1\). Это связано с тем, что эта функция пытается оценить
дисперсию в генеральной совокупности, т.е. относится уже к статистике
вывода. Про это мы будем говорить в дальнейших занятиях, сейчас нам
нужно только отметить то, что здесь есть небольшое различие.

\subsubsection{Стандартное отклонение}\label{sd}

Если вы заметили, значение дисперсии очень большое. Чтобы вернуться к
единицам измерения, соответствующих нашим данным используется корень из
дисперсии, то есть \textbf{стандартное отклонение} \emph{(standard
deviation)}:

\[s= \sqrt\frac{\sum\limits_{i=1}^{n} (x_{i} - \overline{x})^2} {n}\]

Для этого есть функция \texttt{sd()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sd}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 10.52308
\end{verbatim}

Что то же самое, что и:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sqrt}\NormalTok{(}\KeywordTok{var}\NormalTok{(a))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 10.52308
\end{verbatim}

\subsubsection{Медианное абсолютное отклонение}\label{mad}

Поскольку стандартное отклонение не устойчово ко всяким выбросам, то
иногда используют его альтернативу, которая устойчива к выбросам
(особенно если эти выбросы нам как раз и нужно удалить) - медианное
абсолютное отклонение (median absolute deviation):

\[mad= median(|x_{i} - median(x)|)\]

Для этого есть функция \texttt{mad()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mad}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 10.63291
\end{verbatim}

\subsubsection{Межквартильный размах}\label{iqr}

Другой вариант рабостной оценки вариабельности данных является
\textbf{межквартильный размах} \emph{(interquartile range, IQR)}. Это
разница между третьим и первым \textbf{квартилем} \footnote{Квартиль ---
  это частный пример квантиля. Другой известный квантиль --- процентиль.
  Процентили часто используют для сравнения значения с другими
  значениями. Например, 63ий процентиль означает, что данное значение
  больше 63\% значений в выборке.} - значением, которое больше 75\%
значений в выборке, и значением, которое больше 25\% значений в выборке.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{IQR}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 15.07187
\end{verbatim}

\begin{quote}
Ну а второй квартиль - это медиана!
\end{quote}

\subsection{Ассиметрия и эксцесс}\label{skku}

\subsubsection{Ассиметрия}\label{skew}

Ассиметрия (skewness) измеряет симметричность распределения.
Положительный показатель ассиметрии (``Right-skewed'' или positive
skewness) означает, что хвосты с правой части распределения длиннее.
Негативный показатель ассиметрии (``Left-skewed'' или negative skewness)
означает, что левый хвост длиннее.

\begin{figure}
\centering
\includegraphics{images/7180OS_01_180.jpg}
\caption{}
\end{figure}

\begin{quote}
Например, в психологии положительная ассиметрия встречается очень часто.
Например, время реакции: оно ограничено снизу 0 мс (а по факту не меньше
100 мс - быстрее сигнал не успеет по нервной системе пройти до пальцев),
а вот с другой стороны оно никак не ограничено. Испытуемый может на
полчаса перед монитором затупить, ага.
\end{quote}

\subsubsection{Эксцесс}\label{kurtosis}

\textbf{Эксцесс} \emph{(kurtosis)} - это мера ``вытянутости''
распределения:

\begin{figure}
\centering
\includegraphics{images/kurtosis.gif}
\caption{}
\end{figure}

Положительные показатели эксцесса означают ``вытянутое'' распределение,
а отрицательные - ``плоское''.

\subsubsection{Ассиметрия и эксцесс в R}\label{skewR}

К сожалению, в базовом R нет функций для ассиметрии и эксцесса. Зато
есть замечательный пакет \texttt{psych} (да-да, специально для
психологов).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"psych"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{"psych"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

В нем есть функции \texttt{skew()} и \texttt{kurtosi()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{skew}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.1786867
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{kurtosi}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -0.5174814
\end{verbatim}

Ассиметрия близка к нулю - значит распределение выборки достаточно
симметричное, а эксцесс немного ниже нуля - значит распределение
довольно ``плоское''.

\subsection{А теперь все вместе!}\label{summary}

В базовом R есть функция \texttt{summary()}, которая позволяет получить
сразу неплохой набор описательных статистик.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{summary}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##   26.28   41.51   49.71   49.80   56.58   78.44
\end{verbatim}

\begin{quote}
Функция summary() - это универсальная (generic) функция. Это означает,
что Вы можете ее применять для разных объектов и получать разные
результаты. Попробуйте применить ее к векторам с разными типами данных и
даже к дата.фреймам и дата.тейблам. Посмотрите, что получится.
\end{quote}

В пакете \texttt{psych} есть еще и замечательная функция
\texttt{describe()}, которая даст Вам еще больше статистик, включая
ассиметрию и куртозис:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{describe}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    vars   n mean    sd median trimmed   mad   min   max range skew kurtosis
## X1    1 276 49.8 10.52  49.71   49.57 10.63 26.28 78.44 52.16 0.18    -0.52
##      se
## X1 0.63
\end{verbatim}

Даже усеченное (trimmed) среднее есть (с \texttt{trim\ =\ 0.1})! Все
кроме \texttt{se} мы уже знаем. А про этот \texttt{se} узнаем через
позже.

Эта функция прекрасно работает в \texttt{data.table} в сочетании с
\texttt{by\ =}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pbcdt[, }\KeywordTok{describe}\NormalTok{(age), by =}\StringTok{ }\NormalTok{stage]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    stage vars   n     mean       sd   median  trimmed       mad      min
## 1:     4    1  94 53.09709 10.71781 53.92334 53.20437 10.890666 29.55510
## 2:     3    1 111 47.94154 10.00419 47.42779 47.41838  9.948946 26.27789
## 3:     2    1  59 48.52757 10.22616 48.75838 48.34855 10.975908 30.27515
## 4:     1    1  12 47.41182 10.11477 47.97673 47.75359 12.132762 28.88433
##         max    range        skew   kurtosis       se
## 1: 78.43943 48.88433 -0.07684694 -0.4361883 1.105458
## 2: 71.89322 45.61533  0.35465904 -0.3655477 0.949556
## 3: 75.01164 44.73648  0.19440406 -0.7000602 1.331333
## 4: 62.52156 33.63723 -0.06406915 -1.1025021 2.919883
\end{verbatim}

\subsection{Описательных статистик недостаточно}\label{datasaurus}

Я в тайне от Вас загрузил данные в переменную \texttt{xxx} (можете найти
этот набор данных
\href{https://raw.githubusercontent.com/Pozdniakov/stats/master/data/d.csv}{здесь},
если интересно). Выглядят они примерно так:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(xxx)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##          x       y
## 1: 55.3846 97.1795
## 2: 51.5385 96.0256
## 3: 46.1538 94.4872
## 4: 42.8205 91.4103
## 5: 40.7692 88.3333
## 6: 38.7179 84.8718
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(xxx)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Classes 'data.table' and 'data.frame':   142 obs. of  2 variables:
##  $ x: num  55.4 51.5 46.2 42.8 40.8 ...
##  $ y: num  97.2 96 94.5 91.4 88.3 ...
##  - attr(*, ".internal.selfref")=<externalptr>
\end{verbatim}

Надеюсь, Вы уже понимаете, как это интерпретировать - два столбца с 142
числами каждый. Представьте себе, как выглядят эти точки на плоскости,
если каждая строчка означают координаты одной точки по осям x и y (это
называется диаграмма рассеяния, точечная диаграмма или scatterplot).

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <9f>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <80>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b4>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <81>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b2>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <8c>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <be>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <87>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <ba>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b8>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b7>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b4>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <81>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <8c>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <9f>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <80>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b4>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <81>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b2>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <8c>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <be>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <87>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <ba>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b8>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b7>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b4>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <81>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <8c>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <9f>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <80>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b4>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <81>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b2>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <8c>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <be>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <87>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <ba>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b8>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b7>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b4>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <81>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <8c>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <9f>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <80>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b4>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <81>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b2>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <8c>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <be>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <87>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <ba>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b8>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b7>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b4>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <81>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <8c>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <9f>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <80>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b4>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <81>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b2>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <8c>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <be>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <87>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <ba>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b8>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b7>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b4>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <81>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <8c>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <9f>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <80>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b4>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <81>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b2>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <8c>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <be>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <87>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <ba>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b8>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b7>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b4>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <81>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <8c>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <9f>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <80>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b4>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <81>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b2>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <8c>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <be>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <87>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <ba>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b8>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b7>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b4>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <81>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на <8c>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <9f>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <80>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <b4>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <81>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <b2>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <8c>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <be>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <87>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <ba>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <b8>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <b7>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <b4>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <b5>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <81>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Представьте точки здесь:' в 'mbcsToSbcs': точка заменена на
## <8c>
\end{verbatim}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-198-1.pdf}

Применим разные функции, которые мы выучили:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(xxx}\OperatorTok{$}\NormalTok{x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 54.26327
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(xxx}\OperatorTok{$}\NormalTok{y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 47.83225
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{median}\NormalTok{(xxx}\OperatorTok{$}\NormalTok{x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 53.3333
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{median}\NormalTok{(xxx}\OperatorTok{$}\NormalTok{y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 46.0256
\end{verbatim}

Средние и медианы примерно одинаковые, при этом по х они около 53-54, а
по у - примерно 46-47. Попытайтесь представить это. Идем дальше:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sd}\NormalTok{(xxx}\OperatorTok{$}\NormalTok{x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 16.76514
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sd}\NormalTok{(xxx}\OperatorTok{$}\NormalTok{y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 26.9354
\end{verbatim}

Похоже, расброс по у несколько больше, верно?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{skew}\NormalTok{(xxx}\OperatorTok{$}\NormalTok{x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.2807568
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{skew}\NormalTok{(xxx}\OperatorTok{$}\NormalTok{y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0.2472603
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{kurtosi}\NormalTok{(xxx}\OperatorTok{$}\NormalTok{x)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -0.2854912
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{kurtosi}\NormalTok{(xxx}\OperatorTok{$}\NormalTok{y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -1.063552
\end{verbatim}

Похоже, оба распределения немного право-ассиметричны и довольно
``плоские''.

Давайте еще посчитаем корреляцию. Мы про нее будем говорить позже
гораздо подробнее. Пока что нам нужно знать, что она говорит о линейной
связи двух переменных. Если корреляция \emph{положительная} (максимум
равен \texttt{1}), то чем \emph{больше} х, тем \emph{больше} у. Если
\emph{отрицательная} (минимум равен \texttt{-1}), то чем \emph{больше}
х, тем \emph{меньше} у. Если же корреляция равна нулю, то такая линейная
зависимость отсутствует.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cor}\NormalTok{(xxx}\OperatorTok{$}\NormalTok{x, xxx}\OperatorTok{$}\NormalTok{y)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -0.06447185
\end{verbatim}

Корреляция очень близка к нулю (делайте выводы и представляйте).

Давайте напоследок воспользуемся функцией describe() из psych:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{describe}\NormalTok{(xxx)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   vars   n  mean    sd median trimmed   mad   min   max range skew kurtosis
## x    1 142 54.26 16.77  53.33   53.69 15.97 22.31 98.21 75.90 0.28    -0.29
## y    2 142 47.83 26.94  46.03   46.90 30.79  2.95 99.49 96.54 0.25    -1.06
##     se
## x 1.41
## y 2.26
\end{verbatim}

Готовы узнать, как выглядят эти данные на самом деле?!

 Жмите сюда если готовы!

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <ad>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <be>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <94>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b7>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b2>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <80>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <ad>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <be>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <94>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b7>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b2>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <80>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <ad>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <be>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <94>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b7>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b2>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <80>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <ad>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <be>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <94>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b7>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b2>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <80>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <ad>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <be>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <94>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b7>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b2>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <80>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <ad>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <be>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <94>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b7>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b2>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <80>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <ad>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <be>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <94>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b7>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b2>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y, : ошибка
## конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <80>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <ad>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <be>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <94>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <82>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b7>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d0>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <b2>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <d1>
\end{verbatim}

\begin{verbatim}
## Warning in grid.Call.graphics(C_text, as.graphicsAnnot(x$label), x$x, x$y, :
## ошибка конвертации 'Это Датазавр!' в 'mbcsToSbcs': точка заменена на <80>
\end{verbatim}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-204-1.pdf}

Из этого можно сделать важный вывод: не стоит слепо доверять
описательным статистикам. Нужно визуализировать данные, иначе можно
попасть в такую ситуацию в реальности. Все следующее занятие будет
посвящено визуализации данных.

\section{Визуализация данных в R}\label{vis_r}

\subsection{Базовые функции для графики}\label{base_vis}

В R есть достаточно мощный встроенный инструмент для визуализации. Я
приведу три простых примера. Во-первых, это та самая диаграмма
рассеяния. Здесь все просто: функция \texttt{plot()}, вектора \texttt{x}
и \texttt{у}, дополнительные параметры для цвета, размера, формы точек.

Для примера возьмем из дататейбла \texttt{pbcdt} уровень холистерина и
возраст:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{plot}\NormalTok{(pbcdt}\OperatorTok{$}\NormalTok{age, pbcdt}\OperatorTok{$}\NormalTok{chol)}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-205-1.pdf}

\begin{quote}
Между прочим, функция \texttt{plot()} - это тоже универсальная (generic)
функция, как и \texttt{summary()}. В качестве аргумента можете ей
скормить просто один вектор, матрицу, датафрейм. Более того, многие
пакеты добавляют новые методы plot() для новых объектов из этих пакетов.
\end{quote}

Другая распространенная функция - \texttt{hist()} - гистограмма:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{hist}\NormalTok{(pbcdt}\OperatorTok{$}\NormalTok{age)}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-206-1.pdf}

Ну и закончим на суперзвезде прошлого века под названием ``ящик с
усами''(boxplot with whiskers):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{boxplot}\NormalTok{(chol }\OperatorTok{~}\StringTok{ }\NormalTok{stage, pbcdt)}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-207-1.pdf}

Здесь мы использовали уже знакомый нам класс формул. Они еще будут нам
встречаться дальше, обычно они используются следующим образом: слева от
\texttt{\textasciitilde{}} находится зависимая переменная, а справа -
``предикторы''. Эта интуиция работает и здесь: мы хотим посмотреть, как
различается холестирин в зависимости от стадии.

\subsection{ggplot2}\label{ggplot2}

gg в \texttt{ggplot2} означает Grammar of Graphics - это книга Леланда
Уилкинсона, в которой он попытался создать язык описания и создания
всевозможных визуализаций. Хэдли Викхэм (уже знакомый нам по
\texttt{dplyr}) дополнил эту систему \emph{(Layered Grammar of
Graphics)} и реализовал в качестве пакета в R под названием
\texttt{ggplot2}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(ggplot2)}
\end{Highlighting}
\end{Shaded}

\subsubsection{Layered Grammar of
Graphics}\label{layered-grammar-of-graphics}

Основные элементы Layered Grammar of Graphics

\begin{itemize}
\tightlist
\item
  Layer (geom +)
\item
  Scale
\item
  Coordinate system (coord)
\item
  Faceting (facet)
\item
  Theme
\item
  Defaults

  \begin{itemize}
  \tightlist
  \item
    Data
  \item
    Mapping
  \end{itemize}
\end{itemize}

-Layer: - Data - Mapping (aes) - Statistical transformation (stat) -
Geometric object (geom) - Position adjustment (position)

\subsubsection{Пример 0: Круговая
диаграмма}\label{ux43fux440ux438ux43cux435ux440-0-ux43aux440ux443ux433ux43eux432ux430ux44f-ux434ux438ux430ux433ux440ux430ux43cux43cux430}

Чтобы продемонстрировать суть ``графической грамматики'' Уилкинсон в
своей книге приводит в качестве примера круговую диаграмму. Да-да, тот
самый злополучный пирог, которым все так плюются! Тем не менее, этот
пример перевернет Ваше понимание графиков с ног на голову.

Итак, создадим объект \texttt{ggplot} с данными и каким-нибудь мэппингом
по умолчанию (пока не обращайте внимания на него). Если мы попробуем это
отрисовать, то получим пустой экран.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pie <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ pbcdt, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =} \StringTok{""}\NormalTok{, }\DataTypeTok{fill =}\NormalTok{ sex))}
\NormalTok{pie}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-210-1.pdf}

Теперь мы добавим на картинку геом, который будет наследовать мэппинг и
набор данных, указанные в \texttt{ggplot()}. Этим геомом будет
\texttt{geom\_bar()}, для столбиковой диаграммы. Мы получаем немного
странный график:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pie <-}\StringTok{ }\NormalTok{pie }\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_bar}\NormalTok{(}\DataTypeTok{position =} \StringTok{"fill"}\NormalTok{)}
\NormalTok{pie}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-211-1.pdf}

Как нам из этого получить круговую диаграмму? Надо поменять декартову
систему координат на полярную (круговую)!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pie }\OperatorTok{+}\StringTok{ }\KeywordTok{coord_polar}\NormalTok{(}\DataTypeTok{theta =} \StringTok{"y"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-212-1.pdf}

В качестве финального штриха мы можем максимально упростить тему:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pie }\OperatorTok{+}\StringTok{ }\KeywordTok{coord_polar}\NormalTok{(}\DataTypeTok{theta =} \StringTok{"y"}\NormalTok{)}\OperatorTok{+}\KeywordTok{theme_void}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-213-1.pdf}

То есть пай-чарт можно рассматривать не как отдельный вид графика, а как
столбчатую диаграмму в полярной системе координат. То же верно и для
многих других графиков, которые можно представить с помощью
ограниченного количества геомов и других элементов грамматики графики.
Подумайте над этим!

\subsubsection{Пример 1: Диаграмма
рассеяния}\label{ux43fux440ux438ux43cux435ux440-1-ux434ux438ux430ux433ux440ux430ux43cux43cux430-ux440ux430ux441ux441ux435ux44fux43dux438ux44f}

Итак, давайте разбираться детально с синтаксисом \texttt{ggplot2}.

Для начала создадим объект ggplot с помощью \texttt{ggplot()} команды.
Для нее можно указать данные и мэппинг по умолчанию с помощью аргументов
\texttt{data\ =} и \texttt{mapping\ =\ aes()}

В качестве примера мы сделаем диаграмму рассеяния с возрастом по х и
уровнем холестирина по у:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ pbcdt, }\DataTypeTok{mapping =} \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ age, }\DataTypeTok{y =}\NormalTok{ chol))}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-214-1.pdf}

На самом деле, название параметров \texttt{data\ =} и
\texttt{mapping\ =} можно опустить.

Наш график пуст. Нам нужно сделать слой с нужной геометрией. В данном
случае - \texttt{geom\_point()}. Синтаксис \texttt{ggplot()} несколько
необычный - мы добавляем новые слои и дополнительные параметры с помощью
\texttt{+}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ pbcdt, }\DataTypeTok{mapping =} \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ age, }\DataTypeTok{y =}\NormalTok{ chol))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-215-1.pdf}

\paragraph{Фиксированные параметры vs mapping
aesthetics}\label{ux444ux438ux43aux441ux438ux440ux43eux432ux430ux43dux43dux44bux435-ux43fux430ux440ux430ux43cux435ux442ux440ux44b-vs-mapping-aesthetics}

Теперь нам хотелось бы как-то разнообразить график. Изменить цвет,
форму, размер точек:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ pbcdt, }\DataTypeTok{mapping =} \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ age, }\DataTypeTok{y =}\NormalTok{ chol))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size =} \DecValTok{3}\NormalTok{, }\DataTypeTok{colour =} \StringTok{"purple"}\NormalTok{, }\DataTypeTok{shape =} \DecValTok{15}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-216-1.pdf}

А что если мы хотим сделать параметры геома поставить в зависимость от
данных? Тогда нам нужно менять мэппинг с помощью эстетики -
\texttt{aes()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ pbcdt, }\DataTypeTok{mapping =} \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ age, }\DataTypeTok{y =}\NormalTok{ chol))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size =} \DecValTok{3}\NormalTok{,}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{colour =}\NormalTok{ sex, }\DataTypeTok{shape =} \KeywordTok{as.factor}\NormalTok{(hepato)))}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-217-1.pdf}

Если какой-то параметр зависит от данных, то он прописывается внутри
\texttt{aes()}, если же это фиксированное значение - то он находится
``извне'' функции \texttt{aes()} (параметра \texttt{mapping\ =}).

\begin{quote}
Здесь мы \texttt{hepato} (является печень увеличенной или нет)
превратили в фактор. Иначе \texttt{ggplot2} воспринимает эту колонку как
континуальную переменную, потому что она \texttt{numeric}.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ pbcdt, }\DataTypeTok{mapping =} \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ age, }\DataTypeTok{y =}\NormalTok{ chol))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size =} \DecValTok{2}\NormalTok{,}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{shape =} \KeywordTok{as.factor}\NormalTok{(hepato)))}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-218-1.pdf}

У использования цветов на графиков есть 3 основные функции:

\begin{itemize}
\item
  Для различения групп
\item
  Для кодирования информации
\item
  Для подчеркивания
\end{itemize}

Если на диаграмме рассеяния у нас есть и мэппинг формы, и мэппинг цвета,
то победа будет за цветом, причем обычно с большим перевесом. Разные
формы будут только отвлекать, поэтому и смысла в них особого не будет.
Впрочем, при достаточно большом количестве точек даже при одинаковом
цвете формы точек дадут какое-то представление только если эти точки
довольно сильно обособляются в отдельные паттерны.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ pbcdt, }\DataTypeTok{mapping =} \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ age, }\DataTypeTok{y =}\NormalTok{ chol))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size =} \DecValTok{2}\NormalTok{,}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{shape =} \KeywordTok{as.factor}\NormalTok{(hepato)))}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-219-1.pdf}

\paragraph{Overplotting и position}\label{overplotting-ux438-position}

На картинке мы видим много точек, которые перекрывают друг друга. Мы не
знаем, что стоит за точкой - возможно, под ней еще 10 таких же на той же
позиции. Это плохо.

Данная проблема получила название оверплоттинга (overplotting). Решить
ее можно разными способами.

Первый способ - добавить небольшой случайный шум (jitter). Это иногда
подходит в случае дискретных значений - точки за счет шума немного
``раздвигаются'' и создают пятна большего или меньшего размера. Для
зашумления можно использовать position adjustment:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ pbcdt, }\DataTypeTok{mapping =} \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ age, }\DataTypeTok{y =}\NormalTok{ chol))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size =} \DecValTok{2}\NormalTok{,}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{shape =} \KeywordTok{as.factor}\NormalTok{(hepato)), }\DataTypeTok{position =} \StringTok{"jitter"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-220-1.pdf}

То же самое можно сделать выбрав \texttt{geom\_jitter} -
\texttt{geom\_point} с \texttt{position\ =\ "jitter"} по умолчанию. Но
это нам не подходит - у нас значения не дискретные и никакой разницы не
видно. Поэтому мы решим проблему оверплоттинга с помощью использования
прозрачных точек. Для этого есть параметр \texttt{alpha\ =}, который при
0 дает полностью прозрачные точки, а при 1 - полностью непрозрачные
точки.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ pbcdt, }\DataTypeTok{mapping =} \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ age, }\DataTypeTok{y =}\NormalTok{ chol))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size =} \DecValTok{2}\NormalTok{,}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{shape =} \KeywordTok{as.factor}\NormalTok{(hepato)), }\DataTypeTok{alpha =} \FloatTok{0.4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-221-1.pdf}

\paragraph{Двумерные
гистограммы}\label{ux434ux432ux443ux43cux435ux440ux43dux44bux435-ux433ux438ux441ux442ux43eux433ux440ux430ux43cux43cux44b}

Другой способ избежать оверплоттинга - использование других геомов, в
которых можно кодировать плотность. Плотность здесь становится третьей
переменной: мы разделяем все пространство на прямоугольники или
шестиугольники, считаем сколько попало в каждый из них. Количество
попаданий мы можем кодировать цветом. У нас получится ``температурная
карта'' (heatmap) - там, где много точек, происходит что-то ``горячее'',
а там где их нет - что-то ``холодное''. Но на самом деле, это всего лишь
двумерная гистограмма.

\begin{quote}
В теории, мы могли бы сами агррегировать данные, использовать точки
определенного цвета и размера и отрисовать двумерные гистограммы как
точки или маленькие прямоугольники, просто в \texttt{ggplot2} есть
геомы, которые все это немного упрощают.
\end{quote}

Для этого в ggplot2 есть несколько геомов: \texttt{geom\_hex()},
\texttt{geom\_bin2d} и их ``трехмерные'' братья (если плотность уже
посчитана) - \texttt{geom\_raster()}, \texttt{geom\_tile()}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(pbcdt, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ age, }\DataTypeTok{y =}\NormalTok{ chol))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_hex}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{scale_fill_viridis_c}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-222-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(pbcdt, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ age, }\DataTypeTok{y =}\NormalTok{ chol))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_bin2d}\NormalTok{(}\DataTypeTok{binwidth =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{50}\NormalTok{))}\OperatorTok{+}
\StringTok{  }\KeywordTok{scale_fill_viridis_c}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-223-1.pdf}

Геом \texttt{geom\_density\_2d()} позволяет нарисовать контуры плотности
- довольно элегантный способ визуализировать пространственную динамику
плотности. Можно

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(pbcdt, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ age, }\DataTypeTok{y =}\NormalTok{ chol, }\DataTypeTok{colour =}\NormalTok{ sex))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_density_2d}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{alpha =} \FloatTok{0.4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-224-1.pdf}

Мы можем наложить два слоя с разными геомами друг на друга. Таким
образом можно создавать совершенно новые графики!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(pbcdt, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ age, }\DataTypeTok{y =}\NormalTok{ chol, }\DataTypeTok{colour =}\NormalTok{ sex, }\DataTypeTok{fill =}\NormalTok{ sex))}\OperatorTok{+}
\StringTok{   }\KeywordTok{stat_density_2d}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{alpha =}\NormalTok{ ..level..), }\DataTypeTok{geom =} \StringTok{"polygon"}\NormalTok{)}\OperatorTok{+}
\StringTok{   }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{alpha =} \FloatTok{0.4}\NormalTok{)}\OperatorTok{+}
\StringTok{   }\KeywordTok{scale_alpha_continuous}\NormalTok{(}\DataTypeTok{range =} \KeywordTok{c}\NormalTok{(}\FloatTok{0.01}\NormalTok{, }\FloatTok{0.2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-225-1.pdf}

\subsubsection{Пример 2: Столбиковая
диаграмма}\label{ux43fux440ux438ux43cux435ux440-2-ux441ux442ux43eux43bux431ux438ux43aux43eux432ux430ux44f-ux434ux438ux430ux433ux440ux430ux43cux43cux430}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(pbcdt)}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_bar}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ sex, }\DataTypeTok{fill =}\NormalTok{ sex))}\OperatorTok{+}
\StringTok{  }\KeywordTok{facet_grid}\NormalTok{(}\DataTypeTok{rows =} \KeywordTok{vars}\NormalTok{(stage), }\DataTypeTok{cols =} \KeywordTok{vars}\NormalTok{(hepato))}\OperatorTok{+}
\StringTok{  }\KeywordTok{coord_flip}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-226-1.pdf}

\subsubsection{Пример 3: Гистограмма и ящик с
усами}\label{ux43fux440ux438ux43cux435ux440-3-ux433ux438ux441ux442ux43eux433ux440ux430ux43cux43cux430-ux438-ux44fux449ux438ux43a-ux441-ux443ux441ux430ux43cux438}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(pbcdt, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ chol, }\DataTypeTok{fill =} \KeywordTok{as.factor}\NormalTok{(stage)))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_histogram}\NormalTok{(}\DataTypeTok{position =} \StringTok{"identity"}\NormalTok{)}\OperatorTok{+}
\StringTok{  }\KeywordTok{facet_grid}\NormalTok{(}\DataTypeTok{rows =} \KeywordTok{vars}\NormalTok{(stage))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
\end{verbatim}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-227-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(pbcdt, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ chol, }\DataTypeTok{fill =} \KeywordTok{as.factor}\NormalTok{(stage)))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_density}\NormalTok{(}\DataTypeTok{position =} \StringTok{"identity"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-228-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(pbcdt, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ chol, }\DataTypeTok{fill =} \KeywordTok{as.factor}\NormalTok{(stage)))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_density}\NormalTok{(}\DataTypeTok{position =} \StringTok{"identity"}\NormalTok{, }\DataTypeTok{alpha =} \FloatTok{0.4}\NormalTok{, }\DataTypeTok{adjust =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-229-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(pbcdt, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{as.factor}\NormalTok{(stage), }\DataTypeTok{y =}\NormalTok{ chol, }\DataTypeTok{fill =} \KeywordTok{as.factor}\NormalTok{(stage)))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_violin}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-230-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(pbcdt, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{as.factor}\NormalTok{(stage), }\DataTypeTok{y =}\NormalTok{ chol))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_boxplot}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-231-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(pbcdt, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{as.factor}\NormalTok{(stage), }\DataTypeTok{y =}\NormalTok{ chol))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_violin}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{fill =} \KeywordTok{as.factor}\NormalTok{(stage)))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_boxplot}\NormalTok{(}\DataTypeTok{width =} \FloatTok{0.1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-232-1.pdf}

\subsection{Дополнения к
ggplot2}\label{ux434ux43eux43fux43eux43bux43dux435ux43dux438ux44f-ux43a-ggplot2}

\texttt{ggplot2} стал настолько популярным пакетом, что существуют
сторонние пакеты, которые расширяют его функциональность. В некоторых
можно найти новые геомы, в некоторых - новые темы и палитры.
Ознакомиться с разнообразием расширений \texttt{ggplot2} можно
\href{http://www.ggplot2-exts.org/gallery/}{здесь}. Мы же остановимся на
одном из них - \texttt{cowplot}

\subsection{cowplot}\label{cowplot}

Для начала нужно установить \texttt{cowplot}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"cowplot"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

И подгрузить его:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(cowplot)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{g1 <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ pbcdt, }\DataTypeTok{mapping =} \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ age, }\DataTypeTok{y =}\NormalTok{ chol))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size =} \DecValTok{2}\NormalTok{,}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{colour =}\NormalTok{ sex), }\DataTypeTok{alpha =} \FloatTok{0.3}\NormalTok{)}

\NormalTok{g2 <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(pbcdt, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ age, }\DataTypeTok{y =}\NormalTok{ chol))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_hex}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{scale_fill_viridis_c}\NormalTok{()}

\NormalTok{g3 <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(pbcdt, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ age, }\DataTypeTok{y =}\NormalTok{ chol))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_hex}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{scale_fill_viridis_c}\NormalTok{()}

\NormalTok{g4 <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(pbcdt, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ age, }\DataTypeTok{y =}\NormalTok{ chol, }\DataTypeTok{colour =}\NormalTok{ sex))}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_density_2d}\NormalTok{()}\OperatorTok{+}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{alpha =} \FloatTok{0.1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{plot_grid}\NormalTok{(g1, g4,g2, g3, }\DataTypeTok{labels =}\NormalTok{ LETTERS[}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-236-1.pdf}

Если хотите вернуть стандартную тему \texttt{ggplot2}, то выполните
следующую команду:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theme_set}\NormalTok{(}\KeywordTok{theme_grey}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

\subsection{plotly}\label{plotly}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"plotly"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(plotly)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplotly}\NormalTok{(g1)}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidy_stats_files/figure-latex/unnamed-chunk-240-1.pdf}

\chapter{Задания}\label{tasks}

\section{Вектор}\label{vec_task_1}

\begin{itemize}
\tightlist
\item
  Посчитайте логарифм от 8912162342 по основанию 6
\end{itemize}

\begin{verbatim}
## [1] 12.7867
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Теперь натуральный логарифм 10 и умножьте его на 5
\end{itemize}

\begin{verbatim}
## [1] 11.51293
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор от 1 до 20
\end{itemize}

\begin{verbatim}
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор от 20 до 1
\end{itemize}

\begin{verbatim}
##  [1] 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор от 1 до 20 и снова до 1. Число 20 должно
  присутствовать только один раз!
\end{itemize}

\begin{verbatim}
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 19 18 17 16 15
## [26] 14 13 12 11 10  9  8  7  6  5  4  3  2  1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор 2, 4, 6, \ldots{} , 18, 20
\end{itemize}

\begin{verbatim}
##  [1]  2  4  6  8 10 12 14 16 18 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор из одной единицы, двух двоек, трех троек, \ldots{}. ,
  девяти девяток
\end{itemize}

\begin{verbatim}
##  [1] 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 6 6 6 6 6 6 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 9 9
## [39] 9 9 9 9 9 9 9
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Сделайте вектор vec, в котором соедините \texttt{3}, а также значения
  \texttt{"Мой"} и \texttt{"вектор"}.
\end{itemize}

\begin{verbatim}
## [1] "3"      "Мой"    "вектор"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Вычесть \texttt{TRUE} из 10
\end{itemize}

\begin{verbatim}
## [1] 9
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Соедините значение \texttt{10} и \texttt{TRUE} в вектор \texttt{vec}
\end{itemize}

\begin{verbatim}
## [1] 10  1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Соедините вектор \texttt{vec} и значение \texttt{"r"}:
\end{itemize}

\begin{verbatim}
## [1] "10" "1"  "r"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Соедините значения \texttt{10}, \texttt{TRUE}, \texttt{"r"} в вектор.
\end{itemize}

\begin{verbatim}
## [1] "10"   "TRUE" "r"
\end{verbatim}

\section{Вектор. Операции с векторами}\label{vec_op}

Создайте вектор \texttt{p}, состоящий из значений 4, 5, 6, 7, и вектор
\texttt{q}, состоящий из 0, 1, 2, 3.

\begin{verbatim}
## [1] 4 5 6 7
\end{verbatim}

\begin{verbatim}
## [1] 0 1 2 3
\end{verbatim}

Посчитайте поэлементную сумму векторов \texttt{p} и \texttt{q}:

\begin{verbatim}
## [1]  4  6  8 10
\end{verbatim}

Посчитайте поэлементную разницу \texttt{p} и \texttt{q}:

\begin{verbatim}
## [1] 4 4 4 4
\end{verbatim}

Поделите каждый элемент вектора \texttt{p} на соответствующий ему
элемент вектора \texttt{q}:

\begin{quote}
О, да, Вам нужно делить на 0!
\end{quote}

\begin{verbatim}
## [1]      Inf 5.000000 3.000000 2.333333
\end{verbatim}

Возведите каждый элемент вектора \texttt{p} в степень соответствующего
ему элемента вектора \texttt{q}:

\begin{verbatim}
## [1]   1   5  36 343
\end{verbatim}

Создайте вектор квадратов чисел от 1 до 10:

\begin{verbatim}
##  [1]   1   4   9  16  25  36  49  64  81 100
\end{verbatim}

Создайте вектор 0, 2, 0, 4, \ldots{} , 18, 0, 20

\begin{verbatim}
##  [1]  0  2  0  4  0  6  0  8  0 10  0 12  0 14  0 16  0 18  0 20
\end{verbatim}

\section{Вектор. Индексирование}\label{vec_task_2}

Создайте вектор \texttt{vec1}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec1 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Найдите второй элемент вектора \texttt{vec1}:
\end{itemize}

\begin{verbatim}
## [1] 5
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите последний элемент вектора \texttt{vec1}
\end{itemize}

\begin{verbatim}
## [1] 11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите все значения вектора \texttt{vec1}, которые больше 4
\end{itemize}

\begin{verbatim}
## [1]  5  8  9 10 15 11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите все значения вектора vec1, которые больше 4, но меньше 10
\end{itemize}

\begin{verbatim}
## [1] 5 8 9
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Возведите в квадрат каждое значение вектора \texttt{vec1}
\end{itemize}

\begin{verbatim}
##  [1]   9  25   4   1  64  16  81 100   9 225   1 121
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Возведите в квадрат каждое значение вектора на нечетной позиции и
  извлеките корень из каждого значения на четной позиции вектора
  \texttt{vec1}
\end{itemize}

\begin{verbatim}
##  [1]  9.000000  2.236068  4.000000  1.000000 64.000000  2.000000 81.000000
##  [8]  3.162278  9.000000  3.872983  1.000000  3.316625
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор \texttt{vec2}, в котором будут значения все значения
  \texttt{vec1}, которые меньше 10 будут заменены на \texttt{NA}.
\end{itemize}

\begin{verbatim}
##  [1] NA NA NA NA NA NA NA 10 NA 15 NA 11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте сумму \texttt{vec2} с помощью функции \texttt{sum()}. Ответ
  \texttt{NA} не считается!
\end{itemize}

\begin{verbatim}
## [1] 36
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор 2, 4, 6, \ldots{} , 18, 20 как минимум 2 новыми
  способами
\end{itemize}

\begin{quote}
Знаю, это задание может показаться бессмысленным, но это очень базовая
операция, с помощью которой можно, например, разделить данные на две
части. Чем больше способов Вы знаете, тем лучше!
\end{quote}

\begin{verbatim}
##  [1]  2  4  6  8 10 12 14 16 18 20
\end{verbatim}

\section{Матрицы}\label{t}

\begin{itemize}
\tightlist
\item
  Создайте матрицу 4х4, состоящую из единиц. Назовите ее \texttt{M}
\end{itemize}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    1    1    1
## [2,]    1    1    1    1
## [3,]    1    1    1    1
## [4,]    1    1    1    1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Поменяйте все некрайние значения матрицы \texttt{M} (то есть значения
  на позициях {[}2,2{]}, {[}2,3{]}, {[}3,2{]} и {[}3,3{]}) на число 2.
\end{itemize}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    1    1    1
## [2,]    1    2    2    1
## [3,]    1    2    2    1
## [4,]    1    1    1    1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Выделите второй и третий столбик из матрицы \texttt{M}
\end{itemize}

\begin{verbatim}
##      [,1] [,2]
## [1,]    1    1
## [2,]    2    2
## [3,]    2    2
## [4,]    1    1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Сравните (\texttt{==}) вторую колонку и вторую строчку матрицы
  \texttt{M}
\end{itemize}

\begin{verbatim}
## [1] TRUE TRUE TRUE TRUE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте таблицу умножения (9х9) в виде матрицы. Сохраните ее в
  переменную \texttt{tab}:
\end{itemize}

\begin{verbatim}
##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]
##  [1,]    1    2    3    4    5    6    7    8    9
##  [2,]    2    4    6    8   10   12   14   16   18
##  [3,]    3    6    9   12   15   18   21   24   27
##  [4,]    4    8   12   16   20   24   28   32   36
##  [5,]    5   10   15   20   25   30   35   40   45
##  [6,]    6   12   18   24   30   36   42   48   54
##  [7,]    7   14   21   28   35   42   49   56   63
##  [8,]    8   16   24   32   40   48   56   64   72
##  [9,]    9   18   27   36   45   54   63   72   81
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Из матрицы \texttt{tab} выделите подматрицу, включающую в себя только
  строчки с 6 по 8 и столбцы с 3 по 7.
\end{itemize}

\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5]
## [1,]   18   24   30   36   42
## [2,]   21   28   35   42   49
## [3,]   24   32   40   48   56
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте матрицу с логическими значениями, где \texttt{TRUE}, если в
  этом месте в таблице умножения (\texttt{tab}) двузначное число и
  \texttt{FALSE}, если однозначное.
\end{itemize}

\begin{quote}
Матрица - это почти вектор. К нему можно обращаться с единственным
индексом.
\end{quote}

\begin{verbatim}
##        [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9]
##  [1,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [2,] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [3,] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [4,] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [5,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [6,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [7,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [8,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [9,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте матрицу \texttt{tab2}, в которой все значения \texttt{tab}
  меньше 10 заменены на 0.
\end{itemize}

\begin{verbatim}
##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]
##  [1,]    0    0    0    0    0    0    0    0    0
##  [2,]    0    0    0    0   10   12   14   16   18
##  [3,]    0    0    0   12   15   18   21   24   27
##  [4,]    0    0   12   16   20   24   28   32   36
##  [5,]    0   10   15   20   25   30   35   40   45
##  [6,]    0   12   18   24   30   36   42   48   54
##  [7,]    0   14   21   28   35   42   49   56   63
##  [8,]    0   16   24   32   40   48   56   64   72
##  [9,]    0   18   27   36   45   54   63   72   81
\end{verbatim}

\section{Списки}\label{list_ta}

Дан список \texttt{list\_1}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list_}\DecValTok{1}\NormalTok{ =}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{numbers =} \DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{letters =}\NormalTok{ letters, }\DataTypeTok{logic =}\NormalTok{ T)}
\NormalTok{list_}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $numbers
## [1] 1 2 3 4 5
## 
## $letters
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
## [20] "t" "u" "v" "w" "x" "y" "z"
## 
## $logic
## [1] TRUE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите первый элемент списка. Ответ должен быть списком.
\end{itemize}

\begin{verbatim}
## $numbers
## [1] 1 2 3 4 5
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Теперь найдите содержание первого элемента списка двумя разными
  способами. Ответ должен быть вектором.
\end{itemize}

\begin{verbatim}
## [1] 1 2 3 4 5
\end{verbatim}

\begin{verbatim}
## [1] 1 2 3 4 5
\end{verbatim}

Теперь возьмите первый элемент содержания первого элемента списка. Ответ
должен быть вектором.

\begin{verbatim}
## [1] 1
\end{verbatim}

Создайте список \texttt{list\_2}, содержащий в себе два списка
\texttt{list\_1} с именами \texttt{pupa} и \texttt{lupa}.

\begin{verbatim}
## $pupa
## $pupa$numbers
## [1] 1 2 3 4 5
## 
## $pupa$letters
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
## [20] "t" "u" "v" "w" "x" "y" "z"
## 
## $pupa$logic
## [1] TRUE
## 
## 
## $lupa
## $lupa$numbers
## [1] 1 2 3 4 5
## 
## $lupa$letters
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
## [20] "t" "u" "v" "w" "x" "y" "z"
## 
## $lupa$logic
## [1] TRUE
\end{verbatim}

Извлеките первый элемент списка, из него - второй полэлемент, а из него
- третье значение

\begin{verbatim}
## [1] "c"
\end{verbatim}

\section{Датафрейм}\label{df_task}

\begin{itemize}
\tightlist
\item
  Кто является 274ым персонажем в \texttt{got} датафрейме? Из какого он
  дома?
\end{itemize}

\begin{verbatim}
##       Name Allegiances
## 274 Gendry        None
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите имена всех персонажей из дома (\texttt{Allegiances})
  \texttt{"Tyrell"} и \texttt{"House\ Tyrell"}.
\end{itemize}

\begin{verbatim}
##  [1] "Alerie Hightower"  "Alla Tyrell"       "Alyn Ambrose"     
##  [4] "Arryk (Guard)"     "Arwyn Oakheart"    "Bayard Norcross"  
##  [7] "Blue Bard"         "Butterbumps"       "Elinor Tyrell"    
## [10] "Erryk (Guard)"     "Garlan Tyrell"     "Hobber Redwyne"   
## [13] "Horas Redwyne"     "Janna Tyrell"      "Kerwin"           
## [16] "Leo Tyrell"        "Leonette Fossoway" "Loras Tyrell"     
## [19] "Mace Tyrell"       "Margaery Tyrell"   "Megga Tyrell"     
## [22] "Meredyth Crane"    "Olenna Redwyne"    "Paxter Redwyne"   
## [25] "Randyll Tarly"     "Talbert Serry"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте новый датафрейм \texttt{greyjoy\_women}, который будет
  включать в себя только женщин Грейджоев (\texttt{"Greyjoy"},
  \texttt{"House\ Greyjoy"})
\end{itemize}

\begin{verbatim}
##                    Name   Allegiances Death.Year Book.of.Death Death.Chapter
## 58         Asha Greyjoy House Greyjoy         NA            NA            NA
## 248       Falia Flowers       Greyjoy         NA            NA            NA
## 313    Gwin Goodbrother       Greyjoy         NA            NA            NA
## 319 Gysella Goodbrother       Greyjoy         NA            NA            NA
## 806         Three-Tooth       Greyjoy         NA            NA            NA
##     Book.Intro.Chapter Gender Nobility GoT CoK SoS FfC DwD Is.Alive  Houses
## 58                  11      0        1   0   1   0   1   1    Alive Greyjoy
## 248                 29      0        0   0   0   0   1   0    Alive Greyjoy
## 313                  1      0        1   0   0   0   1   0    Alive Greyjoy
## 319                  1      0        1   0   0   0   1   0    Alive Greyjoy
## 806                 11      0        0   0   0   0   1   0    Alive Greyjoy
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Сколько всего женских персонажей в книгах ``Песни льда и пламени''?
\end{itemize}

\begin{verbatim}
## [1] 157
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Сколько всего женских персонажей дворянского происхождения в книгах
  ``Песни льда и пламени''?
\end{itemize}

\begin{verbatim}
## [1] 84
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Поcчитатйе процентную (!) долю знати от общего числа персонажей
  (\texttt{Nobility}) в \texttt{Night\textquotesingle{}s\ Watch}.
\end{itemize}

\begin{verbatim}
## [1] 9.482759
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Поcчитатйе процентную (!) долю знати от общего числа персонажей
  (\texttt{Nobility}) у \texttt{Lannister}.
\end{itemize}

\begin{verbatim}
## [1] 71.60494
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Какая из книг цикла самая кровавая? Для ответа на этот вопрос
  подсчитайте таблицу частот для колонки \texttt{got\$Book.of.Death}:
\end{itemize}

\begin{quote}
Это можно сделать с помощью функции \texttt{table()}, но в дальнейшем Вы
узнаете и другие способы - подобная задача возникает достаточно часто.
\end{quote}

\begin{verbatim}
## 
##  1  2  3  4  5 
## 49 73 97 27 61
\end{verbatim}

\section{Создание функций}\label{task_function}

\begin{itemize}
\tightlist
\item
  Создайте функцию \texttt{plus\_one()}, которая принимает число и
  возвращает это же число + 1
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{plus_one}\NormalTok{(}\DecValTok{41}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 42
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте функцию \texttt{kvadrat()} возвращающее число в квадрате
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{kvadrat}\NormalTok{(}\DecValTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 36
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте функцию \texttt{century()}, которая превращает год в век.
  Возможно, понадобится вспомнить,
  \href{https://ru.wikipedia.org/wiki/Век}{как года переводятся в века}.
\end{itemize}

\begin{quote}
Здесь нужно немного погуглить.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{century}\NormalTok{(}\DecValTok{1999}\OperatorTok{:}\DecValTok{2002}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 20 20 21 21
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *А теперь сделайте функцию \texttt{century\_roman()}, которая
  переводит год в век, записанный римскими цифрами!
\end{itemize}

\begin{quote}
Здесь нужно просто немного погуглить - возможно, для создания римских
цифр есть уже готовая функция? Прежде созданные функции можно
использовать для создания новых функций!
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{century_roman}\NormalTok{(}\DecValTok{1999}\OperatorTok{:}\DecValTok{2002}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] XX  XX  XXI XXI
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Напишите функцию \texttt{is\_prime()}, которая проверяет, является ли
  число простым.
\end{itemize}

\begin{quote}
Здесь может понадобиться оператор для получения остатка от деления:
\texttt{\%\%}. Еще может пригодиться функция \texttt{any()} - она
возвращает \texttt{TRUE}, если в векторе есть хотя бы один \texttt{TRUE}
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_prime}\NormalTok{(}\DecValTok{2017}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_prime}\NormalTok{(}\DecValTok{2019}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2019}\OperatorTok{/}\DecValTok{3} \CommentTok{#2019 делится на 3 без остатка}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 673
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_prime}\NormalTok{(}\DecValTok{2020}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Создайте функцию \texttt{monotonic()}, которая принимает возвращает
  \texttt{TRUE}, если значения в векторе не убывают (то есть каждое
  следующее - больше или равно предыдущему) или не возврастают.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{monotonic}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{monotonic}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{,}\DecValTok{5}\OperatorTok{:}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{monotonic}\NormalTok{(}\DecValTok{6}\OperatorTok{:-}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{monotonic}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\KeywordTok{rep}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{10}\NormalTok{), }\DecValTok{5}\OperatorTok{:}\DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\section{Семейство apply()}\label{task_text}

\begin{itemize}
\tightlist
\item
  Посчитайте, в какой из 5 книг больше всего персонажей.
\end{itemize}

\begin{verbatim}
## GoT CoK SoS FfC DwD 
## 250 324 389 250 261
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Сделайте датафрейм \texttt{heroes} с персонажами, которые
  присутствовали во всех книгах.
\end{itemize}

\begin{verbatim}
##                 Name     Allegiances Death.Year Book.of.Death Death.Chapter
## 56        Arya Stark           Stark         NA            NA            NA
## 63       Balon Swann       Lannister         NA            NA            NA
## 104     Boros Blount       Baratheon         NA            NA            NA
## 131 Cersei Lannister House Lannister         NA            NA            NA
## 302            Grenn   Night's Watch         NA            NA            NA
## 345      Harys Swyft       Lannister         NA            NA            NA
## 383  Jaime Lannister       Lannister         NA            NA            NA
## 410         Jon Snow   Night's Watch         NA            NA            NA
## 436  Kevan Lannister House Lannister        300             5            NA
## 452 Lancel Lannister       Lannister         NA            NA            NA
## 548      Meryn Trant       Lannister         NA            NA            NA
## 652          Pycelle House Lannister        300             5            NA
## 741    Samwell Tarly   Night's Watch         NA            NA            NA
##     Book.Intro.Chapter Gender Nobility GoT CoK SoS FfC DwD Is.Alive
## 56                   2      0        1   1   1   1   1   1    Alive
## 63                  29      1        1   1   1   1   1   1    Alive
## 104                  8      1        1   1   1   1   1   1    Alive
## 131                  4      0        1   1   1   1   1   1    Alive
## 302                 19      1        0   1   1   1   1   1    Alive
## 345                 69      1        1   1   1   1   1   1    Alive
## 383                  5      1        1   1   1   1   1   1    Alive
## 410                  1      1        1   1   1   1   1   1    Alive
## 436                 56      1        1   1   1   1   1   1     Dead
## 452                 47      1        1   1   1   1   1   1    Alive
## 548                  8      1        1   1   1   1   1   1    Alive
## 652                 20      1        0   1   1   1   1   1     Dead
## 741                 70      1        1   1   1   1   1   1    Alive
##            Houses
## 56          Stark
## 63      Lannister
## 104     Baratheon
## 131     Lannister
## 302 Night's Watch
## 345     Lannister
## 383     Lannister
## 410 Night's Watch
## 436     Lannister
## 452     Lannister
## 548     Lannister
## 652     Lannister
## 741 Night's Watch
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте функцию \texttt{na\_n()}, которая будет возвращать количество
  \texttt{NA} в векторе.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{na_n}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\DecValTok{3}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\DecValTok{2}\NormalTok{, }\OtherTok{NA}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте количество NA в каждом столбце \texttt{got}.
\end{itemize}

\begin{verbatim}
##               Name        Allegiances         Death.Year      Book.of.Death 
##                  0                  0                612                610 
##      Death.Chapter Book.Intro.Chapter             Gender           Nobility 
##                618                 12                  0                  0 
##                GoT                CoK                SoS                FfC 
##                  0                  0                  0                  0 
##                DwD           Is.Alive             Houses 
##                  0                  0                  0
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Есть список \texttt{spisok}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{spisok <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DecValTok{0}\OperatorTok{:}\DecValTok{20}\NormalTok{, }\DecValTok{4}\OperatorTok{:}\DecValTok{24}\NormalTok{, }\DecValTok{6}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{6}\OperatorTok{:}\DecValTok{25}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Посчитайте сумму каждого вектора.
\end{itemize}

\begin{verbatim}
## [1]  15 210 294  18 310
\end{verbatim}

\begin{itemize}
\tightlist
\item
  А теперь длину.
\end{itemize}

\begin{verbatim}
## [1]  5 21 21  4 20
\end{verbatim}

\begin{itemize}
\item
  Напишите функцию \texttt{max\_item()}, которая будет принимать на
  входе список, а возвращать - (первый) самый длинный его элемент.
\item
  Теперь мы сделаем сложный список:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{large_spisok <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{3}\OperatorTok{:}\DecValTok{40}\NormalTok{, spisok)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Посчитайте длину каждого вектора в списке, в т.ч. для списка внутри
\end{itemize}

\begin{quote}
Для этого может понадобиться функция \texttt{rapply()}:
\textbf{recursive lapply}
\end{quote}

\begin{verbatim}
## [[1]]
## [1] 3
## 
## [[2]]
## [1] 38
## 
## [[3]]
## [[3]][[1]]
## [1] 5
## 
## [[3]][[2]]
## [1] 21
## 
## [[3]][[3]]
## [1] 21
## 
## [[3]][[4]]
## [1] 4
## 
## [[3]][[5]]
## [1] 20
\end{verbatim}

\section{Работа с текстом}\label{task_test}

Дан строковый вектор:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Я"}\NormalTok{, }\StringTok{"выучу"}\NormalTok{, }\StringTok{"R"}\NormalTok{, }\StringTok{"за"}\NormalTok{, }\StringTok{"май!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Соедините вектор в одно строковое значение \texttt{ch}
\end{itemize}

\begin{verbatim}
## [1] "Я выучу R за май!"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Подсчитайте количество знаков в \texttt{ch}
\end{itemize}

\begin{verbatim}
## [1] 17
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Следующее задание: вырезать Замая
\end{itemize}

\begin{verbatim}
## [1] "за май"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Превратите \texttt{ch} обратно в вектор, значения которого - отдельные
  слова:
\end{itemize}

\begin{verbatim}
## [1] "Я"     "выучу" "R"     "за"    "май!"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте дополнительную колонку в \texttt{got} под названием
  \texttt{info}, в которой будет написано: ``ИМЯ\_ПЕРСОНАЖА from House
  ЕГО\_ДОМ is dead/alive'' в зависимости от его статуса
\end{itemize}

\begin{verbatim}
## [1] "Addam Marbrand from House Lannister is Alive"   
## [2] "Aegon Frey (Jinglebell) from House None is Dead"
## [3] "Aegon Targaryen from House Targaryen is Alive"  
## [4] "Adrack Humble from House Greyjoy is Dead"       
## [5] "Aemon Costayne from House Lannister is Alive"   
## [6] "Aemon Estermont from House Baratheon is Alive"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте длину самого короткого имени в ``Песни льда и пламени''?
\end{itemize}

\begin{verbatim}
## [1] 3
\end{verbatim}

\begin{itemize}
\tightlist
\item
  На самом деле, функция \texttt{which.max()} выдает только индекс
  первого максимального значения, даже если их несколько. Это же верно
  для функции \texttt{which.min()}.
\end{itemize}

Напишите функцию \texttt{which.all.min()}, которая выдает индексы всех
минимальных значений векторов.

Проверьте, что эта функция работает на длине имен персонажей:

\begin{verbatim}
##     Name Allegiances Death.Year Book.of.Death Death.Chapter Book.Intro.Chapter
## 81   Ben        None         NA            NA            NA                 37
## 178  Del    Wildling        299             3            41                 41
## 352  Hod        None         NA            NA            NA                  5
## 459  Lem        None         NA            NA            NA                 13
## 467  Lew House Stark         NA            NA            NA                  7
## 590  Nan House Stark         NA            NA            NA                  1
## 602  Ogo        None        298             1            61                 46
## 640  Pia        None         NA            NA            NA                 30
## 653  Pyg        None        300             4            20                 20
## 734  Ryk    Wildling         NA            NA            NA                  7
## 850  Utt        None        299             3            39                 30
## 851  Val    Wildling         NA            NA            NA                  7
## 912  Zei       Stark         NA            NA            NA                 64
##     Gender Nobility GoT CoK SoS FfC DwD Is.Alive   Houses
## 81       1        0   0   0   0   1   0    Alive     None
## 178      1        0   0   0   1   0   0     Dead Wildling
## 352      1        0   0   1   0   0   0    Alive     None
## 459      1        0   0   0   1   1   0    Alive     None
## 467      1        0   1   0   0   0   0    Alive    Stark
## 590      0        0   1   1   0   0   0    Alive    Stark
## 602      1        1   1   0   0   0   0     Dead     None
## 640      0        0   0   1   0   1   0    Alive     None
## 653      1        0   0   0   1   1   0     Dead     None
## 734      1        0   0   0   1   0   0    Alive Wildling
## 850      1        0   0   1   1   0   0     Dead     None
## 851      0        0   0   0   1   0   1    Alive Wildling
## 912      0        0   0   0   1   0   0    Alive    Stark
##                                 info
## 81      Ben from House None is Alive
## 178  Del from House Wildling is Dead
## 352     Hod from House None is Alive
## 459     Lem from House None is Alive
## 467    Lew from House Stark is Alive
## 590    Nan from House Stark is Alive
## 602      Ogo from House None is Dead
## 640     Pia from House None is Alive
## 653      Pyg from House None is Dead
## 734 Ryk from House Wildling is Alive
## 850      Utt from House None is Dead
## 851 Val from House Wildling is Alive
## 912    Zei from House Stark is Alive
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте функцию \texttt{is\_anagram()}, которая будет выдавать
  \texttt{TRUE} если одно слово является анаграммой другого.
\end{itemize}

Проверьте, работает ли функция, на двух векторах:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"спаниель"}\NormalTok{, }\StringTok{"капюшон"}\NormalTok{, }\StringTok{"state"}\NormalTok{)}
\NormalTok{b <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"апельсин"}\NormalTok{, }\StringTok{"парашют"}\NormalTok{, }\StringTok{"taste"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Нужно либо векторизовать функцию (сделать так, чтобы она могла принимать
вектора на входе), либо использовать mapply(). Есть простой и хитрый
способ векторизовать функцию - Vectorize(). Постарайтесь все-таки не
использовать for, пожалуйста.
\end{quote}

\begin{verbatim}
## спаниель  капюшон    state 
##     TRUE    FALSE     TRUE
\end{verbatim}

\section{data.table}\label{dt_task}

Найдите все битвы, в которых \texttt{attacker\_king} -
\texttt{Robb\ Stark}.

\begin{verbatim}
##                              name year battle_number attacker_king
##  1:      Battle of the Green Fork  298             4    Robb Stark
##  2: Battle of the Whispering Wood  298             5    Robb Stark
##  3:           Battle of the Camps  298             6    Robb Stark
##  4:    Battle of Torrhen's Square  299            11    Robb Stark
##  5:             Battle of Oxcross  299            15    Robb Stark
##  6:             Sack of Harrenhal  299            18    Robb Stark
##  7:            Battle of the Crag  299            19    Robb Stark
##  8:                Siege of Darry  299            21    Robb Stark
##  9:          Battle of Duskendale  299            22    Robb Stark
## 10:              Siege of Seagard  299            27    Robb Stark
##                defender_king attacker_1 attacker_2 attacker_3 attacker_4
##  1: Joffrey/Tommen Baratheon      Stark                                 
##  2: Joffrey/Tommen Baratheon      Stark      Tully                      
##  3: Joffrey/Tommen Baratheon      Stark      Tully                      
##  4:      Balon/Euron Greyjoy      Stark                                 
##  5: Joffrey/Tommen Baratheon      Stark      Tully                      
##  6: Joffrey/Tommen Baratheon      Stark                                 
##  7: Joffrey/Tommen Baratheon      Stark                                 
##  8: Joffrey/Tommen Baratheon      Darry                                 
##  9: Joffrey/Tommen Baratheon      Stark                                 
## 10: Joffrey/Tommen Baratheon       Frey                                 
##     defender_1 defender_2 defender_3 defender_4 attacker_outcome    battle_type
##  1:  Lannister                    NA         NA             loss pitched battle
##  2:  Lannister                    NA         NA              win         ambush
##  3:  Lannister                    NA         NA              win         ambush
##  4:    Greyjoy                    NA         NA              win pitched battle
##  5:  Lannister                    NA         NA              win         ambush
##  6:  Lannister                    NA         NA              win         ambush
##  7:  Lannister                    NA         NA              win         ambush
##  8:  Lannister                    NA         NA              win          siege
##  9:  Lannister                    NA         NA             loss pitched battle
## 10:  Mallister                    NA         NA              win          siege
##     major_death major_capture attacker_size defender_size
##  1:           1             1         18000         20000
##  2:           1             1          1875          6000
##  3:           0             0          6000         12625
##  4:           0             0           244           900
##  5:           1             1          6000         10000
##  6:           1             0           100           100
##  7:           0             0          6000            NA
##  8:           0             0            NA            NA
##  9:           1             0          3000            NA
## 10:           0             1            NA            NA
##                                                                attacker_commander
##  1: Roose Bolton, Wylis Manderly, Medger Cerwyn, Harrion Karstark, Halys Hornwood
##  2:                                                     Robb Stark, Brynden Tully
##  3:                                    Robb Stark, Tytos Blackwood, Brynden Tully
##  4:                                                    Rodrik Cassel, Cley Cerwyn
##  5:                                                     Robb Stark, Brynden Tully
##  6:                                       Roose Bolton, Vargo Hoat, Robett Glover
##  7:                                 Robb Stark, Smalljon Umber, Black Walder Frey
##  8:                                                               Helman Tallhart
##  9:                                               Robertt Glover, Helman Tallhart
## 10:                                                                   Walder Frey
##                                                   defender_commander summer
##  1: Tywin Lannister, Gregor Clegane, Kevan Lannister, Addam Marbrand      1
##  2:                                                  Jaime Lannister      1
##  3:                                 Lord Andros Brax, Forley Prester      1
##  4:                                                  Dagmer Cleftjaw      1
##  5:               Stafford Lannister, Roland Crakehall, Antario Jast      1
##  6:                                                      Amory Lorch      1
##  7:                                                     Rolph Spicer      1
##  8:                                                                       1
##  9:                                    Randyll Tarly, Gregor Clegane      1
## 10:                                                  Jason Mallister      1
##             location          region
##  1:       Green Fork  The Riverlands
##  2:  Whispering Wood  The Riverlands
##  3:         Riverrun  The Riverlands
##  4: Torrhen's Square       The North
##  5:          Oxcross The Westerlands
##  6:        Harrenhal  The Riverlands
##  7:             Crag The Westerlands
##  8:            Darry  The Riverlands
##  9:       Duskendale  The Crownlands
## 10:          Seagard  The Riverlands
##                                                                                                                                                     note
##  1:                                                                                                                                                     
##  2:                                                                                                                                                     
##  3:                                                                                                                                                     
##  4: Greyjoy's troop number comes from the 264 estimate to have arrived on the stony shore minus the 20 Theon takes to attack Winterfell. Thus 264-20=244
##  5:                                                                                                                                                     
##  6:                                                                                                                                                     
##  7:                                                                                                                                                     
##  8:                                                                                                                                                     
##  9:                                                                                                                                                     
## 10:                                                                                                                                                     
##                 outcome all_army ratio_army
##  1: Победа защищающихся    38000  0.9000000
##  2:    Победа атакующих     7875  0.3125000
##  3:    Победа атакующих    18625  0.4752475
##  4:    Победа атакующих     1144  0.2711111
##  5:    Победа атакующих    16000  0.6000000
##  6:    Победа атакующих      200  1.0000000
##  7:    Победа атакующих       NA         NA
##  8:    Победа атакующих       NA         NA
##  9: Победа защищающихся       NA         NA
## 10:    Победа атакующих       NA         NA
\end{verbatim}

Как они заканчивались?

\begin{verbatim}
##    attacker_outcome N
## 1:             loss 2
## 2:              win 8
\end{verbatim}

Найдите, в битвах какого типа проигрывал \texttt{Robb\ Stark} как
атакующий король.

\begin{verbatim}
##    attacker_outcome    battle_type N
## 1:             loss pitched battle 2
## 2:              win         ambush 5
## 3:              win pitched battle 1
## 4:              win          siege 2
\end{verbatim}

\section{Решейпинг}\label{task_reshape}

\begin{itemize}
\tightlist
\item
  Допустим, у вас есть следующий \texttt{data.table}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iq <-}\StringTok{ }\KeywordTok{data.table}\NormalTok{(}\DataTypeTok{id =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{iq_before =} \KeywordTok{c}\NormalTok{(}\DecValTok{98}\NormalTok{, }\DecValTok{106}\NormalTok{, }\DecValTok{102}\NormalTok{), }\DataTypeTok{iq_after =} \KeywordTok{c}\NormalTok{(}\DecValTok{103}\NormalTok{, }\DecValTok{105}\NormalTok{, }\DecValTok{103}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Превратите широкий iq в длинный iq\_long с колонками \texttt{id},
  \texttt{time}, \texttt{IQ}
\end{itemize}

\begin{verbatim}
##    id      time  IQ
## 1:  1 iq_before  98
## 2:  2 iq_before 106
## 3:  3 iq_before 102
## 4:  1  iq_after 103
## 5:  2  iq_after 105
## 6:  3  iq_after 103
\end{verbatim}

\begin{itemize}
\tightlist
\item
  В колонке \texttt{time} должно быть значение \texttt{before} или
  \texttt{after}
\end{itemize}

\begin{verbatim}
##    id   time  IQ
## 1:  1 before  98
## 2:  2 before 106
## 3:  3 before 102
## 4:  1  after 103
## 5:  2  after 105
## 6:  3  after 103
\end{verbatim}

\begin{itemize}
\tightlist
\item
  А теперь обратно \texttt{iq\_long} в широкий формат:
\end{itemize}

\begin{verbatim}
##    id after before
## 1:  1   103     98
## 2:  2   105    106
## 3:  3   103    102
\end{verbatim}

\section{Описательная статистика}\label{task_desc}

\begin{itemize}
\item
  Вспомните все описательные статистики, которые мы прошли, и примените
  их на векторе \texttt{pbcdt\$chol} (количество холистерина).
  Попытайтесь представить, как будут распределены эти данные исходя из
  результатов.
\item
  Посчитайте описательные статистики
\item
  Создайте функцию \texttt{check\_outliers()}, которая принимает как
  аргумент числовой вектор, а возвращает логический вектор:
  \texttt{TRUE} - если есть значения больше или меньше чем 3 стандартных
  отклонения от среднего, \texttt{FALSE} в обратнос случае. Проверьте
  функцию на векторе \texttt{pbcdt\$chol}. Посчитайте количество
  \texttt{TRUE} в результате.
\end{itemize}

\begin{verbatim}
## [1] 8
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Измените функцию \texttt{check\_outliers()}, чтобы у нее появился
  параметр \texttt{n\ =} со значением 3 по умолчанию. От этого параметра
  должно зависеть количество стандартных отклонений от среднего в
  формуле. Проверьте функцию на том же векторе и \texttt{n\ =\ 2}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\KeywordTok{check_outliers}\NormalTok{(pbcdt}\OperatorTok{$}\NormalTok{chol, }\DataTypeTok{n =} \DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 13
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Добавим в функцию \texttt{check\_outliers()} еще больше гибкости.
  Теперь функция сможет принимать на вход еще и функции центральной
  тенденции и вариабельности \texttt{central\ =} и \texttt{deviation\ =}
  со средним и стандартным отклонением по умолчанию. Проверьте функцию с
  помощью \texttt{n\ =\ 3}, медианой и медианным абсолютным отклонением.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\KeywordTok{check_outliers}\NormalTok{(pbcdt}\OperatorTok{$}\NormalTok{chol, }\DataTypeTok{n =} \DecValTok{3}\NormalTok{, median, mad))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \[s^2_{pool} = \frac {(n_1-1)s^2_1 + (n_2-1)s^2_2} {(n_1 - 1) + (n_2 -1)}\]
\end{itemize}

\chapter{Решения\_заданий}\label{solutions}

\section{Вектор}\label{solvvec_task_1}

\begin{itemize}
\tightlist
\item
  Посчитайте логарифм от 8912162342 по основанию 6
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{log}\NormalTok{(}\DecValTok{8912162342}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 12.7867
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Теперь натуральный логарифм 10 и умножьте его на 5
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{log}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{*}\DecValTok{5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 11.51293
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор от 1 до 20
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\OperatorTok{:}\DecValTok{20}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор от 20 до 1
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{20}\OperatorTok{:}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор от 1 до 20 и снова до 1. Число 20 должно
  присутствовать только один раз!
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{20}\NormalTok{, }\DecValTok{19}\OperatorTok{:}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 19 18 17 16 15
## [26] 14 13 12 11 10  9  8  7  6  5  4  3  2  1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор 2, 4, 6, \ldots{} , 18, 20
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{20}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  2  4  6  8 10 12 14 16 18 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор из одной единицы, двух двоек, трех троек, \ldots{}. ,
  девяти девяток
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{9}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{9}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 6 6 6 6 6 6 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 9 9
## [39] 9 9 9 9 9 9 9
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Сделайте вектор vec, в котором соедините \texttt{3}, а также значения
  \texttt{"Мой"} и \texttt{"вектор"}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\StringTok{"Мой"}\NormalTok{, }\StringTok{"вектор"}\NormalTok{)}
\NormalTok{vec}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "3"      "Мой"    "вектор"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Вычесть \texttt{TRUE} из 10
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{10} \OperatorTok{-}\StringTok{ }\OtherTok{TRUE}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 9
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Соедините значение \texttt{10} и \texttt{TRUE} в вектор \texttt{vec}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\OtherTok{TRUE}\NormalTok{)}
\NormalTok{vec}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 10  1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Соедините вектор \texttt{vec} и значение \texttt{"r"}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(vec, }\StringTok{"r"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "10" "1"  "r"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Соедините значения \texttt{10}, \texttt{TRUE}, \texttt{"r"} в вектор.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\StringTok{"r"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "10"   "TRUE" "r"
\end{verbatim}

\section{Вектор. Операции с векторами}\label{solvvec_op}

Создайте вектор \texttt{p}, состоящий из значений 4, 5, 6, 7, и вектор
\texttt{q}, состоящий из 0, 1, 2, 3.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p <-}\StringTok{ }\DecValTok{4}\OperatorTok{:}\DecValTok{7}
\NormalTok{p}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4 5 6 7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{q <-}\StringTok{ }\DecValTok{0}\OperatorTok{:}\DecValTok{3}
\NormalTok{q}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 0 1 2 3
\end{verbatim}

Посчитайте поэлементную сумму векторов \texttt{p} и \texttt{q}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OperatorTok{+}\StringTok{ }\NormalTok{q}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  4  6  8 10
\end{verbatim}

Посчитайте поэлементную разницу \texttt{p} и \texttt{q}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p }\OperatorTok{-}\StringTok{ }\NormalTok{q}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4 4 4 4
\end{verbatim}

Поделите каждый элемент вектора \texttt{p} на соответствующий ему
элемент вектора \texttt{q}:

\begin{quote}
О, да, Вам нужно делить на 0!
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p}\OperatorTok{/}\NormalTok{q}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]      Inf 5.000000 3.000000 2.333333
\end{verbatim}

Возведите каждый элемент вектора \texttt{p} в степень соответствующего
ему элемента вектора \texttt{q}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p}\OperatorTok{^}\NormalTok{q}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]   1   5  36 343
\end{verbatim}

Создайте вектор квадратов чисел от 1 до 10:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}\OperatorTok{^}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]   1   4   9  16  25  36  49  64  81 100
\end{verbatim}

Создайте вектор 0, 2, 0, 4, \ldots{} , 18, 0, 20

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1}\OperatorTok{:}\DecValTok{20} \OperatorTok{*}\StringTok{ }\DecValTok{0}\OperatorTok{:}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  0  2  0  4  0  6  0  8  0 10  0 12  0 14  0 16  0 18  0 20
\end{verbatim}

\section{Вектор. Индексирование}\label{solvvec_task_2}

Создайте вектор \texttt{vec1}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec1 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{9}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{11}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Найдите второй элемент вектора \texttt{vec1}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec1[}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите последний элемент вектора \texttt{vec1}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec1[}\KeywordTok{length}\NormalTok{(vec1)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите все значения вектора \texttt{vec1}, которые больше 4
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec1[vec1}\OperatorTok{>}\DecValTok{4}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  5  8  9 10 15 11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите все значения вектора vec1, которые больше 4, но меньше 10
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec1[vec1}\OperatorTok{>}\DecValTok{4} \OperatorTok{&}\StringTok{ }\NormalTok{vec1}\OperatorTok{<}\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5 8 9
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Возведите в квадрат каждое значение вектора \texttt{vec1}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec1}\OperatorTok{^}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]   9  25   4   1  64  16  81 100   9 225   1 121
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Возведите в квадрат каждое значение вектора на нечетной позиции и
  извлеките корень из каждого значения на четной позиции вектора
  \texttt{vec1}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec1 }\OperatorTok{^}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  9.000000  2.236068  4.000000  1.000000 64.000000  2.000000 81.000000
##  [8]  3.162278  9.000000  3.872983  1.000000  3.316625
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор \texttt{vec2}, в котором будут значения все значения
  \texttt{vec1}, которые меньше 10 будут заменены на \texttt{NA}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec2 <-}\StringTok{ }\NormalTok{vec1}
\NormalTok{vec2[vec2}\OperatorTok{<}\DecValTok{10}\NormalTok{] <-}\StringTok{ }\OtherTok{NA}
\NormalTok{vec2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] NA NA NA NA NA NA NA 10 NA 15 NA 11
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте сумму \texttt{vec2} с помощью функции \texttt{sum()}. Ответ
  \texttt{NA} не считается!
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(vec2, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 36
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте вектор 2, 4, 6, \ldots{} , 18, 20 как минимум 2 новыми
  способами
\end{itemize}

\begin{quote}
Знаю, это задание может показаться бессмысленным, но это очень базовая
операция, с помощью которой можно, например, разделить данные на две
части. Чем больше способов Вы знаете, тем лучше!
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{20}\NormalTok{)[}\KeywordTok{c}\NormalTok{(F,T)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1]  2  4  6  8 10 12 14 16 18 20
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#(1:10)*2}
\end{Highlighting}
\end{Shaded}

\section{Матрицы}\label{solvt}

\begin{itemize}
\tightlist
\item
  Создайте матрицу 4х4, состоящую из единиц. Назовите ее \texttt{M}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{16}\NormalTok{), }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}
\NormalTok{M}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    1    1    1
## [2,]    1    1    1    1
## [3,]    1    1    1    1
## [4,]    1    1    1    1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Поменяйте все некрайние значения матрицы \texttt{M} (то есть значения
  на позициях {[}2,2{]}, {[}2,3{]}, {[}3,2{]} и {[}3,3{]}) на число 2.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M[}\DecValTok{2}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{2}\OperatorTok{:}\DecValTok{3}\NormalTok{] <-}\StringTok{ }\DecValTok{2}
\NormalTok{M}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4]
## [1,]    1    1    1    1
## [2,]    1    2    2    1
## [3,]    1    2    2    1
## [4,]    1    1    1    1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Выделите второй и третий столбик из матрицы \texttt{M}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M[,}\DecValTok{2}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2]
## [1,]    1    1
## [2,]    2    2
## [3,]    2    2
## [4,]    1    1
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Сравните (\texttt{==}) вторую колонку и вторую строчку матрицы
  \texttt{M}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{M[,}\DecValTok{2}\NormalTok{] }\OperatorTok{==}\StringTok{ }\NormalTok{M[}\DecValTok{2}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE TRUE TRUE TRUE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте таблицу умножения (9х9) в виде матрицы. Сохраните ее в
  переменную \texttt{tab}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{9}\NormalTok{, }\KeywordTok{rep}\NormalTok{(}\DecValTok{9}\NormalTok{,}\DecValTok{9}\NormalTok{))}\OperatorTok{*}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{9}\NormalTok{), }\DataTypeTok{nrow =} \DecValTok{9}\NormalTok{)}
\NormalTok{tab}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]
##  [1,]    1    2    3    4    5    6    7    8    9
##  [2,]    2    4    6    8   10   12   14   16   18
##  [3,]    3    6    9   12   15   18   21   24   27
##  [4,]    4    8   12   16   20   24   28   32   36
##  [5,]    5   10   15   20   25   30   35   40   45
##  [6,]    6   12   18   24   30   36   42   48   54
##  [7,]    7   14   21   28   35   42   49   56   63
##  [8,]    8   16   24   32   40   48   56   64   72
##  [9,]    9   18   27   36   45   54   63   72   81
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#Еще}
\CommentTok{#outer(1:9, 1:9, "*")}
\CommentTok{#1:9 %o% 1:9}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Из матрицы \texttt{tab} выделите подматрицу, включающую в себя только
  строчки с 6 по 8 и столбцы с 3 по 7.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab[}\DecValTok{6}\OperatorTok{:}\DecValTok{8}\NormalTok{, }\DecValTok{3}\OperatorTok{:}\DecValTok{7}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5]
## [1,]   18   24   30   36   42
## [2,]   21   28   35   42   49
## [3,]   24   32   40   48   56
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте матрицу с логическими значениями, где \texttt{TRUE}, если в
  этом месте в таблице умножения (\texttt{tab}) двузначное число и
  \texttt{FALSE}, если однозначное.
\end{itemize}

\begin{quote}
Матрица - это почти вектор. К нему можно обращаться с единственным
индексом.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab}\OperatorTok{>=}\DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9]
##  [1,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [2,] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [3,] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [4,] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [5,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [6,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [7,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [8,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [9,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте матрицу \texttt{tab2}, в которой все значения \texttt{tab}
  меньше 10 заменены на 0.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tab2 <-}\StringTok{ }\NormalTok{tab}
\NormalTok{tab2[tab}\OperatorTok{<}\DecValTok{10}\NormalTok{] <-}\StringTok{ }\DecValTok{0}
\NormalTok{tab2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]
##  [1,]    0    0    0    0    0    0    0    0    0
##  [2,]    0    0    0    0   10   12   14   16   18
##  [3,]    0    0    0   12   15   18   21   24   27
##  [4,]    0    0   12   16   20   24   28   32   36
##  [5,]    0   10   15   20   25   30   35   40   45
##  [6,]    0   12   18   24   30   36   42   48   54
##  [7,]    0   14   21   28   35   42   49   56   63
##  [8,]    0   16   24   32   40   48   56   64   72
##  [9,]    0   18   27   36   45   54   63   72   81
\end{verbatim}

\section{Списки}\label{solvlist_ta}

Дан список \texttt{list\_1}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list_}\DecValTok{1}\NormalTok{ =}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{numbers =} \DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{letters =}\NormalTok{ letters, }\DataTypeTok{logic =}\NormalTok{ T)}
\NormalTok{list_}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $numbers
## [1] 1 2 3 4 5
## 
## $letters
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
## [20] "t" "u" "v" "w" "x" "y" "z"
## 
## $logic
## [1] TRUE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите первый элемент списка. Ответ должен быть списком.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list_}\DecValTok{1}\NormalTok{[}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $numbers
## [1] 1 2 3 4 5
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Теперь найдите содержание первого элемента списка двумя разными
  способами. Ответ должен быть вектором.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list_}\DecValTok{1}\NormalTok{[[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3 4 5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list_}\DecValTok{1}\OperatorTok{$}\NormalTok{numbers}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1 2 3 4 5
\end{verbatim}

Теперь возьмите первый элемент содержания первого элемента списка. Ответ
должен быть вектором.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list_}\DecValTok{1}\NormalTok{[[}\DecValTok{1}\NormalTok{]][}\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 1
\end{verbatim}

Создайте список \texttt{list\_2}, содержащий в себе два списка
\texttt{list\_1} с именами \texttt{pupa} и \texttt{lupa}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list_}\DecValTok{2}\NormalTok{ =}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{pupa =}\NormalTok{ list_}\DecValTok{1}\NormalTok{, }\DataTypeTok{lupa =}\NormalTok{ list_}\DecValTok{1}\NormalTok{)}
\NormalTok{list_}\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## $pupa
## $pupa$numbers
## [1] 1 2 3 4 5
## 
## $pupa$letters
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
## [20] "t" "u" "v" "w" "x" "y" "z"
## 
## $pupa$logic
## [1] TRUE
## 
## 
## $lupa
## $lupa$numbers
## [1] 1 2 3 4 5
## 
## $lupa$letters
##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
## [20] "t" "u" "v" "w" "x" "y" "z"
## 
## $lupa$logic
## [1] TRUE
\end{verbatim}

Извлеките первый элемент списка, из него - второй полэлемент, а из него
- третье значение

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{list_}\DecValTok{2}\NormalTok{[[}\DecValTok{1}\NormalTok{]][[}\DecValTok{2}\NormalTok{]][}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "c"
\end{verbatim}

\section{Датафрейм}\label{solvdf_task}

\begin{itemize}
\tightlist
\item
  Кто является 274ым персонажем в \texttt{got} датафрейме? Из какого он
  дома?
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got[}\DecValTok{274}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##       Name Allegiances
## 274 Gendry        None
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Найдите имена всех персонажей из дома (\texttt{Allegiances})
  \texttt{"Tyrell"} и \texttt{"House\ Tyrell"}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got[got}\OperatorTok{$}\NormalTok{Allegiances }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Tyrell"}\NormalTok{, }\StringTok{"House Tyrell"}\NormalTok{), }\StringTok{"Name"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Alerie Hightower"  "Alla Tyrell"       "Alyn Ambrose"     
##  [4] "Arryk (Guard)"     "Arwyn Oakheart"    "Bayard Norcross"  
##  [7] "Blue Bard"         "Butterbumps"       "Elinor Tyrell"    
## [10] "Erryk (Guard)"     "Garlan Tyrell"     "Hobber Redwyne"   
## [13] "Horas Redwyne"     "Janna Tyrell"      "Kerwin"           
## [16] "Leo Tyrell"        "Leonette Fossoway" "Loras Tyrell"     
## [19] "Mace Tyrell"       "Margaery Tyrell"   "Megga Tyrell"     
## [22] "Meredyth Crane"    "Olenna Redwyne"    "Paxter Redwyne"   
## [25] "Randyll Tarly"     "Talbert Serry"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте новый датафрейм \texttt{greyjoy\_women}, который будет
  включать в себя только женщин Грейджоев (\texttt{"Greyjoy"},
  \texttt{"House\ Greyjoy"})
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{greyjoy_women <-}\StringTok{ }\NormalTok{got[got}\OperatorTok{$}\NormalTok{Allegiances }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Greyjoy"}\NormalTok{, }\StringTok{"House Greyjoy"}\NormalTok{) }\OperatorTok{&}\StringTok{ }\NormalTok{got}\OperatorTok{$}\NormalTok{Gender }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{, ]}
\NormalTok{greyjoy_women}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                    Name   Allegiances Death.Year Book.of.Death Death.Chapter
## 58         Asha Greyjoy House Greyjoy         NA            NA            NA
## 248       Falia Flowers       Greyjoy         NA            NA            NA
## 313    Gwin Goodbrother       Greyjoy         NA            NA            NA
## 319 Gysella Goodbrother       Greyjoy         NA            NA            NA
## 806         Three-Tooth       Greyjoy         NA            NA            NA
##     Book.Intro.Chapter Gender Nobility GoT CoK SoS FfC DwD Is.Alive  Houses
## 58                  11      0        1   0   1   0   1   1    Alive Greyjoy
## 248                 29      0        0   0   0   0   1   0    Alive Greyjoy
## 313                  1      0        1   0   0   0   1   0    Alive Greyjoy
## 319                  1      0        1   0   0   0   1   0    Alive Greyjoy
## 806                 11      0        0   0   0   0   1   0    Alive Greyjoy
##                                                info
## 58         Asha Greyjoy from House Greyjoy is Alive
## 248       Falia Flowers from House Greyjoy is Alive
## 313    Gwin Goodbrother from House Greyjoy is Alive
## 319 Gysella Goodbrother from House Greyjoy is Alive
## 806         Three-Tooth from House Greyjoy is Alive
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Сколько всего женских персонажей в книгах ``Песни льда и пламени''?
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(got}\OperatorTok{$}\NormalTok{Gender }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 157
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Сколько всего женских персонажей дворянского происхождения в книгах
  ``Песни льда и пламени''?
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{((got}\OperatorTok{$}\NormalTok{Gender }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) }\OperatorTok{&}\StringTok{ }\NormalTok{(got}\OperatorTok{$}\NormalTok{Nobility }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 84
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Поcчитатйе процентную (!) долю знати от общего числа персонажей
  (\texttt{Nobility}) в \texttt{Night\textquotesingle{}s\ Watch}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(got[got}\OperatorTok{$}\NormalTok{Allegiances }\OperatorTok{==}\StringTok{ "Night's Watch"}\NormalTok{, }\StringTok{"Nobility"}\NormalTok{])}\OperatorTok{*}\DecValTok{100}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 9.482759
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Поcчитатйе процентную (!) долю знати от общего числа персонажей
  (\texttt{Nobility}) у \texttt{Lannister}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(got[got}\OperatorTok{$}\NormalTok{Allegiances }\OperatorTok{==}\StringTok{ "Lannister"}\NormalTok{, }\StringTok{"Nobility"}\NormalTok{])}\OperatorTok{*}\DecValTok{100}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 71.60494
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Какая из книг цикла самая кровавая? Для ответа на этот вопрос
  подсчитайте таблицу частот для колонки \texttt{got\$Book.of.Death}:
\end{itemize}

\begin{quote}
Это можно сделать с помощью функции \texttt{table()}, но в дальнейшем Вы
узнаете и другие способы - подобная задача возникает достаточно часто.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{table}\NormalTok{(got}\OperatorTok{$}\NormalTok{Book.of.Death)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
##  1  2  3  4  5 
## 49 73 97 27 61
\end{verbatim}

\section{Создание функций}\label{solvtask_function}

\begin{itemize}
\tightlist
\item
  Создайте функцию \texttt{plus\_one()}, которая принимает число и
  возвращает это же число + 1
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plus_one <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x}\OperatorTok{+}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{plus_one}\NormalTok{(}\DecValTok{41}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 42
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте функцию \texttt{kvadrat()} возвращающее число в квадрате
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{kvadrat <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) x}\OperatorTok{*}\NormalTok{x}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{kvadrat}\NormalTok{(}\DecValTok{6}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 36
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте функцию \texttt{century()}, которая превращает год в век.
  Возможно, понадобится вспомнить,
  \href{https://ru.wikipedia.org/wiki/Век}{как года переводятся в века}.
\end{itemize}

\begin{quote}
Здесь нужно немного погуглить.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{century <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{floor}\NormalTok{((x}\OperatorTok{-}\DecValTok{1}\NormalTok{)}\OperatorTok{/}\DecValTok{100}\NormalTok{)}\OperatorTok{+}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{century}\NormalTok{(}\DecValTok{1999}\OperatorTok{:}\DecValTok{2002}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 20 20 21 21
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *А теперь сделайте функцию \texttt{century\_roman()}, которая
  переводит год в век, записанный римскими цифрами!
\end{itemize}

\begin{quote}
Здесь нужно просто немного погуглить - возможно, для создания римских
цифр есть уже готовая функция? Прежде созданные функции можно
использовать для создания новых функций!
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{century_roman <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{as.roman}\NormalTok{(}\KeywordTok{century}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{century_roman}\NormalTok{(}\DecValTok{1999}\OperatorTok{:}\DecValTok{2002}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] XX  XX  XXI XXI
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Напишите функцию \texttt{is\_prime()}, которая проверяет, является ли
  число простым.
\end{itemize}

\begin{quote}
Здесь может понадобиться оператор для получения остатка от деления:
\texttt{\%\%}. Еще может пригодиться функция \texttt{any()} - она
возвращает \texttt{TRUE}, если в векторе есть хотя бы один \texttt{TRUE}
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{is_prime <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\OperatorTok{!}\KeywordTok{any}\NormalTok{(x}\OperatorTok{%%}\NormalTok{(}\DecValTok{2}\OperatorTok{:}\NormalTok{(x}\OperatorTok{-}\DecValTok{1}\NormalTok{)) }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_prime}\NormalTok{(}\DecValTok{2017}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_prime}\NormalTok{(}\DecValTok{2019}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2019}\OperatorTok{/}\DecValTok{3} \CommentTok{#2019 делится на 3 без остатка}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 673
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_prime}\NormalTok{(}\DecValTok{2020}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{itemize}
\tightlist
\item
  *Создайте функцию \texttt{monotonic()}, которая принимает возвращает
  \texttt{TRUE}, если значения в векторе не убывают (то есть каждое
  следующее - больше или равно предыдущему) или не возврастают.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{monotonic <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{all}\NormalTok{(}\KeywordTok{diff}\NormalTok{(x)}\OperatorTok{>=}\DecValTok{0}\NormalTok{) }\OperatorTok{|}\StringTok{ }\KeywordTok{all}\NormalTok{(}\KeywordTok{diff}\NormalTok{(x)}\OperatorTok{<=}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{monotonic}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{monotonic}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{,}\DecValTok{5}\OperatorTok{:}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{monotonic}\NormalTok{(}\DecValTok{6}\OperatorTok{:-}\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{monotonic}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\KeywordTok{rep}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{10}\NormalTok{), }\DecValTok{5}\OperatorTok{:}\DecValTok{10}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\section{Семейство apply()}\label{solvtask_text}

\begin{itemize}
\tightlist
\item
  Посчитайте, в какой из 5 книг больше всего персонажей.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(got[, }\DecValTok{9}\OperatorTok{:}\DecValTok{13}\NormalTok{], }\DecValTok{2}\NormalTok{, sum)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## GoT CoK SoS FfC DwD 
## 250 324 389 250 261
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#Без apply():}

\CommentTok{#colSums(got[, 9:13])}

\CommentTok{#Еще:}

\CommentTok{#sapply(got[,9:13], sum)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Сделайте датафрейм \texttt{heroes} с персонажами, которые
  присутствовали во всех книгах.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{heroes <-}\StringTok{ }\NormalTok{got[}\KeywordTok{apply}\NormalTok{(got[, }\DecValTok{9}\OperatorTok{:}\DecValTok{13}\NormalTok{], }\DecValTok{1}\NormalTok{, sum) }\OperatorTok{==}\StringTok{ }\DecValTok{5}\NormalTok{, ]}

\NormalTok{heroes}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                 Name     Allegiances Death.Year Book.of.Death Death.Chapter
## 56        Arya Stark           Stark         NA            NA            NA
## 63       Balon Swann       Lannister         NA            NA            NA
## 104     Boros Blount       Baratheon         NA            NA            NA
## 131 Cersei Lannister House Lannister         NA            NA            NA
## 302            Grenn   Night's Watch         NA            NA            NA
## 345      Harys Swyft       Lannister         NA            NA            NA
## 383  Jaime Lannister       Lannister         NA            NA            NA
## 410         Jon Snow   Night's Watch         NA            NA            NA
## 436  Kevan Lannister House Lannister        300             5            NA
## 452 Lancel Lannister       Lannister         NA            NA            NA
## 548      Meryn Trant       Lannister         NA            NA            NA
## 652          Pycelle House Lannister        300             5            NA
## 741    Samwell Tarly   Night's Watch         NA            NA            NA
##     Book.Intro.Chapter Gender Nobility GoT CoK SoS FfC DwD Is.Alive
## 56                   2      0        1   1   1   1   1   1    Alive
## 63                  29      1        1   1   1   1   1   1    Alive
## 104                  8      1        1   1   1   1   1   1    Alive
## 131                  4      0        1   1   1   1   1   1    Alive
## 302                 19      1        0   1   1   1   1   1    Alive
## 345                 69      1        1   1   1   1   1   1    Alive
## 383                  5      1        1   1   1   1   1   1    Alive
## 410                  1      1        1   1   1   1   1   1    Alive
## 436                 56      1        1   1   1   1   1   1     Dead
## 452                 47      1        1   1   1   1   1   1    Alive
## 548                  8      1        1   1   1   1   1   1    Alive
## 652                 20      1        0   1   1   1   1   1     Dead
## 741                 70      1        1   1   1   1   1   1    Alive
##            Houses                                            info
## 56          Stark            Arya Stark from House Stark is Alive
## 63      Lannister       Balon Swann from House Lannister is Alive
## 104     Baratheon      Boros Blount from House Baratheon is Alive
## 131     Lannister  Cersei Lannister from House Lannister is Alive
## 302 Night's Watch         Grenn from House Night's Watch is Alive
## 345     Lannister       Harys Swyft from House Lannister is Alive
## 383     Lannister   Jaime Lannister from House Lannister is Alive
## 410 Night's Watch      Jon Snow from House Night's Watch is Alive
## 436     Lannister    Kevan Lannister from House Lannister is Dead
## 452     Lannister  Lancel Lannister from House Lannister is Alive
## 548     Lannister       Meryn Trant from House Lannister is Alive
## 652     Lannister            Pycelle from House Lannister is Dead
## 741 Night's Watch Samwell Tarly from House Night's Watch is Alive
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{#Еще}

\CommentTok{#heroes <- got[rowSums(got[, 9:13]) == 5, ]}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Создайте функцию \texttt{na\_n()}, которая будет возвращать количество
  \texttt{NA} в векторе.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{na_n <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{sum}\NormalTok{(}\KeywordTok{is.na}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{na_n}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\DecValTok{3}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\DecValTok{2}\NormalTok{, }\OtherTok{NA}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте количество NA в каждом столбце \texttt{got}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(got, }\DecValTok{2}\NormalTok{, na_n)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##               Name        Allegiances         Death.Year      Book.of.Death 
##                  0                  0                612                610 
##      Death.Chapter Book.Intro.Chapter             Gender           Nobility 
##                618                 12                  0                  0 
##                GoT                CoK                SoS                FfC 
##                  0                  0                  0                  0 
##                DwD           Is.Alive             Houses               info 
##                  0                  0                  0                  0
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Есть список \texttt{spisok}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{spisok <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DecValTok{0}\OperatorTok{:}\DecValTok{20}\NormalTok{, }\DecValTok{4}\OperatorTok{:}\DecValTok{24}\NormalTok{, }\DecValTok{6}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{6}\OperatorTok{:}\DecValTok{25}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Посчитайте сумму каждого вектора.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sapply}\NormalTok{(spisok, sum)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  15 210 294  18 310
\end{verbatim}

\begin{itemize}
\tightlist
\item
  А теперь длину.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sapply}\NormalTok{(spisok, length)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  5 21 21  4 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Напишите функцию \texttt{max\_item()}, которая будет принимать на
  входе список, а возвращать - (первый) самый длинный его элемент.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{max_item <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (x) spisok[[}\KeywordTok{which.max}\NormalTok{(}\KeywordTok{sapply}\NormalTok{(x, length))]]}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Теперь мы сделаем сложный список:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{large_spisok <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{3}\OperatorTok{:}\DecValTok{40}\NormalTok{, spisok)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Посчитайте длину каждого вектора в списке, в т.ч. для списка внутри
\end{itemize}

\begin{quote}
Для этого может понадобиться функция \texttt{rapply()}:
\textbf{recursive lapply}
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rapply}\NormalTok{(large_spisok, length, }\DataTypeTok{how =} \StringTok{"list"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [[1]]
## [1] 3
## 
## [[2]]
## [1] 38
## 
## [[3]]
## [[3]][[1]]
## [1] 5
## 
## [[3]][[2]]
## [1] 21
## 
## [[3]][[3]]
## [1] 21
## 
## [[3]][[4]]
## [1] 4
## 
## [[3]][[5]]
## [1] 20
\end{verbatim}

\section{Работа с текстом}\label{solvtask_test}

Дан строковый вектор:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Я"}\NormalTok{, }\StringTok{"выучу"}\NormalTok{, }\StringTok{"R"}\NormalTok{, }\StringTok{"за"}\NormalTok{, }\StringTok{"май!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Соедините вектор в одно строковое значение \texttt{ch}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ch <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(s, }\DataTypeTok{collapse =} \StringTok{" "}\NormalTok{)}
\NormalTok{ch}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Я выучу R за май!"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Подсчитайте количество знаков в \texttt{ch}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{nchar}\NormalTok{(ch)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 17
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Следующее задание: вырезать Замая
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{substr}\NormalTok{(ch, }\DecValTok{11}\NormalTok{, }\DecValTok{16}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "за май"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Превратите \texttt{ch} обратно в вектор, значения которого - отдельные
  слова:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{strsplit}\NormalTok{(ch, }\StringTok{" "}\NormalTok{)[[}\DecValTok{1}\NormalTok{]]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Я"     "выучу" "R"     "за"    "май!"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте дополнительную колонку в \texttt{got} под названием
  \texttt{info}, в которой будет написано: ``ИМЯ\_ПЕРСОНАЖА from House
  ЕГО\_ДОМ is dead/alive'' в зависимости от его статуса
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got}\OperatorTok{$}\NormalTok{info <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(got}\OperatorTok{$}\NormalTok{Name, }\StringTok{"from House"}\NormalTok{, got}\OperatorTok{$}\NormalTok{Houses, }\StringTok{"is"}\NormalTok{, got}\OperatorTok{$}\NormalTok{Is.Alive)}
\NormalTok{got}\OperatorTok{$}\NormalTok{info <-}\StringTok{ }\KeywordTok{sprintf}\NormalTok{(}\StringTok{"%s from House %s is %s"}\NormalTok{, got}\OperatorTok{$}\NormalTok{Name, got}\OperatorTok{$}\NormalTok{Houses, got}\OperatorTok{$}\NormalTok{Is.Alive)}
\KeywordTok{head}\NormalTok{(got}\OperatorTok{$}\NormalTok{info)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "Addam Marbrand from House Lannister is Alive"   
## [2] "Aegon Frey (Jinglebell) from House None is Dead"
## [3] "Aegon Targaryen from House Targaryen is Alive"  
## [4] "Adrack Humble from House Greyjoy is Dead"       
## [5] "Aemon Costayne from House Lannister is Alive"   
## [6] "Aemon Estermont from House Baratheon is Alive"
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Посчитайте длину самого короткого имени в ``Песни льда и пламени''?
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{min}\NormalTok{(}\KeywordTok{nchar}\NormalTok{(got}\OperatorTok{$}\NormalTok{Name))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 3
\end{verbatim}

\begin{itemize}
\tightlist
\item
  На самом деле, функция \texttt{which.max()} выдает только индекс
  первого максимального значения, даже если их несколько. Это же верно
  для функции \texttt{which.min()}.
\end{itemize}

Напишите функцию \texttt{which.all.min()}, которая выдает индексы всех
минимальных значений векторов.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{which.all.min <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) (}\DecValTok{1}\OperatorTok{:}\KeywordTok{length}\NormalTok{(x))[x }\OperatorTok{==}\StringTok{ }\KeywordTok{min}\NormalTok{(x)]}
\end{Highlighting}
\end{Shaded}

Проверьте, что эта функция работает на длине имен персонажей:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{got[}\KeywordTok{which.all.min}\NormalTok{(}\KeywordTok{nchar}\NormalTok{(got}\OperatorTok{$}\NormalTok{Name)),]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##     Name Allegiances Death.Year Book.of.Death Death.Chapter Book.Intro.Chapter
## 81   Ben        None         NA            NA            NA                 37
## 178  Del    Wildling        299             3            41                 41
## 352  Hod        None         NA            NA            NA                  5
## 459  Lem        None         NA            NA            NA                 13
## 467  Lew House Stark         NA            NA            NA                  7
## 590  Nan House Stark         NA            NA            NA                  1
## 602  Ogo        None        298             1            61                 46
## 640  Pia        None         NA            NA            NA                 30
## 653  Pyg        None        300             4            20                 20
## 734  Ryk    Wildling         NA            NA            NA                  7
## 850  Utt        None        299             3            39                 30
## 851  Val    Wildling         NA            NA            NA                  7
## 912  Zei       Stark         NA            NA            NA                 64
##     Gender Nobility GoT CoK SoS FfC DwD Is.Alive   Houses
## 81       1        0   0   0   0   1   0    Alive     None
## 178      1        0   0   0   1   0   0     Dead Wildling
## 352      1        0   0   1   0   0   0    Alive     None
## 459      1        0   0   0   1   1   0    Alive     None
## 467      1        0   1   0   0   0   0    Alive    Stark
## 590      0        0   1   1   0   0   0    Alive    Stark
## 602      1        1   1   0   0   0   0     Dead     None
## 640      0        0   0   1   0   1   0    Alive     None
## 653      1        0   0   0   1   1   0     Dead     None
## 734      1        0   0   0   1   0   0    Alive Wildling
## 850      1        0   0   1   1   0   0     Dead     None
## 851      0        0   0   0   1   0   1    Alive Wildling
## 912      0        0   0   0   1   0   0    Alive    Stark
##                                 info
## 81      Ben from House None is Alive
## 178  Del from House Wildling is Dead
## 352     Hod from House None is Alive
## 459     Lem from House None is Alive
## 467    Lew from House Stark is Alive
## 590    Nan from House Stark is Alive
## 602      Ogo from House None is Dead
## 640     Pia from House None is Alive
## 653      Pyg from House None is Dead
## 734 Ryk from House Wildling is Alive
## 850      Utt from House None is Dead
## 851 Val from House Wildling is Alive
## 912    Zei from House Stark is Alive
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Создайте функцию \texttt{is\_anagram()}, которая будет выдавать
  \texttt{TRUE} если одно слово является анаграммой другого.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ "tree"}
\NormalTok{b <-}\StringTok{ "erte"}

\NormalTok{is_anagram <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, b) }\KeywordTok{paste}\NormalTok{(}\KeywordTok{sort}\NormalTok{(}\KeywordTok{strsplit}\NormalTok{(a, }\StringTok{""}\NormalTok{)[[}\DecValTok{1}\NormalTok{]]), }\DataTypeTok{collapse =} \StringTok{""}\NormalTok{) }\OperatorTok{==}\StringTok{ }\KeywordTok{paste}\NormalTok{(}\KeywordTok{sort}\NormalTok{(}\KeywordTok{strsplit}\NormalTok{(b, }\StringTok{""}\NormalTok{)[[}\DecValTok{1}\NormalTok{]]), }\DataTypeTok{collapse =} \StringTok{""}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Проверьте, работает ли функция, на двух векторах:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"спаниель"}\NormalTok{, }\StringTok{"капюшон"}\NormalTok{, }\StringTok{"state"}\NormalTok{)}
\NormalTok{b <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"апельсин"}\NormalTok{, }\StringTok{"парашют"}\NormalTok{, }\StringTok{"taste"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{quote}
Нужно либо векторизовать функцию (сделать так, чтобы она могла принимать
вектора на входе), либо использовать mapply(). Есть простой и хитрый
способ векторизовать функцию - Vectorize(). Постарайтесь все-таки не
использовать for, пожалуйста.
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mapply}\NormalTok{(is_anagram, a, b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## спаниель  капюшон    state 
##     TRUE    FALSE     TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{is_anagram_v <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, b) \{}
  \KeywordTok{sapply}\NormalTok{(}\KeywordTok{sapply}\NormalTok{(}\KeywordTok{sapply}\NormalTok{(a,strsplit, }\StringTok{""}\NormalTok{), sort), paste, }\DataTypeTok{collapse =} \StringTok{""}\NormalTok{) }\OperatorTok{==}\StringTok{ }\KeywordTok{sapply}\NormalTok{(}\KeywordTok{sapply}\NormalTok{(}\KeywordTok{sapply}\NormalTok{(b,strsplit, }\StringTok{""}\NormalTok{), sort), paste, }\DataTypeTok{collapse =} \StringTok{""}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\section{data.table}\label{solvdt_task}

Найдите все битвы, в которых \texttt{attacker\_king} -
\texttt{Robb\ Stark}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{batdt[attacker_king }\OperatorTok{==}\StringTok{ "Robb Stark"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##                              name year battle_number attacker_king
##  1:      Battle of the Green Fork  298             4    Robb Stark
##  2: Battle of the Whispering Wood  298             5    Robb Stark
##  3:           Battle of the Camps  298             6    Robb Stark
##  4:    Battle of Torrhen's Square  299            11    Robb Stark
##  5:             Battle of Oxcross  299            15    Robb Stark
##  6:             Sack of Harrenhal  299            18    Robb Stark
##  7:            Battle of the Crag  299            19    Robb Stark
##  8:                Siege of Darry  299            21    Robb Stark
##  9:          Battle of Duskendale  299            22    Robb Stark
## 10:              Siege of Seagard  299            27    Robb Stark
##                defender_king attacker_1 attacker_2 attacker_3 attacker_4
##  1: Joffrey/Tommen Baratheon      Stark                                 
##  2: Joffrey/Tommen Baratheon      Stark      Tully                      
##  3: Joffrey/Tommen Baratheon      Stark      Tully                      
##  4:      Balon/Euron Greyjoy      Stark                                 
##  5: Joffrey/Tommen Baratheon      Stark      Tully                      
##  6: Joffrey/Tommen Baratheon      Stark                                 
##  7: Joffrey/Tommen Baratheon      Stark                                 
##  8: Joffrey/Tommen Baratheon      Darry                                 
##  9: Joffrey/Tommen Baratheon      Stark                                 
## 10: Joffrey/Tommen Baratheon       Frey                                 
##     defender_1 defender_2 defender_3 defender_4 attacker_outcome    battle_type
##  1:  Lannister                    NA         NA             loss pitched battle
##  2:  Lannister                    NA         NA              win         ambush
##  3:  Lannister                    NA         NA              win         ambush
##  4:    Greyjoy                    NA         NA              win pitched battle
##  5:  Lannister                    NA         NA              win         ambush
##  6:  Lannister                    NA         NA              win         ambush
##  7:  Lannister                    NA         NA              win         ambush
##  8:  Lannister                    NA         NA              win          siege
##  9:  Lannister                    NA         NA             loss pitched battle
## 10:  Mallister                    NA         NA              win          siege
##     major_death major_capture attacker_size defender_size
##  1:           1             1         18000         20000
##  2:           1             1          1875          6000
##  3:           0             0          6000         12625
##  4:           0             0           244           900
##  5:           1             1          6000         10000
##  6:           1             0           100           100
##  7:           0             0          6000            NA
##  8:           0             0            NA            NA
##  9:           1             0          3000            NA
## 10:           0             1            NA            NA
##                                                                attacker_commander
##  1: Roose Bolton, Wylis Manderly, Medger Cerwyn, Harrion Karstark, Halys Hornwood
##  2:                                                     Robb Stark, Brynden Tully
##  3:                                    Robb Stark, Tytos Blackwood, Brynden Tully
##  4:                                                    Rodrik Cassel, Cley Cerwyn
##  5:                                                     Robb Stark, Brynden Tully
##  6:                                       Roose Bolton, Vargo Hoat, Robett Glover
##  7:                                 Robb Stark, Smalljon Umber, Black Walder Frey
##  8:                                                               Helman Tallhart
##  9:                                               Robertt Glover, Helman Tallhart
## 10:                                                                   Walder Frey
##                                                   defender_commander summer
##  1: Tywin Lannister, Gregor Clegane, Kevan Lannister, Addam Marbrand      1
##  2:                                                  Jaime Lannister      1
##  3:                                 Lord Andros Brax, Forley Prester      1
##  4:                                                  Dagmer Cleftjaw      1
##  5:               Stafford Lannister, Roland Crakehall, Antario Jast      1
##  6:                                                      Amory Lorch      1
##  7:                                                     Rolph Spicer      1
##  8:                                                                       1
##  9:                                    Randyll Tarly, Gregor Clegane      1
## 10:                                                  Jason Mallister      1
##             location          region
##  1:       Green Fork  The Riverlands
##  2:  Whispering Wood  The Riverlands
##  3:         Riverrun  The Riverlands
##  4: Torrhen's Square       The North
##  5:          Oxcross The Westerlands
##  6:        Harrenhal  The Riverlands
##  7:             Crag The Westerlands
##  8:            Darry  The Riverlands
##  9:       Duskendale  The Crownlands
## 10:          Seagard  The Riverlands
##                                                                                                                                                     note
##  1:                                                                                                                                                     
##  2:                                                                                                                                                     
##  3:                                                                                                                                                     
##  4: Greyjoy's troop number comes from the 264 estimate to have arrived on the stony shore minus the 20 Theon takes to attack Winterfell. Thus 264-20=244
##  5:                                                                                                                                                     
##  6:                                                                                                                                                     
##  7:                                                                                                                                                     
##  8:                                                                                                                                                     
##  9:                                                                                                                                                     
## 10:                                                                                                                                                     
##                 outcome all_army ratio_army
##  1: Победа защищающихся    38000  0.9000000
##  2:    Победа атакующих     7875  0.3125000
##  3:    Победа атакующих    18625  0.4752475
##  4:    Победа атакующих     1144  0.2711111
##  5:    Победа атакующих    16000  0.6000000
##  6:    Победа атакующих      200  1.0000000
##  7:    Победа атакующих       NA         NA
##  8:    Победа атакующих       NA         NA
##  9: Победа защищающихся       NA         NA
## 10:    Победа атакующих       NA         NA
\end{verbatim}

Как они заканчивались?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{batdt[attacker_king }\OperatorTok{==}\StringTok{ "Robb Stark"}\NormalTok{, .N, by =}\StringTok{ }\NormalTok{attacker_outcome]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    attacker_outcome N
## 1:             loss 2
## 2:              win 8
\end{verbatim}

Найдите, в битвах какого типа проигрывал \texttt{Robb\ Stark} как
атакующий король.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{batdt[attacker_king }\OperatorTok{==}\StringTok{ "Robb Stark"}\NormalTok{, .N, by =}\StringTok{ }\NormalTok{.(attacker_outcome, battle_type)]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    attacker_outcome    battle_type N
## 1:             loss pitched battle 2
## 2:              win         ambush 5
## 3:              win pitched battle 1
## 4:              win          siege 2
\end{verbatim}

\section{Решейпинг}\label{solvtask_reshape}

\begin{itemize}
\tightlist
\item
  Допустим, у вас есть следующий \texttt{data.table}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iq <-}\StringTok{ }\KeywordTok{data.table}\NormalTok{(}\DataTypeTok{id =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{iq_before =} \KeywordTok{c}\NormalTok{(}\DecValTok{98}\NormalTok{, }\DecValTok{106}\NormalTok{, }\DecValTok{102}\NormalTok{), }\DataTypeTok{iq_after =} \KeywordTok{c}\NormalTok{(}\DecValTok{103}\NormalTok{, }\DecValTok{105}\NormalTok{, }\DecValTok{103}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Превратите широкий iq в длинный iq\_long с колонками \texttt{id},
  \texttt{time}, \texttt{IQ}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iq_long <-}\StringTok{ }\KeywordTok{melt}\NormalTok{(iq, }\DataTypeTok{id.vars =} \StringTok{'id'}\NormalTok{, }\DataTypeTok{variable.name =} \StringTok{"time"}\NormalTok{, }\DataTypeTok{value.name =} \StringTok{"IQ"}\NormalTok{)}
\NormalTok{iq_long}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    id      time  IQ
## 1:  1 iq_before  98
## 2:  2 iq_before 106
## 3:  3 iq_before 102
## 4:  1  iq_after 103
## 5:  2  iq_after 105
## 6:  3  iq_after 103
\end{verbatim}

\begin{itemize}
\tightlist
\item
  В колонке \texttt{time} должно быть значение \texttt{before} или
  \texttt{after}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iq_long[, time }\OperatorTok{:}\ErrorTok{=}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{"iq_"}\NormalTok{, }\StringTok{""}\NormalTok{, time)]}
\NormalTok{iq_long}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    id   time  IQ
## 1:  1 before  98
## 2:  2 before 106
## 3:  3 before 102
## 4:  1  after 103
## 5:  2  after 105
## 6:  3  after 103
\end{verbatim}

\begin{itemize}
\tightlist
\item
  А теперь обратно \texttt{iq\_long} в широкий формат:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{dcast}\NormalTok{(iq_long, ... }\OperatorTok{~}\StringTok{ }\NormalTok{time)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    id after before
## 1:  1   103     98
## 2:  2   105    106
## 3:  3   103    102
\end{verbatim}

\section{Описательная статистика}\label{solvtask_desc}

\begin{itemize}
\item
  Вспомните все описательные статистики, которые мы прошли, и примените
  их на векторе \texttt{pbcdt\$chol} (количество холистерина).
  Попытайтесь представить, как будут распределены эти данные исходя из
  результатов.
\item
  Посчитайте описательные статистики
\item
  Создайте функцию \texttt{check\_outliers()}, которая принимает как
  аргумент числовой вектор, а возвращает логический вектор:
  \texttt{TRUE} - если есть значения больше или меньше чем 3 стандартных
  отклонения от среднего, \texttt{FALSE} в обратнос случае. Проверьте
  функцию на векторе \texttt{pbcdt\$chol}. Посчитайте количество
  \texttt{TRUE} в результате.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{check_outliers <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{abs}\NormalTok{(x }\OperatorTok{-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x))}\OperatorTok{>}\DecValTok{3}\OperatorTok{*}\KeywordTok{sd}\NormalTok{(x)}
\KeywordTok{sum}\NormalTok{(}\KeywordTok{check_outliers}\NormalTok{(pbcdt}\OperatorTok{$}\NormalTok{chol))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 8
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Измените функцию \texttt{check\_outliers()}, чтобы у нее появился
  параметр \texttt{n\ =} со значением 3 по умолчанию. От этого параметра
  должно зависеть количество стандартных отклонений от среднего в
  формуле. Проверьте функцию на том же векторе и \texttt{n\ =\ 2}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{check_outliers <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, n) }\KeywordTok{abs}\NormalTok{(x }\OperatorTok{-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x))}\OperatorTok{>}\NormalTok{n}\OperatorTok{*}\KeywordTok{sd}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\KeywordTok{check_outliers}\NormalTok{(pbcdt}\OperatorTok{$}\NormalTok{chol, }\DataTypeTok{n =} \DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 13
\end{verbatim}

\begin{itemize}
\tightlist
\item
  Добавим в функцию \texttt{check\_outliers()} еще больше гибкости.
  Теперь функция сможет принимать на вход еще и функции центральной
  тенденции и вариабельности \texttt{central\ =} и \texttt{deviation\ =}
  со средним и стандартным отклонением по умолчанию. Проверьте функцию с
  помощью \texttt{n\ =\ 3}, медианой и медианным абсолютным отклонением.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{check_outliers <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, n, }\DataTypeTok{central =}\NormalTok{ mean, }\DataTypeTok{deviation =}\NormalTok{ sd) }\KeywordTok{abs}\NormalTok{(x }\OperatorTok{-}\StringTok{ }\KeywordTok{central}\NormalTok{(x))}\OperatorTok{>}\NormalTok{n}\OperatorTok{*}\KeywordTok{deviation}\NormalTok{(x)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\KeywordTok{check_outliers}\NormalTok{(pbcdt}\OperatorTok{$}\NormalTok{chol, }\DataTypeTok{n =} \DecValTok{3}\NormalTok{, median, mad))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 20
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \[s^2_{pool} = \frac {(n_1-1)s^2_1 + (n_2-1)s^2_2} {(n_1 - 1) + (n_2 -1)}\]
\end{itemize}

\bibliography{book.bib,packages.bib}

\end{document}
