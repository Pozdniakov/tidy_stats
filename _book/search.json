[
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Введение в R",
    "section": "",
    "text": "Для работы с R необходимо его сначала скачать и установить.\n\nR\n\nна Windows, найдите большую кнопку Download R (номер версии) for Windows.\nна Mac, если маку меньше, чем 5 лет, то смело ставьте *.pkg файл с последней версией. Если старше, то поищите на той же странице версию для вашей системы.\nна Linux, также можно добавить зеркало и установить из командной строки:\n\n\n\nsudo apt-get install r-cran-base\nВ данной книге используется следующая версия R:\n\nsessionInfo()$R.version$version.string\n\n[1] \"R version 4.0.2 (2020-06-22)\"\n\n\nПосле установки R необходимо скачать и установить RStudio:\n\nRStudio\n\nЕсли вдруг что-то установить не получается (или же вы просто не хотите устанавливать на компьютер лишние программы), то можно работать в облаке, делая все то же самое в веб-браузере:\n\nRStudio cloud\n\nПервый и вполне закономерный вопрос: зачем мы ставили R и отдельно еще какой-то RStudio? Если опустить незначительные детали, то R – это сам язык программирования, а RStudio – это среда (IDE), которая позволяет в этом языке очень удобно работать.\n\nRStudio – это не единственная среда для R, но, определенно, самая удобная на сегодняшний день. Почти все пользуются именно ею и не стоит тратить время на поиск чего-то более удобного и лучшего. Если же вы привыкли работать с Jupyter Notebook, то в R обычно вместо него используется великолепный RMarkdown – с помощью которого и написан этот онлайн-учебник, кстати говоря. И с RMarkdown мы тоже будем разбираться!"
  },
  {
    "objectID": "intro.html#rstudio",
    "href": "intro.html#rstudio",
    "title": "1  Введение в R",
    "section": "1.2 Знакомство с RStudio",
    "text": "1.2 Знакомство с RStudio\nТак, давайте взглянем на то, что нам тут открылось:\n\nВ первую очередь нас интересуют два окна: 1 - Code Editor (окно для написания скриптов) 1 и 2 - R Console (консоль). Здесь можно писать команды и запускать их. При этом работа в консоли и работа со скриптом немного различается.\nВ 2 - R Console вы пишите команду и запускаете ее нажиманием Enter. Иногда после запуска команды появляется какой-то результат. Если нажимать стрелку вверх на клавиатуре, то можно выводить в консоль предыдущие команды. Это очень удобно для запуска предыдущих команд с небольшими изменениями.\nВ 1 - Code Editor для запуска команды вы должны выделить ее и нажать Ctrl + Enter (Cmd + Enter на macOS). Если не нажать эту комбинацию клавиш, то команда не запустится. Можно выделить и запустить сразу несколько команд или даже все команды скрипта. Все команды скрипта можно выделить с помощью сочетания клавиш Ctrl + A на Windows и Linux, Cmd + A на macOS 2. Как только вы запустите команду (или несколько команд), соответствующие строчки кода появятся в 2 - R Console, как будто бы вы запускали их прямо там.\nОбычно в консоли удобно что-то писать, чтобы быстро что-то посчитать. Скрипты удобнее при работе с длинными командами и как способ сохранения написанного кода для дальнейшей работы. Для сохранения скрипта нажмите File - Save As.... R скрипты сохраняются с разрешением .R, но по своей сути это просто текстовые файлы, которые можно открыть и модифицировать в любом текстовом редакторе а-ля “Блокнот”.\n3 - Workspace and History – здесь можно увидеть переменные. Это поле будет автоматически обновляться по мере того, как Вы будете запускать строчки кода и создавать новые переменные. Еще там есть вкладка с историей всех команд, которые были запущены.\n4 - Plots and files. Здесь есть очень много всего. Во-первых, небольшой файловый менеджер, во-вторых, там будут появляться графики, когда вы будете их рисовать. Там же есть вкладка с вашими пакетами (Packages) и Help по функциям. Но об этом потом."
  },
  {
    "objectID": "intro.html#calc",
    "href": "intro.html#calc",
    "title": "1  Введение в R",
    "section": "1.3 R как калькулятор",
    "text": "1.3 R как калькулятор\nR – полноценный язык программирования, который позволяет решать широкий спектр задач. Но в первую очередь R используется для анализа данных и статистических вычислений. Тем не менее, многими R до сих пор воспринимается как просто продвинутый калькулятор. Ну что ж, калькулятор, так калькулятор.\nДавайте начнем с самого простого и попробуем использовать R как калькулятор с помощью арифметических операторов +, -, *, /, ^ (степень), () и т.д.\nПросто запускайте в консоли пока не надоест:\n\n40+2\n\n[1] 42\n\n3-2\n\n[1] 1\n\n5*6\n\n[1] 30\n\n99/9 #деление\n\n[1] 11\n\n2^3 #степень\n\n[1] 8\n\n13 %/% 3 #целочисленное деление\n\n[1] 4\n\n13 %% 3 #остаток от деления\n\n[1] 1\n\n\nПопробуйте самостоятельно посчитать что-нибудь с разными числами.\n\nНичего сложного, верно? Вводим выражение и получаем результат.\nВы могли заметить, что некоторые команды у меня заканчиваются знаком решетки (#). Все, что написано в строчке после # игнорируется R при выполнении команды. Написанные команды в скрипте рекомендуется сопровождать комментариями, которые будут объяснять вам же в будущем (или кому-то еще), что конкретно происходит в соответствующем куске кода 3. Кроме того, комментарии можно использовать в тех случаях, когда вы хотите написать кусок кода по-другому, не стирая полностью предыдущий код: достаточно “закомментить” нужные строчки - поставить # в начало каждой строки, которую вы хотите переписать. Для этого есть специальное сочетание горячих клавиш: Ctrl + Shift + C (Cmd + Shift + C на macOS) – во всех выделенных строчках будет написан # в начале.\nСогласно данным навязчивых рекламных баннеров в интернете, только 14% россиян могут справиться с этим примером:\n\n2 + 2 * 2\n\n[1] 6\n\n\nНа самом деле, разные языки программирования ведут себя по-разному в таких ситуациях, поэтому ответ 6 (сначала умножаем, потом складываем) не так очевиден.\nПорядок выполнения арифметических операций (т.е. приоритет операторов, operator precedence) в R как в математике, так что не забывайте про скобочки.\n\n(2+2)*2\n\n[1] 8\n\n\nЕсли Вы не уверены в том, какие операторы имеют приоритет, то используйте скобочки, чтобы точно обозначить, в каком порядке нужно производить операции. Или же смотрите на таблицу приоритета операторов с помощью команды ?Syntax."
  },
  {
    "objectID": "intro.html#func",
    "href": "intro.html#func",
    "title": "1  Введение в R",
    "section": "1.4 Функции",
    "text": "1.4 Функции\nДавайте теперь извлечем корень из какого-нибудь числа. В принципе, тем, кто помнит школьный курс математики, возведения в степень вполне достаточно:\n\n16 ^ 0.5\n\n[1] 4\n\n\nНу а если нет, то можете воспользоваться специальной функцией: это обычно какие-то буквенные символы с круглыми скобками сразу после названия функции. Мы подаем на вход (внутрь скобочек) какие-то данные, внутри этих функций происходят какие-то вычисления, которые выдает в ответ какие-то другие данные (или же функция записывает файл, рисует график и т.д.).\nВот, например, функция для корня:\n\nsqrt(16)\n\n[1] 4\n\n\n\nR – case-sensitive язык, т.е. регистр важен. SQRT(16) не будет работать.\n\nА вот так выглядит функция логарифма:\n\nlog(8)\n\n[1] 2.079442\n\n\nТак, вроде бы все нормально, но… Если Вы еще что-то помните из школьной математики, то должны понимать, что что-то здесь не так.\nЗдесь не хватает основания логарифма!\n\nЛогарифм – показатель степени, в которую надо возвести число, называемое основанием, чтобы получить данное число.\n\nТо есть у логарифма 8 по основанию 2 будет значение 3:\n\\(\\log_2 8 = 3\\)\nТо есть если возвести 2 в степень 3 у нас будет 8:\n\\(2^3 = 8\\)\nТолько наша функция считает все как-то не так.\nЧтобы понять, что происходит, нам нужно залезть в хэлп этой функции:\n\n?log\n\nСправа внизу в RStudio появится вот такое окно:\n\nДействительно, у этой функции есть еще аргумент base =. По умолчанию он равен числу Эйлера (2.7182818…), т.е. функция считает натуральный логарифм. В большинстве функций R есть какой-то основной инпут – данные в том или ином формате, а есть и дополнительные параметры, которые можно прописывать вручную, если параметры по умолчанию вас не устраивают.\n\nlog(x = 8, base = 2)\n\n[1] 3\n\n\n…или просто (если Вы уверены в порядке переменных):\n\nlog(8,2)\n\n[1] 3\n\n\nБолее того, Вы можете использовать результат выполнения одних функций в качестве аргумента для других:\n\nlog(8, sqrt(4))\n\n[1] 3\n\n\nЕсли эксплицитно писать имена аргументов, то их порядок в функции не важен:\n\nlog(base = 2, x = 8)\n\n[1] 3\n\n\nА еще можно писать имена аргументов не полностью, если они не совпадают с другими:\n\nlog(b = 2, x = 8)\n\n[1] 3\n\n\nМы еще много раз будем возвращаться к функциям. Вообще, функции – это одна из важнейших штук в R (примерно так же как и в Python). Мы будем создавать свои функции, использовать функции как инпут для функций и многое-многое другое. В R очень крутые возможности работы с функциями. Поэтому подружитесь с функциями, они клевые.\n\nАрифметические знаки, которые мы использовали: +,-,/,^ и т.д. называются операторами и на самом деле тоже являются функциями:\n\n\n'+'(3,4)\n\n[1] 7"
  },
  {
    "objectID": "intro.html#google",
    "href": "intro.html#google",
    "title": "1  Введение в R",
    "section": "1.5 В любой непонятной ситуации – гуглите",
    "text": "1.5 В любой непонятной ситуации – гуглите\nЕсли вдруг вы не знаете, что искать в хэлпе, или хэлпа попросту недостаточно, то… гуглите!\n\nНет ничего постыдного в том, чтобы гуглить решения проблем. Это абсолютно нормально. Используйте силу интернета во благо и да помогут вам Stackoverflow4 и бесчисленные R-туториалы!\n\n\nComputer Programming To Be Officially Renamed “Googling Stack Overflow”Source: http://t.co/xu7acfXvFF pic.twitter.com/iJ9k7aAVhd\n\n— Stack Exchange ((StackExchange?)) July 20, 2015\n\n\n\nГлавное, помните: загуглить работающий ответ всегда недостаточно. Надо понять, как и почему решение работает. Иначе что-то обязательно пойдет не так.\nКроме того, правильно загуглить проблему – не так уж и просто.\n\n\nDoes anyone ever get good at R or do they just get good at googling how to do things in R\n\n— 🔬🖤Lauren M. Seyler, Ph.D.❤️⚒ ((mousquemere?)) May 6, 2019\n\n\nКороче говоря: гуглить – хорошо, бездумно копировать чужие решения – плохо."
  },
  {
    "objectID": "intro.html#variables",
    "href": "intro.html#variables",
    "title": "1  Введение в R",
    "section": "1.6 Переменные",
    "text": "1.6 Переменные\nВажная штука в программировании на практически любом языке – возможность сохранять значения в переменных. В R это обычно делается с помощью вот этих символов: <- (но можно использовать и обычное =, хотя это не очень принято). Для этого есть удобное сочетание клавиш: нажмите одновременно Alt + - (или option + - на macOS).\n\nЗаметьте, при присвоении результат вычисления не выводится в консоль! Если опустить детали, то обычно результат выполнения комманды либо выводится в консоль, либо записывается в переменную.\n\n\na <- 2\na\n\n[1] 2\n\n\nСправа от <- находится значение, которое вы хотите сохранить, или же какое-то выражение, результат которого вы хотите сохранить в эту переменную5:\nСлева от <- находится название будущей переменной. Название переменных может быть самым разным. Есть несколько ограничений для синтаксически валидных имен переменных: они должны включать в себя буквы, цифры, . или _, начинаться на букву (или точку, за которой не будет следовать цифра), не должны совпадать с коротким списком зарезервированных слов. Короче говоря, название не должно включать в себя пробелы и большинство других знаков.\nНельзя: - new variable - _new_variable - .1var - v-r\nМожно: - new_variable - .new.variable - var_2\nОбязательно делайте названия переменных осмысленными! Старайтесь делать при этом их понятными и короткими, это сохранит вам очень много времени, когда вы (или кто-то еще) будете пытаться разобраться в написанном ранее коде. Если название все-таки получается длинным и состоящим из нескольких слов, то лучше всего использовать нижнее подчеркивание в качестве разделителя: some_variable6.\nПосле присвоения переменная появляется во вкладке Environment в RStudio:\n\nМожно использовать переменные в функциях и просто вычислениях:\n\nb <- a ^ a + a * a\nb\n\n[1] 8\n\nlog(b, a)\n\n[1] 3"
  },
  {
    "objectID": "intro.html#logic",
    "href": "intro.html#logic",
    "title": "1  Введение в R",
    "section": "1.7 Логические операторы",
    "text": "1.7 Логические операторы\nВы можете сравнивать разные переменные:\n\na == b\n\n[1] FALSE\n\n\nЗаметьте, что сравнивая две переменные мы используем два знака равно ==, а не один =. Иначе это будет означать присвоение.\n\na = b\na\n\n[1] 8\n\n\nТеперь Вы сможете понять комикс про восстание роботов на следующей странице (пусть он и совсем про другой язык программирования)\n\nЭтот комикс объясняет, как важно не путать присваивание и сравнение (хотя я иногда путаю до сих пор =( ).\nИногда нам нужно проверить на неравенство:\n\na <- 2\nb <- 3\n\na == b\n\n[1] FALSE\n\na != b\n\n[1] TRUE\n\n\nВосклицательный язык в программировании вообще и в R в частности стандартно означает отрицание.\nЕще мы можем сравнивать на больше/меньше:\n\na > b\n\n[1] FALSE\n\na < b\n\n[1] TRUE\n\na >= b\n\n[1] FALSE\n\na <= b\n\n[1] TRUE\n\n\nЭтим мы будем пользоваться в дальнейшем регулярно! Именно на таких простых логических операциях построено большинство операций с данными.\n##Типы данных {#data_types}\nДо этого момента мы работали только с числами (numeric):\n\nclass(a)\n\n[1] \"numeric\"\n\n\nНа самом деле, в R три типа numeric: integer (целые), double (дробные), complex (комплексные числа)7. R сам будет конвертировать числа в нужный тип numeric при необходимости, поэтому этим можно не заморачиваться.\nЕсли же все-таки нужно задать конкретный тип числа эксплицитно, то можно воспользоваться функциями as.integer(), as.double() и as.complex(). Кроме того, при создании числа можно поставить в конце L, чтобы обозначить число как integer:\n\nis.integer(5)\n\n[1] FALSE\n\nis.integer(5L)\n\n[1] TRUE\n\n\nПро double есть еще один маленький секрет. Дело в том, что дробные числа хранятся в R как числа с плавающей запятой двойной точности. Дробные числа в компьютере могут быть записаны только с определенной степенью точности, поэтому иногда встречаются вот такие вот ситуации:\n\nsqrt(2)^2 == 2\n\n[1] FALSE\n\n\nЭто довольно стандартная ситуация, характерная не только для R. Чтобы ее избежать, можно воспользоваться функцией all.equal():\n\nall.equal(sqrt(2)^2, 2)\n\n[1] TRUE\n\n\nТеперь нам нужно ознакомиться с двумя другими важными типами данных в R:\n\nСтроковые (character) данные: набор букв, цифр и символов, которые должны выделяться кавычками.\n\n\ns <- \"Всем привет!\"\ns\n\n[1] \"Всем привет!\"\n\nclass(s)\n\n[1] \"character\"\n\n\nМожно использовать как \", так и ' (что удобно, когда строчка внутри уже содержит какие-то кавычки).\n\n\"Ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn\"\n\n[1] \"Ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn\"\n\n\n\nЛогические (logical) данные: просто TRUE или FALSE.\n\n\nt1 <- TRUE\nf1 <- FALSE\n\nt1\n\n[1] TRUE\n\nf1\n\n[1] FALSE\n\n\nВообще, можно еще писать T и F (но не True и False!)\n\nt2 <- T\nf2 <- F\n\nЭто плохая практика, так как R защищает от перезаписи переменные TRUE и FALSE, но не защищает от этого T и F.\n\nTRUE <- FALSE\n\nError in TRUE <- FALSE: invalid (do_set) left-hand side to assignment\n\nTRUE\n\n[1] TRUE\n\nT <- FALSE\nT\n\n[1] FALSE\n\n\nФункция rm() позволяет удалить ненужную переменную:\n\nrm(T)\n\nМы уже встречались с логическими значениями при сравнении двух числовых переменных. Теперь вы можете догадаться, что результаты сравнения, например, числовых или строковых переменных, можно тоже сохранять в переменные!\n\ncomparison <- a == b\ncomparison\n\n[1] FALSE\n\n\nЭто нам очень понадобится, когда мы будем работать с реальными данными: нам нужно будет постоянно вытаскивать какие-то данные из датасета, что как раз и построено на игре со сравнением переменных.\nЧтобы этим хорошо уметь пользоваться, нам нужно еще освоить как работать с логическими операторами. Про один мы немного уже говорили – это логическое НЕ (!). ! превращает TRUE в FALSE, а FALSE в TRUE:\n\nt1\n\n[1] TRUE\n\n!t1\n\n[1] FALSE\n\n!!t1 #Двойное отрицание!\n\n[1] TRUE\n\n\nЕще есть логическое И (выдаст TRUE только в том случае если обе переменные TRUE):\n\nt1 & t2\n\n[1] TRUE\n\nt1 & f1\n\n[1] FALSE\n\n\nА еще логическое ИЛИ (выдаст TRUE в случае если хотя бы одна из переменных TRUE):\n\nt1 | f1\n\n[1] TRUE\n\nf1 | f2\n\n[1] FALSE\n\n\nЕсли кому-то вдруг понадобится другое ИЛИ (строгое ЛИБО) – есть функция xor(), принимающая два аргумента и возвращая TRUE только в том случае, если ровно один из двух аргументов равен TRUE.\nИтак, мы только что разобрались с самой занудной (хотя и важной) частью - с основными типа данных в R и как с ними работать8. Пора переходить к чему-то более интересному и специфическому для R. Вперед к ВЕКТОРАМ!"
  },
  {
    "objectID": "intro.html#atomic",
    "href": "intro.html#atomic",
    "title": "1  Введение в R",
    "section": "2.1 Понятие atomic вектора в R",
    "text": "2.1 Понятие atomic вектора в R\nЕсли у вас не было линейной алгебры (или у вас с ней было все плохо), то просто запомните, что вектор (atomic vector или просто atomic) – это набор (столбик) чисел в определенном порядке.\nЕсли вы привыкли из школьного курса физики считать вектора стрелочками, то не спешите возмущаться и паниковать. Представьте стрелочки как точки из нуля координат {0,0} до какой-то точки на координатной плоскости, например, {2,3}:\n\nВот последние два числа и будем считать вектором. Попытайтесь теперь мысленно стереть координатную плоскость и выбросить стрелочки из головы, оставив только последовательность чисел {2,3}:\n\nНа самом деле, мы уже работали с векторами в R, но, возможно, вы об этом даже не догадывались. Дело в том, что в R нет как таковых скалярных (т.е. одиночных) значений, есть вектора длиной 1. Такие дела!\nЧтобы создать вектор из нескольких значений, нужно воспользоваться функцией c():\n\nc(4, 8, 15, 16, 23, 42)\n\n[1]  4  8 15 16 23 42\n\nc(\"Хэй\", \"Хэй\", \"Ха\")\n\n[1] \"Хэй\" \"Хэй\" \"Ха\" \n\nc(TRUE, FALSE)\n\n[1]  TRUE FALSE\n\n\n\nОдна из самых мерзких и раздражающих причин ошибок в коде – это использование с из кириллицы вместо c из латиницы. Видите разницу? И я не вижу. А R видит. И об этом сообщает:\n\n\nс(3, 4, 5)\n\nError in с(3, 4, 5): could not find function \"с\"\n\n\nДля создания числовых векторов есть удобный оператор :.\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n5:-3\n\n[1]  5  4  3  2  1  0 -1 -2 -3\n\n\nЭтот оператор создает вектор от первого числа до второго с шагом 1. Вы не представляете, как часто эта штука нам пригодится… Если же нужно сделать вектор с другим шагом, то есть функция seq():\n\nseq(10, 100, by = 10)\n\n [1]  10  20  30  40  50  60  70  80  90 100\n\n\nКроме того, можно задавать не шаг, а длину вектора. Тогда функция seq() сама посчитает шаг:\n\nseq(1, 13, length.out = 4)\n\n[1]  1  5  9 13\n\n\nДругая функция – rep() – позволяет создавать вектора с повторяющимися значениями. Первый аргумент – значение, которое нужно повторять, а второй аргумент – сколько раз повторять.\n\nrep(1, 5)\n\n[1] 1 1 1 1 1\n\n\nИ первый, и второй аргумент могут быть векторами!\n\nrep(1:3, 3)\n\n[1] 1 2 3 1 2 3 1 2 3\n\nrep(1:3, 1:3)\n\n[1] 1 2 2 3 3 3\n\n\nЕще можно объединять вектора (что мы, по сути, и делали, просто с векторами длиной 1):\n\nv1 <- c(\"Hey\", \"Ho\")\nv2 <- c(\"Let's\", \"Go!\")\nc(v1, v2)\n\n[1] \"Hey\"   \"Ho\"    \"Let's\" \"Go!\"  \n\n\nОчень многие функции в R работают именно с векторами. Например, функции sum() (считает сумму значений вектора) и mean() (считает среднее арифметическое всех значений в векторе):\n\nsum(1:10)\n\n[1] 55\n\nmean(1:10)\n\n[1] 5.5"
  },
  {
    "objectID": "intro.html#coercion",
    "href": "intro.html#coercion",
    "title": "1  Введение в R",
    "section": "2.2 Приведение типов",
    "text": "2.2 Приведение типов\nЧто будет, если вы объедините два вектора с значениями разных типов? Ошибка?\nМы уже обсуждали, что в обычных векторах (atomic векторах) может быть только один тип данных. В некоторых языках программирования при операции с данными разных типов мы бы получили ошибку. А вот в R при несовпадении типов произойдет попытка привести типы к “общему знаменателю”, то есть конвертировать данные в более “широкий” тип (а иногда – более “узкий” тип, если того требует функция).\nНапример:\n\nc(FALSE, 2)\n\n[1] 0 2\n\n\nFALSE превратился в 0 (а TRUE превратился бы в 1), чтобы оба значения можно было объединить в вектор. То же самое произошло бы в случае операций с векторами:\n\n2 + TRUE\n\n[1] 3\n\n\nЭто называется неявным приведением типов (implicit coercion).\nВот более сложный пример:\n\nc(TRUE, 3, \"Привет\")\n\n[1] \"TRUE\"   \"3\"      \"Привет\"\n\n\nЗдесь все значения были приведены сразу к строковому типу данных.\nУ R есть иерархия приведения типов:\nNULL < raw < logical < integer < double < complex < character < list < expression.\nМы из этого списка еще многого не знаем, сейчас важно запомнить, что логические данные – TRUE и FALSE – превращаются в 0 и 1 соответственно, а 0 и 1 в строчки \"0\" и \"1\".\nЕсли Вы боитесь полагаться на приведение типов, то можете воспользоваться функциями as.нужныйтипданных для явного приведения типов (explicit coercion):\n\nas.numeric(c(TRUE, FALSE, FALSE))\n\n[1] 1 0 0\n\nas.character(as.numeric(c(TRUE, FALSE, FALSE)))\n\n[1] \"1\" \"0\" \"0\"\n\n\nМожно превращать и обратно, например, строковые значения в числовые. Если среди числа встретится буква или другой неподходящий знак, то мы получим предупреждение NA – пропущенное значение (мы очень скоро научимся с ними работать).\n\nas.numeric(c(\"1\", \"2\", \"три\"))\n\nWarning: NAs introduced by coercion\n\n\n[1]  1  2 NA\n\n\n\nОдин из распространенных примеров использования неявного приведения типов – использования функций sum() и mean() для подсчета в логическом векторе количества и доли TRUE соответсвенно. Мы будем много раз пользоваться этим приемом в дальнейшем!"
  },
  {
    "objectID": "intro.html#vector_op",
    "href": "intro.html#vector_op",
    "title": "1  Введение в R",
    "section": "2.3 Векторизация",
    "text": "2.3 Векторизация\nВсе те арифметические операторы, что мы использовали ранее, можно использовать с векторами одинаковой длины:\n\nn <- 1:4\nm <- 4:1\nn + m\n\n[1] 5 5 5 5\n\nn - m\n\n[1] -3 -1  1  3\n\nn * m\n\n[1] 4 6 6 4\n\nn / m\n\n[1] 0.2500000 0.6666667 1.5000000 4.0000000\n\nn ^ m + m * (n - m)\n\n[1] -11   5  11   7\n\n\nЕсли применить операторы на двух векторах одинаковой длины, то мы получим результат поэлементного применения оператора к двум векторам. Это называется векторизацией (vectorization).\n\nЕсли после какого-нибудь MATLAB Вы привыкли, что по умолчанию операторы работают по правилам линейной алгебры и m * n будет давать скалярное произведение (dot product), то снова нет. Для скалярного произведения нужно использовать операторы с % по краям:\n\n\nn %*% m\n\n     [,1]\n[1,]   20\n\n\n\nАбсолютно так же и с операциями с матрицами в R, хотя про матрицы будет немного позже.\n\nВ принципе, большинство функций в R, которые работают с отдельными значениями, так же хорошо работают и с целыми векторами. Скажем, если вы хотите извлечь корень из нескольких чисел, то для этого не нужны никакие циклы (как это обычно делается во многих других языках программирования). Можно просто “скормить” вектор функции и получить результат применения функции к каждому элементу вектора:\n\nsqrt(1:10)\n\n [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427\n [9] 3.000000 3.162278\n\n\nТаких векторизованных функций в R очень много. Многие из них написаны на более низкоуровневых языках программирования (C, C++, FORTRAN), за счет чего использование таких функций приводит не только к более элегантному, лаконичному, но и к более быстрому коду.\n\nВекторизация в R – это очень важная фишка, которая отличает этот язык программирования от многих других. Если вы уже имеете опыт программирования на другом языке, то вам во многих задачах захочется использовать циклы типа for и while @ref(for). Не спешите этого делать! В очень многих случаях циклы можно заменить векторизацией. Тем не менее, векторизация – это не единственный способ избавить от циклов типа for и while @ref(apply)."
  },
  {
    "objectID": "intro.html#recycling",
    "href": "intro.html#recycling",
    "title": "1  Введение в R",
    "section": "2.4 Ресайклинг",
    "text": "2.4 Ресайклинг\nДопустим мы хотим совершить какую-нибудь операцию с двумя векторами. Как мы убедились, с этим обычно нет никаких проблем, если они совпадают по длине. А что если вектора не совпадают по длине? Ничего страшного! Здесь будет работать правило ресайклинга (правило переписывания, recycling rule). Это означает, что если мы делаем операцию на двух векторах разной длины, то если короткий вектор кратен по длине длинному, короткий вектор будет повторяться необходимое количество раз:\n\nn <- 1:4\nm <- 1:2\nn * m\n\n[1] 1 4 3 8\n\n\nА что будет, если совершать операции с вектором и отдельным значением? Можно считать это частным случаем ресайклинга: короткий вектор длиной 1 будет повторятся столько раз, сколько нужно, чтобы он совпадал по длине с длинным:\n\nn * 2\n\n[1] 2 4 6 8\n\n\nЕсли же меньший вектор не кратен большему (например, один из них длиной 3, а другой длиной 4), то R посчитает результат, но выдаст предупреждение.\n\nn + c(3,4,5)\n\nWarning in n + c(3, 4, 5): longer object length is not a multiple of shorter\nobject length\n\n\n[1] 4 6 8 7\n\n\nПроблема в том, что эти предупреждения могут в неожиданный момент стать причиной ошибок. Поэтому не стоит полагаться на ресайклинг некратных по длине векторов. А вот ресайклинг кратных по длине векторов – это очень удобная штука, которая используется очень часто."
  },
  {
    "objectID": "intro.html#index_atomic",
    "href": "intro.html#index_atomic",
    "title": "1  Введение в R",
    "section": "2.5 Индексирование векторов",
    "text": "2.5 Индексирование векторов\nИтак, мы подошли к одному из самых сложных моментов. И одному из основных. От того, как хорошо вы научись с этим работать, зависит весь ваш дальнейший успех на R-поприще!\nРечь пойдет об индексировании векторов. Задача, которую Вам придется решать каждые пять минут работы в R – как выбрать из вектора (или же списка, матрицы и датафрейма) какую-то его часть. Для этого используются квадратные скобочки [] (не круглые – они для функций!).\nСамое простое – индексировать по номеру индекса, т.е. порядку значения в векторе.\n\nn <- c(0, 1, 1, 2, 3, 5, 8, 13, 21, 34)\nn[1]\n\n[1] 0\n\nn[10]\n\n[1] 34\n\n\n\nЕсли вы знакомы с другими языками программирования (не MATLAB, там все так же) и уже научились думать, что индексация с 0 – это очень удобно и очень правильно (ну или просто свыклись с этим), то в R вам придется переучиться обратно. Здесь первый индекс – это 1, а последний равен длине вектора – ее можно узнать с помощью функции length(). С обоих сторон индексы берутся включительно.\n\nС помощью индексирования можно не только вытаскивать имеющиеся значения в векторе, но и присваивать им новые:\n\nn[3] <- 20\nn\n\n [1]  0  1 20  2  3  5  8 13 21 34\n\n\nКонечно, можно использовать целые векторы для индексирования:\n\nn[4:7]\n\n[1] 2 3 5 8\n\nn[10:1]\n\n [1] 34 21 13  8  5  3  2 20  1  0\n\nn[4:6] <- 0\nn\n\n [1]  0  1 20  0  0  0  8 13 21 34\n\n\nИндексирование с минусом выдаст вам все значения вектора кроме выбранных:\n\nn[-1]\n\n[1]  1 20  0  0  0  8 13 21 34\n\nn[c(-4, -5)]\n\n[1]  0  1 20  0  8 13 21 34\n\n\nМинус здесь “выключает” выбранные значения из вектора, а не означает отсчет с конца как в Python.\nБолее того, можно использовать логический вектор для индексирования. В этом случае нужен логический вектор такой же длины:\n\nn[c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE)]\n\n[1]  0 20  0  8 21\n\n\nЛогический вектор работает здесь как фильтр: пропускает только те значения, где на соответствующей позиции в логическом векторе для индексирования содержится TRUE, и не пропускает те значения, где на соответствующей позиции в логическом векторе для индексирования содержится FALSE.\n\nНу а если эти два вектора (исходный вектор и логический вектор индексов) не равны по длине, то тут будет снова работать правило ресайклинга!\n\nn[c(TRUE, FALSE)] #то же самое - recycling rule!\n\n[1]  0 20  0  8 21\n\n\nЕсть еще один способ индексирования векторов, но он несколько более редкий: индексирование по имени. Дело в том, что для значений векторов можно (но не обязательно) присваивать имена:\n\nmy_named_vector <- c(first = 1,\n                     second = 2,\n                     third = 3)\nmy_named_vector['first']\n\nfirst \n    1 \n\n\nА еще можно “вытаскивать” имена из вектора с помощью функции names() и присваивать таким образом новые имена.\n\nd <- 1:4\nnames(d) <- letters[1:4]\nnames(d)\n\n[1] \"a\" \"b\" \"c\" \"d\"\n\nd[\"a\"]\n\na \n1 \n\n\n\nletters – это “зашитая” в R константа – вектор букв от a до z. Иногда это очень удобно! Кроме того, есть константа LETTERS – то же самое, но заглавными буквами. А еще в R есть названия месяцев на английском и числовая константа pi.\n\nВернемся к нашему вектору n и посчитаем его среднее с помощью функции mean():\n\nmean(n)\n\n[1] 9.7\n\n\nА как вытащить все значения, которые больше среднего?\nСначала получим логический вектор – какие значения больше среднего:\n\nlarger <- n > mean(n)\nlarger\n\n [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n\n\nА теперь используем его для индексирования вектора n:\n\nn[larger]\n\n[1] 20 13 21 34\n\n\nМожно все это сделать в одну строчку:\n\nn[n > mean(n)]\n\n[1] 20 13 21 34\n\n\nПредыдущая строчка отражает то, что мы будем постоянно делать в R: вычленять (subset) из данных отдельные куски на основании разных условий."
  },
  {
    "objectID": "intro.html#logic_vectors",
    "href": "intro.html#logic_vectors",
    "title": "1  Введение в R",
    "section": "2.6 Работа с логическими векторами",
    "text": "2.6 Работа с логическими векторами\nНа работе с логическими векторами построено очень много удобных фишек, связанных со сравнением условий.\n\neyes <- c(\"green\", \"blue\", \"blue\", \"brown\", \"green\", \"blue\")\n\n\n2.6.1 mean() и sum() для подсчета пропорций и количества TRUE\nУже знакомая нам функция sum() позволяет посчитать количество TRUE в логическом векторе. Например, можно удобно посчитать сколько раз значение \"blue\" встречается в векторе eyes:\n\neyes == \"blue\"\n\n[1] FALSE  TRUE  TRUE FALSE FALSE  TRUE\n\nsum(eyes == \"blue\")\n\n[1] 3\n\n\nФункцию mean() можно использовать для подсчета пропорций TRUE в логическом векторе.\n\neyes == \"blue\"\n\n[1] FALSE  TRUE  TRUE FALSE FALSE  TRUE\n\nmean(eyes == \"blue\")\n\n[1] 0.5\n\n\nУмножив на 100, мы получим долю выраженную в процентах:\n\nmean(eyes == \"blue\") * 100\n\n[1] 50\n\n\n\n\n2.6.2 all() и any()\nФункция all() выдает TRUE только когда все значения логического вектора на входе равны TRUE:\n\nall(eyes == \"blue\")\n\n[1] FALSE\n\n\nФункция any() выдает TRUE когда есть хотя бы одно значение TRUE:\n\nany(eyes == \"blue\")\n\n[1] TRUE\n\n\nВместе с оператором ! можно получить много дополнительных вариантов. Например, есть ли хотя бы один FALSE в векторе?\n\nany(!eyes == \"blue\")\n\n[1] TRUE\n\n!all(eyes == \"blue\")\n\n[1] TRUE\n\n\nВсе ли значения в векторе равны FALSE?\n\nall(!eyes == \"blue\")\n\n[1] FALSE\n\n!any(eyes == \"blue\")\n\n[1] FALSE\n\n\n\n\n2.6.3 Превращение логических значений в индексы: which()\nКак вы уже знаете, и логические векторы, и числовые вектора с индексами могут использоваться для индексирования векторов. Иногда может понадобиться превратить логический вектор в вектор индексов. Для этого есть функция which()\n\nwhich(eyes == \"blue\")\n\n[1] 2 3 6\n\n\n\n\n2.6.4 оператор %in% и match()\nЧасто возникает такая задача: нужно проверить вектор на равенство с хотя бы одним значением из другого вектора. Например, мы хотим вычленить всех зеленоглазых и голубоглазых. Может возникнуть идея сделать так:\n\neyes[eyes == c(\"green\", \"blue\")]\n\n[1] \"green\" \"blue\"  \"green\" \"blue\" \n\n\nПеред нами самый страшный случай: результат похож на правильный, но не правильный! Попытайтесь самостоятельно понять почему этот ответ неверный и что произошло на самом деле.\nА на самом деле мы просто сравнили два вектора, один из которых короче другого, следовательно, у нас сработало правило ресайклинга.\n\nКак мы видим, это совсем не то, что нам нужно! В данной ситуации нам подойдет сравнение с двумя значениями вместе с логическим ИЛИ.\n\neyes[eyes == \"green\" | eyes == \"blue\"]\n\n[1] \"green\" \"blue\"  \"blue\"  \"green\" \"blue\" \n\n\nОднако это не очень удобно, особенно если значений больше 2. Тогда на помощь приходит оператор %in%, который выполняет именно то, что нам изначально нужно: выдает для каждого значения в векторе слева, есть ли это значение среди значений вектора справа.\n\neyes[eyes %in% c(\"green\", \"blue\")]\n\n[1] \"green\" \"blue\"  \"blue\"  \"green\" \"blue\" \n\n\nОсновное преимущество оператора %in% в его простоте и понятности. У оператора %in% есть старший брат, более сложный и более мощный. Функция match() работает похожим образом на %in%, но при совпадении значения в левом векторе с одним из значений в правом выдает индекс соответствующего значения вместо TRUE. Если же совпадений нет, то вместо FALSE функция match() выдает NA (что можно поменять параметром nomatch =).\n\nmatch(eyes, c(\"green\", \"blue\"))\n\n[1]  1  2  2 NA  1  2\n\n\nЗачем это может понадобиться? Во-первых, это способ соединить два набора данных (хотя для этого есть и более подходящие инструменты), во-вторых, так можно заменить все значения кроме выбранных заменить на NA.\n\nc(\"green\", \"blue\")[match(eyes, c(\"green\", \"blue\"))]\n\n[1] \"green\" \"blue\"  \"blue\"  NA      \"green\" \"blue\""
  },
  {
    "objectID": "intro.html#na",
    "href": "intro.html#na",
    "title": "1  Введение в R",
    "section": "2.7 NA - пропущенные значения",
    "text": "2.7 NA - пропущенные значения\nВ реальных данных у нас часто чего-то не хватает. Например, из-за технической ошибки или невнимательности не получилось записать какое-то измерение. Для обозначения пропущенных значений в R есть специальное значение NA (расшифровывается как Not Available - недоступное значение). NA – это не строка \"NA\", не 0, не пустая строка \"\" и не FALSE. NA – это NA. Большинство операций с векторами, содержащими NA будут выдавать NA:\n\nmissed <- NA\nmissed == \"NA\"\n\n[1] NA\n\nmissed == \"\"\n\n[1] NA\n\nmissed == NA\n\n[1] NA\n\n\nЗаметьте, даже сравнение NA c NA выдает NA. Это может прозвучать абсурдно: ну как же так, и то NA, и другое NA – это же одно и то же, они должны быть равны! Не совсем: NA – это отсутствие информации об объекте, неопределенность, неизвестная нам величина. Если мы не знаем двух значений (т.е. имеем два NA), то это еще не значит, что они равны.\nИногда наличие NA в данных очень бесит:\n\nn[5] <- NA\nn\n\n [1]  0  1 20  0 NA  0  8 13 21 34\n\nmean(n)\n\n[1] NA\n\n\nПолучается, что наличие NA “заражает” неопределенностью все последующие действия. Что же делать?\nНаверное, надо сравнить вектор с NA и исключить этих пакостников. Давайте попробуем:\n\nn == NA\n\n [1] NA NA NA NA NA NA NA NA NA NA\n\n\nАх да, мы ведь только что узнали, что даже сравнение NA c NA приводит к NA! Сначала это может показаться нелогичным: ведь с обоих сторон NA, почему же тогда результат их сравнения – это тоже NA, а не TRUE?\nДело в том, что сравнивая две неопределенности, вы не можете установить между ними знак равенства. Представим себе двух супергероев: Бэтмена и Спайдермена. Допустим, мы не знаем их рост:\n\nBatman <- NA\nSpiderman <- NA\n\nОдинаковый ли у них рост?\n\nBatman == Spiderman\n\n[1] NA\n\n\nМы не знаем! Возможно, да, возможно, и нет. Поэтому у нас здесь остается неопределенность.\nТак как же избавиться от NA в данных? Самый простой способ – это функция is.na():\n\nis.na(n)\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n\n\nРезультат выполнения is.na(n) выдает FALSE на тех позициях, где у нас числа (или другие значения), и TRUE там, где у нас NA. Чтобы вычленить из вектора n все значения кроме NA нам нужно, чтобы было наоборот: TRUE, если это не NA, FALSE, если это NA. Здесь нам понадобится логический оператор НЕ ! (мы его уже встречали – см. @ref(data_types)), который инвертирует логические значения:\n\nn[!is.na(n)]\n\n[1]  0  1 20  0  0  8 13 21 34\n\n\nУра, мы можем считать среднее без NA!\n\nmean(n[!is.na(n)])\n\n[1] 10.77778\n\n\nТеперь Вы понимаете, зачем нужно отрицание (!)\nВообще, есть еще один из способов посчитать среднее, если есть NA. Для этого надо залезть в хэлп по функции mean():\n\n?mean()\n\nВ хэлпе мы найдем параметр na.rm =, который по умолчанию FALSE. Вы знаете, что нужно делать!\n\nmean(n, na.rm = T)\n\n[1] 10.77778\n\n\nNA может появляться в векторах разных типов. На самом деле, NA - это специальное значение в логических векторах, тогда как в векторах других типов NA появляется как NA_integer_, NA_real_, NA_complex_ или NA_character_, но R обычно сам все переводит в нужный формат и показывает как просто NA. Таким образом, NA в векторах разных типов – это разные NA, хотя на практике эта деталь обычно несущественна.\n\nКроме NA есть еще NaN – это разные вещи. NaN расшифровывается как Not a Number и получается в результате таких операций как 0 / 0. Тем не менее, функция is.na() выдает TRUE на NaN, а вот функция is.nan() выдает TRUE на NaN и FALSE на NA:\n\n\nis.na(NA)\n\n[1] TRUE\n\nis.na(NaN)\n\n[1] TRUE\n\nis.nan(NA)\n\n[1] FALSE\n\nis.nan(NaN)\n\n[1] TRUE"
  },
  {
    "objectID": "intro.html#vector_end",
    "href": "intro.html#vector_end",
    "title": "1  Введение в R",
    "section": "2.8 Заключение",
    "text": "2.8 Заключение\nИтак, с векторами мы более-менее разобрались. Помните, что вектора – это один из краеугольных камней вашей работы в R. Если вы хорошо с ними разобрались, то дальше все будет довольно несложно. Тем не менее, вектора – это не все. Есть еще два важных типа данных: списки (list) и матрицы (matrix). Их можно рассматривать как своеобразное “расширение” векторов, каждый в свою сторону. Ну а списки и матрицы нужны чтобы понять основной тип данных в R – data.frame."
  },
  {
    "objectID": "intro.html#matrix",
    "href": "intro.html#matrix",
    "title": "1  Введение в R",
    "section": "3.1 Матрица",
    "text": "3.1 Матрица\nЕсли вдруг вас пугает это слово, то совершенно зря. Матрица (matrix) – это всего лишь “двумерный” вектор: вектор, у которого есть не только длина, но и ширина. Создать матрицу можно с помощью функции matrix() из вектора, указав при этом количество строк и столбцов.\n\nA <- matrix(1:20, nrow=5,ncol=4)\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n\n\n\nЗаметьте, значения вектора заполняются следующим образом: сначала заполняется первый столбик сверху вниз, потом второй сверху вниз и так до конца, т.е. заполнение значений матрицы идет в первую очередь по вертикали. Это довольно стандартный способ создания матриц, характерный не только для R.\n\nЕсли мы знаем сколько значений в матрице и сколько мы хотим строк, то количество столбцов указывать необязательно:\n\nA <- matrix(1:20, nrow=5)\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n\n\nВсе остальное так же как и с векторами: внутри находится данные только одного типа. Поскольку матрица – это уже двумерный массив, то у него имеется два индекса. Эти два индекса разделяются запятыми.\n\nA[2,3]\n\n[1] 12\n\nA[2:4, 1:3]\n\n     [,1] [,2] [,3]\n[1,]    2    7   12\n[2,]    3    8   13\n[3,]    4    9   14\n\n\nПервый индекс – выбор строк, второй индекс – выбор колонок. Если же мы оставляем пустое поле вместо числа, то мы выбираем все строки/колонки в зависимости от того, оставили мы поле пустым до или после запятой:\n\nA[, 1:3]\n\n     [,1] [,2] [,3]\n[1,]    1    6   11\n[2,]    2    7   12\n[3,]    3    8   13\n[4,]    4    9   14\n[5,]    5   10   15\n\nA[2:4, ]\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    7   12   17\n[2,]    3    8   13   18\n[3,]    4    9   14   19\n\nA[, ]\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n\n\nТак же как и в случае с обычными векторами, часть матрицы можно переписать:\n\nA[2:4, 2:4] <- 100\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2  100  100  100\n[3,]    3  100  100  100\n[4,]    4  100  100  100\n[5,]    5   10   15   20\n\n\nВ принципе, это все, что нам нужно знать о матрицах. Матрицы используются в R довольно редко, особенно по сравнению, например, с MATLAB. Но вот индексировать матрицы хорошо бы уметь: это понадобится в работе с датафреймами.\n\nТо, что матрица – это просто двумерный вектор, не является метафорой: в R матрица – это по сути своей вектор с дополнительными атрибутами dim и (опционально) dimnames. Атрибуты – это свойства объектов, своего рода “метаданные”. Для всех объектов есть обязательные атрибуты типа и длины и могут быть любые необязательные атрибуты. Можно задавать свои атрибуты или удалять уже присвоенные: удаление атрибута dim у матрицы превратит ее в обычный вектор. Про атрибуты подробнее можно почитать здесь или на стр. 99-101 книги “R in a Nutshell” (adler2010r?)."
  },
  {
    "objectID": "intro.html#arrays",
    "href": "intro.html#arrays",
    "title": "1  Введение в R",
    "section": "3.2 Массив",
    "text": "3.2 Массив\nДва измерения – это не предел! Структура с одним типом данных внутри, но с тремя измерениями или больше, называется массивом (array). Создание массива очень похоже на создание матрицы: задаем вектор, из которого будет собран массив, и размерность массива.\n\narray_3d <- array(1:12, c(3, 2, 2))\narray_3d\n\n, , 1\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n, , 2\n\n     [,1] [,2]\n[1,]    7   10\n[2,]    8   11\n[3,]    9   12"
  },
  {
    "objectID": "intro.html#list",
    "href": "intro.html#list",
    "title": "1  Введение в R",
    "section": "3.3 Список",
    "text": "3.3 Список\nТеперь представим себе вектор без ограничения на одинаковые данные внутри. И получим список (list)!\n\nsimple_list <- list(42, \"Пам пам\", TRUE)\nsimple_list\n\n[[1]]\n[1] 42\n\n[[2]]\n[1] \"Пам пам\"\n\n[[3]]\n[1] TRUE\n\n\nА это значит, что там могут содержаться самые разные данные, в том числе и другие списки и векторы!\n\ncomplex_list <- list(c(\"Wow\", \"this\", \"list\", \"is\", \"so\", \"big\"), \"16\", simple_list)\ncomplex_list\n\n[[1]]\n[1] \"Wow\"  \"this\" \"list\" \"is\"   \"so\"   \"big\" \n\n[[2]]\n[1] \"16\"\n\n[[3]]\n[[3]][[1]]\n[1] 42\n\n[[3]][[2]]\n[1] \"Пам пам\"\n\n[[3]][[3]]\n[1] TRUE\n\n\nЕсли у нас сложный список, то есть очень классная функция, чтобы посмотреть, как он устроен, под названием str():\n\nstr(complex_list)\n\nList of 3\n $ : chr [1:6] \"Wow\" \"this\" \"list\" \"is\" ...\n $ : chr \"16\"\n $ :List of 3\n  ..$ : num 42\n  ..$ : chr \"Пам пам\"\n  ..$ : logi TRUE\n\n\n\nПредставьте, что список - это такое дерево с ветвистой структурой. А на конце этих ветвей - листья-векторы.\n\nКак и в случае с векторами мы можем давать имена элементам списка:\n\nnamed_list <- list(age = 24, PhDstudent = T, language = \"Russian\")\nnamed_list\n\n$age\n[1] 24\n\n$PhDstudent\n[1] TRUE\n\n$language\n[1] \"Russian\"\n\n\nК списку можно обращаться как с помощью индексов, так и по именам. Начнем с последнего:\n\nnamed_list$age\n\n[1] 24\n\n\nА вот с индексами сложнее, и в этом очень легко запутаться. Давайте попробуем сделать так, как мы делали это раньше:\n\nnamed_list[1]\n\n$age\n[1] 24\n\n\nМы, по сути, получили элемент списка – просто как часть списка, т.е. как список длиной один:\n\nclass(named_list)\n\n[1] \"list\"\n\nclass(named_list[1])\n\n[1] \"list\"\n\n\nА вот чтобы добраться до самого элемента списка (и сделать с ним что-то хорошее), нам нужна не одна, а две квадратных скобочки:\n\nnamed_list[[1]]\n\n[1] 24\n\nclass(named_list[[1]])\n\n[1] \"numeric\"\n\n\n\n\nIndexing lists in #rstats. Inspired by the Residence Inn pic.twitter.com/YQ6axb2w7t\n\n— Hadley Wickham ((hadleywickham?)) September 14, 2015\n\n\nКак и в случае с вектором, к элементу списка можно обращаться по имени.\n\nnamed_list[['age']]\n\n[1] 24\n\n\nХотя последнее – практически то же самое, что и использование знака $.\n\nСписки довольно часто используются в R, но реже, чем в Python. Со многими объектами в R, такими как результаты статистических тестов, удобно работать именно как со списками – к ним все вышеописанное применимо. Кроме того, некоторые данные мы изначально получаем в виде древообразной структуры – хочешь не хочешь, а придется работать с этим как со списком. Но обычно после этого стоит как можно скорее превратить список в датафрейм."
  },
  {
    "objectID": "intro.html#df",
    "href": "intro.html#df",
    "title": "1  Введение в R",
    "section": "3.4 Датафрейм",
    "text": "3.4 Датафрейм\nИтак, мы перешли к самому главному. Самому-самому. Датафреймы (data.frames). Более того, сейчас станет понятно, зачем нам нужно было разбираться со всеми предыдущими темами.\nБез векторов мы не смогли бы разобраться с матрицами и списками. А без последних мы не сможем понять, что такое датафрейм.\n\nname <- c(\"Petr\", \"Eugeny\", \"Lena\", \"Misha\", \"Sasha\") \nage <- c(26, 34, 23, 27, 26) \nstudent <- c(F, F, T, T, T) \ndf <- data.frame(name, age, student)  \ndf\n\n    name age student\n1   Petr  26   FALSE\n2 Eugeny  34   FALSE\n3   Lena  23    TRUE\n4  Misha  27    TRUE\n5  Sasha  26    TRUE\n\nstr(df)\n\n'data.frame':   5 obs. of  3 variables:\n $ name   : chr  \"Petr\" \"Eugeny\" \"Lena\" \"Misha\" ...\n $ age    : num  26 34 23 27 26\n $ student: logi  FALSE FALSE TRUE TRUE TRUE\n\n\nВообще, очень похоже на список, не правда ли? Так и есть, датафрейм – это что-то вроде проименованного списка, каждый элемент которого является atomic вектором фиксированной длины. Скорее всего, вы представляли список “горизонтально”. Если это так, то теперь “переверните” список у себя в голове на 90 градусов. Так, чтобы названия векторов оказались сверху, а элементы списка стали столбцами. Поскольку длина всех этих векторов одинаковая (обязательное условие!), то данные представляют собой табличку, похожую на матрицу. Но в отличие от матрицы, разные столбцы могут иметь разные типы данных. В нашем случае первая колонка – character, вторая колонка – numeric, третья колонка – logical. Тем не менее, обращаться с датафреймом можно и как с проименованным списком, и как с матрицей:\n\ndf$age[2:3]\n\n[1] 34 23\n\n\nЗдесь мы сначала ивлекли колонку age с помощью оператора $. Результатом этой операции является числовой вектор, из которого мы вытащили кусок, выбрав индексы 2 и 3.\nИспользуя оператор $ и присваивание можно создавать новые колонки датафрейма:\n\ndf$lovesR <- TRUE #правило recycling - узнали? \ndf\n\n    name age student lovesR\n1   Petr  26   FALSE   TRUE\n2 Eugeny  34   FALSE   TRUE\n3   Lena  23    TRUE   TRUE\n4  Misha  27    TRUE   TRUE\n5  Sasha  26    TRUE   TRUE\n\n\nНу а можно просто обращаться с помощью двух индексов через запятую, как мы это делали с матрицей:\n\ndf[3:5, 2:3]\n\n  age student\n3  23    TRUE\n4  27    TRUE\n5  26    TRUE\n\n\nКак и с матрицами, первый индекс означает строчки, а второй – столбцы.\nА еще можно использовать названия колонок внутри квадратных скобок:\n\ndf[1:2, \"age\"]\n\n[1] 26 34\n\n\nИ здесь перед нами открываются невообразимые возможности! Узнаем, любят ли R те, кто моложе среднего возраста в группе:\n\ndf[df$age < mean(df$age), 4]\n\n[1] TRUE TRUE TRUE TRUE\n\n\nЭту же задачу можно выполнить другими способами:\n\ndf$lovesR[df$age < mean(df$age)]\n\n[1] TRUE TRUE TRUE TRUE\n\ndf[df$age < mean(df$age), 'lovesR']\n\n[1] TRUE TRUE TRUE TRUE\n\n\nВ большинстве случаев подходят сразу несколько способов – тем не менее, стоит овладеть ими всеми.\nДатафреймы удобно просматривать в RStudio. Для это нужно написать команду View(df) или же просто нажать на названии нужной переменной из списка вверху справа (там где Environment). Тогда увидите табличку, очень похожую на Excel и тому подобные программы для работы с таблицами. Там же есть и всякие возможности для фильтрации, сортировки и поиска 9.\n\nНо, конечно, интереснее все эти вещи делать руками, т.е. с помощью написания кода."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Анализ данных и статистика в R",
    "section": "",
    "text": "Здесь будут материалы для курса “Анализ данных и статистика в R”. Эта онлайн-книжка написана с помощью quatro и пакета {bookdown}, здесь можно посмотреть код с материалами. Эта книга будет постоянно пополняться, поэтому следите за обновлениями!\nПо всем вопросам пишите на мне на почту ivanspozdniakov@gmail.com, VK или в Telegram:@pozdniakovivan."
  },
  {
    "objectID": "250-rmarkdown.html",
    "href": "250-rmarkdown.html",
    "title": "9  R Markdown",
    "section": "",
    "text": "После подсчета описательных статитистик, создания графиков и, в особенности, интерактивных визуализаций, возникает вопрос о том, как представить полученные результаты.\nR Markdown представляет такую возможность. С помощью R Markdown в документе можно совмещать код, результаты его исполнения и написанный текст. Кроме того, можно вставлять картинки, ссылки, видео и многое другое. В чем-то R Markdown напоминает Jupyter Notebook знакомый всем питоноводом, но это сходство, скорее, функциональное (и то, и то позволяет превращать сухой текст скрипта в красивый документ), их устройство значительно различается.\nR Markdown представляет собой текстовый документ специального формата .Rmd, который можно скомпилировать в самые различные документы:\n\nДокументы в форматах Word, ODT, RTF, PDF (с использованием LaTeX), HTML, в том числе:\n\nОнлайн-книги (bookdown)\nНаучные статьи (papaja)\n\nПрезентации в виде HTML (ioslides, Slidy, revealjs, rmdshower, Beamer)\nВеб-сайты (blogdown)\nДашборды (flexdashboard)\n\nФормат вывода легко настроить и поменять по ходу работы, что позволяет гибко изменять формат документа на выходе."
  },
  {
    "objectID": "250-rmarkdown.html#rmd_begin",
    "href": "250-rmarkdown.html#rmd_begin",
    "title": "9  R Markdown",
    "section": "9.2 Начало работы в R Markdown",
    "text": "9.2 Начало работы в R Markdown\nДля работы с R Markdown у RStudio есть специальные инструменты, которые позволяют не только удобно писать и компилировать R Markdown документы, но и превращают R Markdown в удобную среду для работы с R вместо обычных R-скриптов.\nЧтобы начать работать с R Markdown, нужно создать новый .Rmd файл с помощью File - New File - R Markdown... Перед вами появится меню выбора формата R Markdown документа, названия и имени автора.\n\n\n\nМеню выбора формата R Markdown документа\n\n\nВыбирайте что угодно, все это можно потом изменить вручную.\nЕсли пакет rmarkdown у вас еще не установлен, то он будет автоматически установлен. Кроме того, если вы выбрали в качестве формата PDF (презентацию или документ), то вам понадобится еще установить LaTeX на компьютер. Это тоже можно сделать с помощью специального пакета:\n\ninstall.packages('tinytex')\ntinytex::install_tinytex()  # install TinyTeX\n\n.Rmd файл, который вы создадите таким образом, будет создан из шаблона, который демонстрирует основной функционал R Markdown. В отличие от работы с R скриптом, перед вами будет немного другой набор кнопок. Самая важная из новых кнопок — это кнопка Knit (с клубком и спицей рядом), нажав на которую, начнется “вязание” (knitting) финального документа, то есть его компиляция. Если компиляция завершится успешно, то перед вами появится скомпилированный документ в том формате, который вы выбрали."
  },
  {
    "objectID": "250-rmarkdown.html#rmd_str",
    "href": "250-rmarkdown.html#rmd_str",
    "title": "9  R Markdown",
    "section": "9.3 Структура R Markdown документа",
    "text": "9.3 Структура R Markdown документа\nR Markdown документ состоит из трех базовых элементов:\n\nYAML-шапки 1\nТекста с использованием разметки Markdown\nЧанков (chunks) с кодом\n\nРазберем их по порядку.\n\nYAML-шапка находится в самом верху документа и отделена тремя дефисами (---) сверху и снизу. В нем содержится, во-первых, мета-информация о документе, которая будет отображена на титульном листе/слайде, во-вторых, информация о формате документа, который будет “связан”. Пример YAML-шапки:\n\n\n---\ntitle: \"Классное название для документа\"\nauthor: \"Поздняков Иван\"\ndate: \"15 11 2020\"\noutput: html_document\n---\n\nТекст с использование синтаксиса Markdown идет сразу после YAML-шапки и составляет основную часть .Rmd документа. Markdown (не путать с R Markdown!) — это популярный и очень удобный язык разметки. Markdown используется повсюду: в ReadMe страницах на GitHub, как способ ведения записей во многих программах для заметок и даже в Telegram! Например, вот так можно задавать полужирный шрифт и курсив:\n\n\nВот так мы делаем **полужирный**, а вот так мы делаем *курсив.*\nВ результате мы получим следующую строчку:\nВот так мы делаем полужирный, а вот так мы делаем курсив.\nДалее мы разберем подробнее синтаксис Markdown.\n\nЧанки с кодом содержат в себе код на языке R или другом языке программирования, которые будут исполнены, а результат которых будет отображен прямо под чанком с кодом. Чанк с кодом отделяется ``` с обоих сторон и содержит {r}. Это означает, что внутри находится код на R, который должен быть выполнен:\n\n```{r}\n2+2\n```\nВ итоговом документе чанк будет выглядеть так:\n\n2+2\n\n[1] 4"
  },
  {
    "objectID": "250-rmarkdown.html#chunk",
    "href": "250-rmarkdown.html#chunk",
    "title": "9  R Markdown",
    "section": "9.4 Настройки чанка",
    "text": "9.4 Настройки чанка\nУ чанка с кодом есть набор настроек. Самый важные из них такие:\n\necho: будет ли показан сам код\nmessage и warning: будут ли показаны сообщения и предупреждения, всплывающие во время исполнения кода\neval: будет ли испольняться код внутри чанка\n\n\n9.4.1 Настройка нескольких чанков\nВсе эти настройки можно настроить как для отдельных чанков, так и для все чанков сразу:\n\nknitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)\n\nЭтот чанк нужно вставлять в начале .Rmd документа, тогда выбранные настройки повлияют на все последующие чанки.\n\n\n9.4.2 Чанки с Python и другими языками программирования\nМожно вставлять чанки с кодом на других языках программирования! Для этого вместо {r} нужно написать {python}.\n\nx = 'hello, python !'\nprint (x.split(\" \"))\n\nВот полный список поддерживаемых языков:\n\nnames(knitr::knit_engines$get())\n\n [1] \"awk\"       \"bash\"      \"coffee\"    \"gawk\"      \"groovy\"    \"haskell\"  \n [7] \"lein\"      \"mysql\"     \"node\"      \"octave\"    \"perl\"      \"psql\"     \n[13] \"Rscript\"   \"ruby\"      \"sas\"       \"scala\"     \"sed\"       \"sh\"       \n[19] \"stata\"     \"zsh\"       \"highlight\" \"Rcpp\"      \"tikz\"      \"dot\"      \n[25] \"c\"         \"cc\"        \"fortran\"   \"fortran95\" \"asy\"       \"cat\"      \n[31] \"asis\"      \"stan\"      \"block\"     \"block2\"    \"js\"        \"css\"      \n[37] \"sql\"       \"go\"        \"python\"    \"julia\"     \"sass\"      \"scss\"     \n[43] \"R\"         \"bslib\"     \"ojs\"       \"mermaid\"   \"include\"  \n\n\n\n\n9.4.3 Код вне чанков (inline code)\nИногда хочется вставить результат расчетов прямо в текст. Для этого нужно поставить символ ` с обоих краев команды и написать r перед самой командой. В этом случае результат выполнения этой команды будет в тексте вместо этой конструкции.\nЧисло пи равно ` r pi `:\nЧисло пи равно 3.1415927"
  },
  {
    "objectID": "250-rmarkdown.html#md",
    "href": "250-rmarkdown.html#md",
    "title": "9  R Markdown",
    "section": "9.5 Синтаксис Markdown (без R)",
    "text": "9.5 Синтаксис Markdown (без R)\nВ RStudio есть подсказка по синтаксису Markdown, для ее вызова нужно нажать Help - Markdown Quick Reference\n\n9.5.1 Выделение текста\nВыделение текста происходит с помощью обособления текста специальными символами:\n*Курсив* \n_Тоже курсив_\n**Полужирный**\n__Тоже полужирный__\n~~перечеркнутый~~\nиндекс^надстрочный^\nиндекс~подстрочный~\nКурсив Тоже курсив Полужирный Тоже полужирный перечеркнутый индекснадстрочный индексподстрочный\n\n\n9.5.2 Заголовки разных уровней\nС помощью решенточек (#) выделяются заголовки разных уровней.\n# Самый верхний заголовок\n\n## Заголовок второго уровня\n\n### Мне заголовок\n\n#### И моему сыну тоже\n\n##### И моему!\n\n###### Все, дальше опускаться некуда\n\n\n9.5.3 Списки\nСписки можно создавать по-разному, в зависимости от того, является ли список пронумерованным:\n* Первый вариант списка выглядит так:  \n    + Можно и с подсписком\n    + Почему бы и нет?\n\n1. Кому нужен порядок\n2. Тот списки номерует\n\nПервый вариант списка выглядит так:\n\nМожно и с подсписком\nПочему бы и нет?\n\n\n\nКому нужен порядок\nТот списки номерует\n\n\n\n9.5.4 Цитаты\nЦитаты выделяются с помощью знака > в начале строки.\n> Я устал  \n> Который год во мне живет нарвал\n\nЯ устал\nКоторый год во мне живет нарвал\n\n\n\n9.5.5 Таблицы\nТабличные данные имеют особое значение в R, в R Markdown им тоже уделяется особое внимание.\nДля начала подгрузим данные о супергероях:\n\nlibrary(\"tidyverse\")\nheroes <- read_csv(\"https://raw.githubusercontent.com/Pozdniakov/tidy_stats/master/data/heroes_information.csv\",\n                   na = c(\"-\", \"-99\"))\n\nФункция knitr::kable() превращает табличные данные (матрицы, датафреймы) в текст, отформатированный как Markdown-таблицы. Таким образом, вот такая таблица:\n\nknitr::kable(heroes[1:3, 1:4])\n\nПревращается вот в такую, отформатированную с помощью символов -, | и т.п.:\n| X1|name       |Gender |Eye color |\n|--:|:----------|:------|:---------|\n|  0|A-Bomb     |Male   |yellow    |\n|  1|Abe Sapien |Male   |blue      |\n|  2|Abin Sur   |Male   |blue      |\nА эта таблица, в свою очередь, превращается в такую в финальном документе:\n\n\n\nX1\nname\nGender\nEye color\n\n\n\n\n0\nA-Bomb\nMale\nyellow\n\n\n1\nAbe Sapien\nMale\nblue\n\n\n2\nAbin Sur\nMale\nblue\n\n\n\nЕсли вам нужно самостоятельно отформатировать таблицу в Markdown, то для этого есть специальный ресурс.\nПакет knitr является ключевым для R Markdown, поэтому он устанавливается вместе с rmarkdown. А вот для дополнительной настройки вывода таблиц рекомендуется пакет kableExtra."
  },
  {
    "objectID": "250-rmarkdown.html#extra_rmd",
    "href": "250-rmarkdown.html#extra_rmd",
    "title": "9  R Markdown",
    "section": "9.6 Дополнительные возможности R Markdown",
    "text": "9.6 Дополнительные возможности R Markdown\n\n9.6.1 Динамические таблицы\nОдин из самых интересных HTML-виджетов (@ref(htmlwidgets)) — пакет DT для создания интерактивных таблиц прямо внутри HTML-документа.\n\nlibrary(tidyverse)\nheroes <- read_csv(\"https://raw.githubusercontent.com/Pozdniakov/tidy_stats/master/data/heroes_information.csv\",\n                   na = c(\"-\", \"-99\"))\nDT::datatable(heroes)\n\n\n\n\n\n\n\n\n9.6.2 Графики в R Markdown\nВсе создаваемые графики будут появляться под чанком с кодом.\n\nheight_weight_gg <- heroes %>%\n  mutate(Publisher = ifelse(Publisher %in% c(\"Marvel Comics\", \"DC Comics\"), \n                            Publisher,\n                            \"Other publishers\")) %>%\n  filter(Weight < 700 & Height < 400) %>%\n  ggplot(aes(x = Height, y = Weight)) +\n  geom_point(aes(colour = Gender), alpha = 0.5) +\n  coord_fixed() +\n  facet_wrap(~Publisher)+\n  theme_minimal()\nheight_weight_gg\n\n\n\n\nЭто так же относится и к динамическим визуализациям с помощью HTML-виджетов (@ref(htmlwidgets)), например, plotly.\n\nlibrary(plotly)\nggplotly(height_weight_gg)\n\n\n\n\n\nКонечно, чтобы эта интерактивность сохранилась, используемый формат итогового документа должен ее поддерживать. Word-документы, так же как и PDF-документы, — статичны, поэтому единственный вариант сохранить интерактивные элементы — это использование HTML-документов или HTML-презентаций.\n\n\n9.6.3 HTML-код\nЕсли вы выбрали HTML форматом итогового документа, то можете использовать все его фишки, включая форматирование с помощью HTML-тегов (в дополнение к обычному Markdown). Еще вы можете вставлять куски HTML-кода, например, вставить видео с YouTube или отдельный пост из Twitter.\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/5qap5aO4i9A\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>"
  },
  {
    "objectID": "030-import_data.html",
    "href": "030-import_data.html",
    "title": "3  Импорт и экспорт данных",
    "section": "",
    "text": "Итак, пришло время перейти к реальным данным. Мы начнем с использования датасета (так мы будем называть любой набор данных) по супергероям. Этот датасет представляет собой табличку, каждая строка которой - отдельный супергерой, а столбик — какая-либо информация о нем. Например, цвет глаз, цвет волос, вселенная супергероя1, рост, вес, пол и так далее. Несложно заметить, что этот датасет идеально подходит под структуру датафрейма: прямоугольная табличка, внутри которой есть разные колонки, каждая из которой имеет свой тип (числовой или строковый)."
  },
  {
    "objectID": "030-import_data.html#wd",
    "href": "030-import_data.html#wd",
    "title": "3  Импорт и экспорт данных",
    "section": "3.1 Рабочая папка и проекты RStudio",
    "text": "3.1 Рабочая папка и проекты RStudio\nДля начала скачайте файл по ссылке\nОн, скорее всего, появился у Вас в папке “Загрузки”. Если мы будем просто пытаться прочитать этот файл (например, с помощью read.csv() — мы к этой функцией очень скоро перейдем), указав его имя и разрешение, то наткнемся на такую ошибку:\n\nread.csv(\"heroes_information.csv\")\n\nWarning in file(file, \"rt\"): cannot open file 'heroes_information.csv': No such\nfile or directory\n\n\nError in file(file, \"rt\"): cannot open the connection\n\n\nЭто означает, что R не может найти нужный файл. Вообще-то мы даже не сказали, где искать. Нам нужно как-то совместить место, где R ищет загружаемые файлы и сами файлы. Для этого есть несколько способов.\n\nМагомет идет к горе: перемещение файлов в рабочую папку.\n\nДля этого нужно узнать, какая папка является рабочей с помощью функции getwd() (без аргументов), найти эту папку в проводнике и переместить туда файл. После этого можно использовать просто название файла с разрешением:\n\nheroes <- read.csv(\"heroes_information.csv\")\n\nКроме того, путь к рабочей папке можно увидеть в RStudio во вкладке с консолью, в самой верхней части (прямо под надписью “Console”):\n\n\nГора идет к Магомету: изменение рабочей папки.\n\nМожно просто сменить рабочую папку с помощью setwd() на ту, где сейчас лежит файл, прописав путь до этой папки. Теперь файл находится в рабочей папке:\n\nheroes <- read.csv(\"heroes_information.csv\")\n\nЭтот вариант использовать не рекомендуется! Как минимум, это сразу делает невозможным запустить скрипт на другом компьютере. Ну а если все-таки вдруг повезет и получится, то ваш коллега будет очень недоволен, что ваш скрипт изменяет рабочую директорию.\n\nГора находит Магомета по месту прописки: указание полного пути файла.\n\n\nheroes <- read.csv(\"/Users/Username/Some_Folder/heroes_information.csv\")\n\nЭтот вариант страдает теми же проблемами, что и предыдущий, поэтому тоже не рекомендуется!\n\nДля пользователей Windows есть дополнительная сложность: знак / является особым знаком для R, поэтому вместо него нужно использовать двойной //.\n\n\nМагомет использует кнопочный интерфейс: Import Dataset.\n\nВо вкладке Environment справа в окне RStudio есть кнопка “Import Dataset”. Возможно, у Вас возникло непреодолимое желание отдохнуть от написания кода и понажимать кнопочки — сопротивляйтесь этому всеми силами, но не вините себя, если не сдержитесь.\n\nГора находит Магомета в интернете.\n\nМногие функции в R, предназначенные для чтения файлов, могут прочитать файл не только на Вашем компьютере, но и сразу из интернета. Для этого просто используйте ссылку вместо пути:\n\nheroes <- read.csv(\"https://raw.githubusercontent.com/agricolamz/2020-2021-ds4dh/master/data/heroes_information.csv\")\n\n\nКаждый Магомет получает по своей горе: использование проектов в RStudio.\n\nНа первый взгляд это кажется чем-то очень сложным, но это не так. Это очень просто и ОЧЕНЬ удобно. При создании проекта создается отдельная папка, где у вас лежат данные, хранятся скрипты, вспомогательные файлы и отчеты. Кроме папки создается файл формата .Rproj, в котором хранятся настройки проекта. Если нужно вернуться к другому проекту — просто открываете другой проект, с другими файлами и скриптами. Можно даже иметь открытыми несколько окон RStudio таким образом. Это еще помогает не пересекаться переменным из разных проектов — а то, знаете, использование двух переменных data в разных скриптах чревато ошибками. Поэтому очень удобным решением будет выделение отдельного проекта под этот курс.\n\nПри закрытии проекта все переменные по умолчанию тоже будут сохраняться, а при открытии — восстанавливаться (а вот пакеты все равно придется подгружать заново). Это очень удобно, хотя некоторые рекомендуют от этого отказаться. Это можно сделать во вкладке Tool - Global Options..."
  },
  {
    "objectID": "030-import_data.html#project_workflow",
    "href": "030-import_data.html#project_workflow",
    "title": "3  Импорт и экспорт данных",
    "section": "3.2 Организация проектов",
    "text": "3.2 Организация проектов\nДаже если не пользоваться проектами RStudio (но я настоятельно рекомендую, это очень удобно), то все равно имеет смысл разделять различные свои проекты по отдельным папкам. Для небольших проектов этого уже может быть достаточно, но я рекомендую делать немного более сложную структуру папок внутри проекта. Например, такую:\n.\n└── my_project \n    ├── R \n    ├── data\n    │   ├── raw\n    │   ├── temp\n    │   └── processed\n    ├── figures\n    ├── main_script.R \n    ├── my_project.Rproj\n    ├── output\n    └── README.txt\nВ основной папке содержится автоматически созданный RStudio файл .Rproj, основной скрипт с формат .R (или же это может быть .Rmd файл — см. @ref(rmd)). Вспомогательные скрипты (например, с функциями) могут храниться в папке R. Если скриптов несколько, то их порядок стоит обозначить числами:\n.\n├── 01_first_script_preposcessing.R\n├── 02_second_script_statistics.R\n└── 03_third_script_figures.R \nДанные стоит держать в отдельной папке, причем в некоторых ситуациях вы захотите создать отдельные подпапки, например, отдельные подпапки для данных на входе, временных файлов и данных на выходе. Результаты работы, например, отчеты, сгенерированные с помощью R Markdown (см. @ref(rmd)). Туда же можно поместить папку с графиками или же можно поместить эту папку в корневую директорию.\nЭто лишь пример структуры организации проектов, детали могут различаться, но такая структура позволит не заблудиться в собственных файлах, если тех накопилось достаточно много. Кроме того, другому человеку в такой структуре проекта будет разобраться значительно проще\nПри создании папок внутри основного проекта важно помнить о том, что теперь ваши файлы больше нельзя найти в вашей корневой директории: нужно искать их в соответствующих папках. Это значит, что путь до файла теперь будет не \"heroes_information.csv\", а \"data/heroes_information.csv\" или даже \"data/raw/heroes_information.csv\".\nПакет {here} позволяет удобно работать с путями на любых операционных системах, создавая путь в зависимости от вашей корневой директории проекта.\n\nhere::here(\"data\", \"heroes_information.csv\")\n\n[1] \"/Users/ivan/R/tidy_stats2/data/heroes_information.csv\"\n\n\nСозданный путь можно использовать для чтения файлов:\n\nheroes <- read.csv(here::here(\"data\", \"heroes_information.csv\"))\n\nСами скрипты тоже лучше разделять на смысловые части. Для этого есть горячие клавиши Cmd + Shift + R. Это сочетание клавиш выведет окно, в котором вам нужно вписать название, после чего появится вот такой аккуратный комментарий:\n\n# Meaningful part of the script -------------------------------------------\n\nРазделенный на такие части скрипт (да еще и с подробными комментариями) гораздо удобнее читать!\n\n3.2.1 Табличные данные: текстовые и бинарные данные\nКак Вы уже поняли, импортирование данных - одна из самых муторных и неприятных вещей в R. Если у Вас получится с этим справится, то все остальное - ерунда. Мы уже разобрались с первой частью этого процесса - нахождением файла с данными, осталось научиться их читать.\nЗдесь стоит сделать небольшую ремарку. Довольно часто данные представляют собой табличку. Или же их можно свести к табличке. Такая табличка, как мы уже выяснили, удобно репрезентируется в виде датафрейма. Но как эти данные хранятся на компьютере? Есть два варианта: в бинарном и в текстовом файле.\nТекстовый файл означает, что такой файл можно открыть в программе “Блокнот” или аналоге (например, TextEdit на macOS) и увидеть напечатанный текст: скрипт, роман или упорядоченный набор цифр и букв. Нас сейчас интересует именно последний случай. Таблица может быть представлена как текст: отдельные строчки в файле будут разделять разные строчки таблицы, а какой-нибудь знак-разделитель отделять колонки друг от друга.\nДля чтения данных из текстового файла есть довольно удобная функция read.table(). Почитайте хэлп по ней и ужаснитесь: столько разных параметров на входе! Но там же вы увидете функции read.csv(), read.csv2() и некоторые другие — по сути, это тот же read.table(), но с другими параметрами по умолчанию, соответствующие формату файла, который мы загружаем. В данном случае используется формат .csv, что означает “Comma Separated Values” (Значения, Разделенные Запятыми). Формат .csv — это самый известный способ хранения табличных данных в файде на сегодняшний день. Файлы с расширением .csv можно легко открыть в любой программе, работающей с таблицами, в том числе Microsoft Excel и его аналогах.\nФайл с расширением .csv — это просто текстовый файл, в котором “закодирована” таблица: разные строчки разделяют разные строчки таблицы, а столбцы отделяются запятыми (отсюда и название). Вы можете вручную создать такие файлы в Блокноте и сохранять их с форматом .csv - и такая табличка будет нормально открываться в Microsoft Excel и других программах для работы с таблицами. Можете попробовать это сделать самостоятельно!\nКак говорилось ранее, в качестве разделителя ячеек по горизонтали — то есть разделителя между столбцами — используется запятая. С этим связана одна проблема: в некоторых странах (в т.ч. и России) принято использовать запятую для разделения дробной части числа, а не точку, как это делается в большинстве стран мира. Поэтому есть альтернативный вариант формата .csv, где значения разделены точкой с запятой (;), а дробные значения - запятой (,). В этом и различие функций read.csv() и read.csv2() — первая функция предназначена для “международного” формата, вторая - для (условно) “Российского”. Оба варианта формата имеют расширение .csv, поэтому заранее понять какой именно будет вариант довольно сложно, приходится либо пробовать оба, либо заранее открывать файл в текстовом редакторе.\nВ первой строчке обычно содержатся названия столбцов - и это чертовски удобно, функции read.csv() и read.csv2() по умолчанию считают первую строчку именно как название для колонок.\nКроме .csv формата есть и другие варианты хранения таблиц в виде текста. Например, .tsv — тоже самое, что и .csv, но разделитель - знак табуляции. Для чтения таких файлов есть функция read.delim() и read.delim2(). Впрочем, даже если бы ее и не было, можно было бы просто подобрать нужные параметры для функции read.table(). Есть даже функции, которые пытаются сами “угадать” нужные параметры для чтения — часто они справляются с этим довольно удачно. Но не всегда. Поэтому стоит научиться справляться с любого рода данными на входе.\nИтак, прочитаем наш файл. Для этого используем только параметр file =, который идет первым, и для параметра stringsAsFactors = поставим значение FALSE:\n\nheroes <- read.csv(\"data/heroes_information.csv\", stringsAsFactors = FALSE)\n\n\nПараметр stringsAsFactors = задает то, как будут прочитаны строковые значения - как уже знакомые нам строки или как факторы. По сути, факторы - это примерно то же самое, что и character, но закодированные числами. Когда-то это было придумано для экономии используемых времени и памяти, сейчас же обычно становится просто лишней морокой. Но некоторые функции требуют именно character, некоторые factor, в большинстве случаев это без разницы. Но иногда непонимание может привести к дурацким ошибкам. В данном случае мы просто пока обойдемся без факторов. Если у вас версия R выше 4.0.0, то stringsAsFactors = будет FALSE по умолчанию.\n\nМожете проверить с помощью View(heroes): все работает! Если же вылезает какая-то странная ерунда или же просто ошибка - попробуйте другие функции (read.table(), read.delim()) и покопаться с параметрами. Для этого читайте Help."
  },
  {
    "objectID": "030-import_data.html#check_imported",
    "href": "030-import_data.html#check_imported",
    "title": "3  Импорт и экспорт данных",
    "section": "3.3 Проверка импортированных данных",
    "text": "3.3 Проверка импортированных данных\nПри импорте данных обратите внимания на предупреждения (если таковые появляются), в большинстве случаев они указывают на то, что данные импортированы некорректно.\nПроверим, что все прочиталось нормально с помощью уже известной нам функции str():\n\nstr(heroes)\n\n'data.frame':   734 obs. of  11 variables:\n $ X         : int  0 1 2 3 4 5 6 7 8 9 ...\n $ name      : chr  \"A-Bomb\" \"Abe Sapien\" \"Abin Sur\" \"Abomination\" ...\n $ Gender    : chr  \"Male\" \"Male\" \"Male\" \"Male\" ...\n $ Eye.color : chr  \"yellow\" \"blue\" \"blue\" \"green\" ...\n $ Race      : chr  \"Human\" \"Icthyo Sapien\" \"Ungaran\" \"Human / Radiation\" ...\n $ Hair.color: chr  \"No Hair\" \"No Hair\" \"No Hair\" \"No Hair\" ...\n $ Height    : num  203 191 185 203 -99 193 -99 185 173 178 ...\n $ Publisher : chr  \"Marvel Comics\" \"Dark Horse Comics\" \"DC Comics\" \"Marvel Comics\" ...\n $ Skin.color: chr  \"-\" \"blue\" \"red\" \"-\" ...\n $ Alignment : chr  \"good\" \"good\" \"good\" \"bad\" ...\n $ Weight    : int  441 65 90 441 -99 122 -99 88 61 81 ...\n\n\n\nВсегда проверяйте данные на входе и никогда не верьте на слово, если вам говорят, что данные вычищенные и не содержат никаких ошибок.\n\nНа что нужно обращать внимание?\n\nПрочитаны ли пропущенные значения как NA. По умолчанию пропущенные значения обозначаются пропущенной строчкой или “NA”, но встречаются самые разнообразные варианты. Возможные варианты кодирования пропущенных значений можно задать в параметре na.strings = функции read.table() и ее вариантов. В нашем датасете как раз такая ситуация, где нужно самостоятельно задавать, какие значения будут прочитаны как NA. Попытайтесь самостоятельно догадаться, как именно.\nПрочитаны ли те столбики, которые должны быть числовыми, как int или num. Если в колонке содержатся числа, а написано chr (= \"character\") или Factor (в случае если stringsAsFactors = TRUE), то, скорее всего, одна из строчек содержит в себе нечисловые знаки, которые не были прочитаны как NA.\nСтранные названия колонок. Это может случиться по самым разным причинам, но в таких случаях стоит открывать файл в другой программе и смотреть первые строчки. Например, может оказаться, что первые несколько строчек — пустые или что первая строчка не содержит название столбцов (тогда для параметра header = нужно поставить FALSE)\nВместо строковых данных у вас кракозябры. Это означает проблемы с кодировкой. В первую очередь попробуйте выставить значение \"UTF-8\" для параметра encoding = в функции для чтения файла:\n\n\nheroes <- read.csv(\"data/heroes_information.csv\", \n                   stringsAsFactors = FALSE,\n                   encoding = \"UTF-8\")\n\nВ случае если это не помогает, попробуйте разобрать, что это за кодировка.\n\nВсе прочиталось как одна колонка. В этом случае, скорее всего, неправильно подобран разделить колонок — параметр sep =. Откройте файл в текстовом редакторе, чтобы понять какой нужно использовать.\nВ отдельных строчках все прочиталось как одна колонка, а в остальных нормально. Скорее всего, в файле есть значения типа \\ или \", которые в функциях read.csv(), read.delim(), read.csv2(), read.delim2() читаются как символы для закавычивания значений. Это может понадобиться, если у вас в таблице есть строковые значения со знаками , или ;, которые могут восприниматься как разделитель столбцов.\nПоявились какие-то новые числовые колонки. Возможно неправильно поставлен разделитель дробной части. Обычно это либо . (read.table(), read.csv(), read.delim()), либо , (read.csv2(), read.delim2()).\n\nКонкретно в нашем случае все прочиталось хорошо с помощью функции read.csv(), но в строковых переменных есть много прочерков, которые обозначают отсутствие информации по данному параметру супергероя, т.е. пропущенное значение. А вот с числовыми значениями все не так просто: для всех супергероев прописано какое-то число, но во многих случаях это -99. Очевидно, отрицательного роста и массы не бывает, это просто обозначение пропущенных значений (такое часто используется). Таким образом, чтобы адекватно прочитать файл, нам нужно поменять параметр na.strings = функции read.csv():\n\nheroes <- read.csv(\"data/heroes_information.csv\", \n                   stringsAsFactors = FALSE,\n                   na.strings = c(\"-\", \"-99\"))"
  },
  {
    "objectID": "030-import_data.html#export_data",
    "href": "030-import_data.html#export_data",
    "title": "3  Импорт и экспорт данных",
    "section": "3.4 Экспорт данных",
    "text": "3.4 Экспорт данных\nПредставим, что вы хотите сохранить табличку с данными про супергероев из вселенной DC в виде отдельного файла .csv.\n\ndc <- heroes[heroes$Publisher == \"DC Comics\",]\n\nФункция write.csv() позволит записать датафрейм в файл формата .csv:\n\nwrite.csv(dc, \"data/dc_heroes_information.csv\")\n\nОбычно названия строк не используются, и их лучше не записывать, поставив для row.names = значение FALSE:\n\nwrite.csv(dc, \"data/dc_heroes_information.csv\", row.names = FALSE)\n\nПо аналогии с read.csv2(), write.csv2() позволит записать файлы формата .csv с разделителем ;.\n\nwrite.csv2(dc, \"data/dc_heroes_information.csv\", row.names = FALSE)"
  },
  {
    "objectID": "030-import_data.html#binary",
    "href": "030-import_data.html#binary",
    "title": "3  Импорт и экспорт данных",
    "section": "3.5 Импорт таблиц в бинарном формате: таблицы Excel, SPSS",
    "text": "3.5 Импорт таблиц в бинарном формате: таблицы Excel, SPSS\nТем не менее, далеко не всегда таблицы представлены в виде текстового файла. Самый распространенный пример таблицы в бинарном виде — родные форматы Microsoft Excel. Если Вы попробуете открыть .xlsx файл в Блокноте, то увидите кракозябры. Это делает работу с этим файлами гораздо менее удобной, поэтому стоит избегать экселевских форматов и стараться все сохранять в .csv.\nТакие файлы не получится прочитать при помощи базового инструментария R. Тем не менее, для чтения таких файлов есть много дополнительных пакетов:\n\nфайлы Microsoft Excel: лучше всего справляется пакет readxl (является частью расширенного tidyverse), у него есть много альтернатив (xlsx, openxlsx).\nфайлы SPSS, SAS, Stata: существуют два основных пакета — haven (часть расширенного tidyverse) и foreign.\n\nЧто такое пакеты и как их устанавливать мы изучим очень скоро."
  },
  {
    "objectID": "030-import_data.html#fastread",
    "href": "030-import_data.html#fastread",
    "title": "3  Импорт и экспорт данных",
    "section": "3.6 Быстрый импорт данных",
    "text": "3.6 Быстрый импорт данных\nЧтение табличных данных обычно происходит очень быстро. По крайней мере, до тех пор пока ваши данные не содержат очень много значений. Если вы попробуете прочитать с помощью read.csv() таблицу с миллионами строчками, то заметите, что это происходит довольно медленно. Впрочем, эта проблема эффективно решается дополнительными пакетами.\n\nПакет readr (часть базового tidyverse) предлагает функции, очень похожие на стандартные read.csv(), read.csv2() и тому подобные, только в названиях используется нижнее подчеркивание: read_csv() и read_csv2(). Они быстрее и немного удобнее, особенно если вы работаете в tidyverse.\n\n\nreadr::read_csv(\"data/heroes_information.csv\",\n         na = c(\"-\", \"-99\"))\n\nWarning: Missing column names filled in: 'X1' [1]\n\n\n\n── Column specification ────────────────────────────────────────────────────────\ncols(\n  X1 = col_double(),\n  name = col_character(),\n  Gender = col_character(),\n  `Eye color` = col_character(),\n  Race = col_character(),\n  `Hair color` = col_character(),\n  Height = col_double(),\n  Publisher = col_character(),\n  `Skin color` = col_character(),\n  Alignment = col_character(),\n  Weight = col_double()\n)\n\n\n# A tibble: 734 × 11\n      X1 name          Gender `Eye color` Race     `Hair color` Height Publisher\n   <dbl> <chr>         <chr>  <chr>       <chr>    <chr>         <dbl> <chr>    \n 1     0 A-Bomb        Male   yellow      Human    No Hair         203 Marvel C…\n 2     1 Abe Sapien    Male   blue        Icthyo … No Hair         191 Dark Hor…\n 3     2 Abin Sur      Male   blue        Ungaran  No Hair         185 DC Comics\n 4     3 Abomination   Male   green       Human /… No Hair         203 Marvel C…\n 5     4 Abraxas       Male   blue        Cosmic … Black            NA Marvel C…\n 6     5 Absorbing Man Male   blue        Human    No Hair         193 Marvel C…\n 7     6 Adam Monroe   Male   blue        <NA>     Blond            NA NBC - He…\n 8     7 Adam Strange  Male   blue        Human    Blond           185 DC Comics\n 9     8 Agent 13      Female blue        <NA>     Blond           173 Marvel C…\n10     9 Agent Bob     Male   brown       Human    Brown           178 Marvel C…\n# … with 724 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <dbl>\n\n\n\nПакет vroom - это часть расширенного tidyverse. Это такая альтернатива readr из того же tidyverse, но еще быстрее (отсюда и название).\n\n\nvroom::vroom(\"data/heroes_information.csv\")\n\nNew names:\nRows: 734 Columns: 11 Delimiter: \",\" chr [8]: name, Gender, Eye color, Race,\nHair color, Publisher, Skin color, Alignment dbl [3]: ...1, Height, Weight\n\nUse `spec()` to retrieve the guessed column specification Pass a specification\nto the `col_types` argument to quiet this message\n• `` -> `...1`\n\n\n# A tibble: 734 × 11\n    ...1 name          Gender `Eye color` Race     `Hair color` Height Publisher\n   <dbl> <chr>         <chr>  <chr>       <chr>    <chr>         <dbl> <chr>    \n 1     0 A-Bomb        Male   yellow      Human    No Hair         203 Marvel C…\n 2     1 Abe Sapien    Male   blue        Icthyo … No Hair         191 Dark Hor…\n 3     2 Abin Sur      Male   blue        Ungaran  No Hair         185 DC Comics\n 4     3 Abomination   Male   green       Human /… No Hair         203 Marvel C…\n 5     4 Abraxas       Male   blue        Cosmic … Black           -99 Marvel C…\n 6     5 Absorbing Man Male   blue        Human    No Hair         193 Marvel C…\n 7     6 Adam Monroe   Male   blue        -        Blond           -99 NBC - He…\n 8     7 Adam Strange  Male   blue        Human    Blond           185 DC Comics\n 9     8 Agent 13      Female blue        -        Blond           173 Marvel C…\n10     9 Agent Bob     Male   brown       Human    Brown           178 Marvel C…\n# … with 724 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <dbl>\n\n\n\nПакет data.table - это не просто пакет, а целый фреймворк для работы с R, основной конкурент tidyverse. Одна из основных фишек data.table - быстрота работы. Это касается не только процессинга данных, но и их загрузки и записи. Поэтому некоторые используют функции data.table для чтения и записи данных в отдельности от всего остального пакета - они даже и называются соответствующе: fread() и fwrite(), где f означет fast2.\n\n\ndata.table::fread(\"data/heroes_information.csv\")\n\n      V1            name Gender Eye color              Race       Hair color\n  1:   0          A-Bomb   Male    yellow             Human          No Hair\n  2:   1      Abe Sapien   Male      blue     Icthyo Sapien          No Hair\n  3:   2        Abin Sur   Male      blue           Ungaran          No Hair\n  4:   3     Abomination   Male     green Human / Radiation          No Hair\n  5:   4         Abraxas   Male      blue     Cosmic Entity            Black\n ---                                                                        \n730: 729 Yellowjacket II Female      blue             Human Strawberry Blond\n731: 730            Ymir   Male     white       Frost Giant          No Hair\n732: 731            Yoda   Male     brown    Yoda's species            White\n733: 732         Zatanna Female      blue             Human            Black\n734: 733            Zoom   Male       red                 -            Brown\n     Height         Publisher Skin color Alignment Weight\n  1:  203.0     Marvel Comics          -      good    441\n  2:  191.0 Dark Horse Comics       blue      good     65\n  3:  185.0         DC Comics        red      good     90\n  4:  203.0     Marvel Comics          -       bad    441\n  5:  -99.0     Marvel Comics          -       bad    -99\n ---                                                     \n730:  165.0     Marvel Comics          -      good     52\n731:  304.8     Marvel Comics      white      good    -99\n732:   66.0      George Lucas      green      good     17\n733:  170.0         DC Comics          -      good     57\n734:  185.0         DC Comics          -       bad     81\n\n\nЧем же пользоваться среди всего этого многообразия? Бенчмарки3 показывают, что быстрее всех vroom и data.table. Если же у вас нет задачи ускорить работу кода на несколько миллисекунд или прочитать датасет на много миллионов строк, то стандартного read.csv() (если вы работаете в базовом R) и readr::read_csv() (если вы работаете в tidyverse) должно быть достаточно.\nВсе перечисленные пакеты повзоляют не только быстро импортировать данные, но и быстро (и удобно!) экспортировать их:\n\nreadr::write_csv(dc, \"data/dc_heroes_information.csv\")\nreadr::write_excel_csv(dc, \"data/dc_heroes_information.csv\") #Если в Excel возникают проблемы с кодировками при открытии созданного .csv файла, то эта функция решает эти проблемы\nvroom::vroom_write(dc, \"data/dc_heroes_information.csv\", delim = \",\")\ndata.table::fwrite(dc, \"data/dc_heroes_information.csv\")\n\nВ плане скорости записи файлов соотношение сил примерно такое же, как и для чтения: vroom и data.table обгоняют всех, затем идет readr, и только после него - базовые функции R."
  },
  {
    "objectID": "110-tidyverse_basic.html",
    "href": "110-tidyverse_basic.html",
    "title": "8  Введение в tidyverse",
    "section": "",
    "text": "tidyverse - это не один, а целое множество пакетов. Есть ключевые пакеты (ядро тайдиверса), а есть побочные - в основном для работы со специфическими видами данных.\ntidyverse — это набор пакетов:\n\nggplot2, для визуализации\ntibble, для работы с тибблами, продвинутый вариант датафрейма\ntidyr, для формата tidy data\nreadr, для чтения файлов в R\npurrr, для функционального программирования (замена семейства функций *apply())\ndplyr, для преобразованиия данных\nstringr, для работы со строковыми переменными\nforcats, для работы с переменными-факторами\n\nПолезно также знать о следующих пакетах, не включенных в ядро, но также считающихся частью тайдиверса:\n\nvroom, для быстрой загрузки табоичных данных\nreadxl, для чтения .xls и .xlsx\njsonlite, для работы с JSON\nxml, для работы с XML\nDBI, для работы с базами данных\nrvest, для веб-скреппинга\nlubridate, для работы с временем\ntidytext, для работы с текстами и корпусами\nglue, для продвинутого объединения строк\nmagrtittr, с несколькими вариантами pipe оператора\ntidymodels, для моделирования и машинного обучения1\ndtplyr, для ускорения dplyr за счет перевод синтаксиса на data.table\n\nИ это еще не все пакеты tidyverse! Есть еще много других небольших пакетов, которые тоже считаются частью tidyverse. Кроме официальных пакетов tidyverse есть множество пакетов, которые пытаются соответствовать принципам tidyverse и дополняют его.\nВсе пакеты tidyverse объединены tidy философией и взаимосовместимым синтаксисом. Это означает, что, во многих случаях даже не нужно думать о том, из какого именно пакета тайдиверса пришла функция. Можно просто установить и загрузить пакет tidyverse.\n\ninstall.packages(\"tidyverse\")\n\nПакет tidyverse — это такой пакет с пакетами.\n\nlibrary(\"tidyverse\")\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──\n\n\n✓ ggplot2 3.3.5     ✓ purrr   0.3.4\n✓ tibble  3.1.6     ✓ dplyr   1.0.8\n✓ tidyr   1.2.0     ✓ stringr 1.4.0\n✓ readr   1.4.0     ✓ forcats 0.5.1\n\n\nWarning: package 'tidyr' was built under R version 4.0.5\n\n\nWarning: package 'dplyr' was built under R version 4.0.5\n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\n\n\nПодключение пакета tidyverse автоматически приводит к подключению ядра tidyverse, остальные же пакеты нужно подключать дополнительно при необходимости."
  },
  {
    "objectID": "210-desc_stats.html",
    "href": "210-desc_stats.html",
    "title": "10  Описательная статистика",
    "section": "",
    "text": "Статистика делится на описательную статистику (descriptive statistics) и статистику вывода (inferential statistics). Описательная статистика пытается описать нашу выборку (sample, т.е. те данные, что у нас на руках) различными способами. Проблема в том, что описательная статистика может описать только то, что у нас есть, но не позволяет сделать выводы о генеральной совокупности (population) - это уже цель статистики вывода. Цель описательной статистики - “ужать” данные для их обобщенного понимания с помощью статистик.\n\nЗаметьте, у выборки (sample) мы считаем статистики (statistics), а у генеральной совокупности (Population) есть параметры (Parameters). Вот такая вот мнемотехника.\n\nСтатистики часто выступают в роли точечной оценки (point estimators) параметров, так что в этом легко запутаться. Например, среднее (в выборке) - это оценка среднего (в генеральной совокупности). Да, можно свихнуться. Мы это будем разбирать подробнее в следующие занятия (это действительно важно, поверьте), пока что остановимся только на описании выборки."
  },
  {
    "objectID": "040-programming.html",
    "href": "040-programming.html",
    "title": "4  Условные конструкции и циклы",
    "section": "",
    "text": "Стандратная часть практически любого языка программирования — условные конструкции. R не исключение. Однако и здесь есть свои особенности. Начнем с самого простого варианта с одним условием. Выглядеть условная конcтрукция будет вот так:\nif (условие) выражение\nВот так это будет работать на практике:\n\nnumber <- 1\nif (number > 0) \"Положительное число\"\n\n[1] \"Положительное число\"\n\n\nЕсли выражение (expression) содержит больше одной строчки, то они объединяются фигурными скобками. Впрочем, использовать их можно, даже если строчка всего в выражении всего одна.\n\nnumber <- 1\nif (number > 0) {\n  \"Положительное число\"\n}\n\n[1] \"Положительное число\"\n\n\nВ рассмотренной нами конструкции происходит проверка на условие. Если условие верно1, то происходит то, что записано в последующем выражении. Если же условие неверно2, то ничего не происходит.\nОператор else позволяет задавать действие на все остальные случаи:\nif (условие) выражение else выражение\nРаботает это так:\n\nnumber <- -3\nif (number > 0) {\n  \"Положительное число\"\n} else {\n  \"Отрицательное число или ноль\"\n}\n\n[1] \"Отрицательное число или ноль\"\n\n\nИногда нам нужна последовательная проверка на несколько условий. Для этого есть оператор else if. Вот как выглядит ее применение:\n\nnumber <- 0\nif (number > 0) {\n  \"Положительное число\"\n} else if (number < 0){\n  \"Отрицательное число\"\n} else {\n  \"Ноль\"\n}\n\n[1] \"Ноль\"\n\n\nКак мы помним, R — язык, в котором векторизация играет большое значение. Но вот незадача — условные конструкции не векторизованы в R! Давайте попробуем применить эти конструкции для вектора значений и посмотрим, что получится.\n\nnumber <- -2:2\nif (number > 0) {\n  \"Положительное число\"\n} else if (number < 0){\n  \"Отрицательное число\"\n} else {\n  \"Ноль\"\n}\n\nWarning in if (number > 0) {: the condition has length > 1 and only the first\nelement will be used\n\n\nWarning in if (number < 0) {: the condition has length > 1 and only the first\nelement will be used\n\n\n[1] \"Отрицательное число\"\n\n\nR выдает сообщение, что используется только первое значение логического вектора внутри условия. Остальные просто игнорируются. Как же посчитать для всего вектора сразу?"
  },
  {
    "objectID": "040-programming.html#for",
    "href": "040-programming.html#for",
    "title": "4  Условные конструкции и циклы",
    "section": "4.2 Циклы for",
    "text": "4.2 Циклы for\nВо-первых, можно использовать for. Синтаксис у for похож на синтаксис условных конструкций.\nfor(переменная in последовательность) выражение\nТеперь мы можем объединить условные конструкции и for. Немножко монструозно, но это работает:\n\nfor (i in number) {\n  if (i > 0) {\n    print(\"Положительное число\")\n  } else if (i < 0) {\n    print(\"Отрицательное число\")\n  } else {\n    print(\"Ноль\")\n  }\n}\n\n[1] \"Отрицательное число\"\n[1] \"Отрицательное число\"\n[1] \"Ноль\"\n[1] \"Положительное число\"\n[1] \"Положительное число\"\n\n\n\nЧтобы выводить в консоль результат вычислений внутри for, нужно использовать print().\n\nЗдесь стоит отметить, что for используется в R относительно редко. В подавляющем числе ситуаций использование for можно избежать. Обычно мы работаем в R с векторами или датафреймами, которые представляют собой множество относительно независимых наблюдений. Если мы хотим провести какие-нибудь операции с этими наблюдениями, то они обычно могут быть выполнены параллельно. Скажем, вы хотите для каждого испытуемого пересчитать его массу из фунтов в килограммы. Этот пересчет осуществляется по одинаковой формуле для каждого испытуемого. Эта формула не изменится из-за того, что какой-то испытуемый слишком большой или слишком маленький - для следующего испытуемого формула будет прежняя. Если Вы встречаете подобную задачу (где функцию можно применить независимо для всех значений), то без цикла for вполне можно обойтись.\nДаже во многих случаях, где расчеты для одной строчки зависят от расчетов предыдущих строчек, можно обойтись без for векторизованными функциями, например, cumsum() для подсчета кумулятивной суммы.\n\ncumsum(1:10)\n\n [1]  1  3  6 10 15 21 28 36 45 55\n\n\nЕсли же нет подходящей векторизованной функции, то можно воспользоваться семейством функций apply() (см. @ref(apply_f) ).\n\nПосле этих объяснений кому-то может показаться странным, что я вообще упоминаю про эти циклы. Но для кого-то циклы for настолько привычны, что их полное отсутствие в курсе может показаться еще более странным. Поэтому лучше от меня, чем на улице.\n\nЗачем вообще избегать конструкций for? Некоторые говорят, что они слишком медленные, и частично это верно, если мы сравниваем с векторизованными функциями, которые написаны на более низкоуровневых языках. Но в большинстве случаев низкая скорость for связана с неправильным использованием этой конструкции. Например, стоит избегать ситуации, когда на каждой итерации for какой-то объект (вектор, список, что угодно) изменяется в размере. Лучше будет создать заранее объект нужного размера, который затем будет наполняться значениями:\n\nnumber_descriptions <- character(length(number)) #создаем строковый вектор с такой же длиной, как и исходный вектор\nfor (i in 1:length(number)) {\n  if (number[i] > 0) {\n    number_descriptions[i] <- \"Положительное число\"\n  } else if (number[i] < 0) {\n    number_descriptions[i] <- \"Отрицательное число\"\n  } else {\n    number_descriptions[i] <- \"Ноль\"\n  }\n}\nnumber_descriptions\n\n[1] \"Отрицательное число\" \"Отрицательное число\" \"Ноль\"               \n[4] \"Положительное число\" \"Положительное число\"\n\n\nВ общем, при правильном обращении с for особых проблем со скоростью не будет. Но все равно это будет громоздкая конструкция, в которой легко ошибиться, и которую, скорее всего, можно заменить одной короткой строчкой. Кроме того, без конструкции for код обычно легко превратить в набор функций, последовательно применяющихся к данным, что мы будем по максимуму использовать, работая в tidyverse и применяя пайпы (см. [pipe])."
  },
  {
    "objectID": "040-programming.html#ifelse",
    "href": "040-programming.html#ifelse",
    "title": "4  Условные конструкции и циклы",
    "section": "4.3 Векторизованные условные конструкции: функции ifelse() и dplyr::case_when()",
    "text": "4.3 Векторизованные условные конструкции: функции ifelse() и dplyr::case_when()\nАльтернатива сочетанию условных конструкций и циклов for является использование встроенной функции ifelse(). Функция ifelse() принимает три аргумента - 1) условие (т.е. просто логический вектор, состоящий из TRUE и FALSE), 2) что выдавать в случае TRUE, 3) что выдавать в случае FALSE. На выходе получается вектор такой же длины, как и изначальный логический вектор (условие).\n\nifelse(number > 0, \"Положительное число\", \"Отрицательное число или ноль\")\n\n[1] \"Отрицательное число или ноль\" \"Отрицательное число или ноль\"\n[3] \"Отрицательное число или ноль\" \"Положительное число\"         \n[5] \"Положительное число\"         \n\n\n\nПериодически я встречаю у студентов строчку вроде такой: ifelse(условие, TRUE, FALSE). Эта конструкция избыточна, т.к. получается, что логический вектор из TRUE и FALSE превращается в абсолютно такой же вектор из TRUE и FALSE на тех же самых местах. Выходит, что ничего не меняется!\n\nПакеты {dplyr} и {data.table} предоставляют более быстрые и более строгие альтернативы для базовой функции ifelse() с аналогичным синтаксисом:\n\ndplyr::if_else(number > 0, \"Положительное число\", \"Отрицательное число или ноль\")\n\n[1] \"Отрицательное число или ноль\" \"Отрицательное число или ноль\"\n[3] \"Отрицательное число или ноль\" \"Положительное число\"         \n[5] \"Положительное число\"         \n\ndata.table::fifelse(number > 0, \"Положительное число\", \"Отрицательное число или ноль\")\n\n[1] \"Отрицательное число или ноль\" \"Отрицательное число или ноль\"\n[3] \"Отрицательное число или ноль\" \"Положительное число\"         \n[5] \"Положительное число\"         \n\n\nЕсли вы пользуетесь одним из этих пакетов (о них пойдет речь далее — см. @ref(tidy_intro)), то я советую пользоваться соотвествующей функцией вместо базового ifelse().\nОбе функции будут избегать скрытого приведения типов (см. @ref(coercion)) и намеренно выдавать ошибку при использовании разных типов данных в параметрах yes = и no =. Помните, что NA по умолчанию — это логический тип данных, поэтому в этих функциях нужно использовать NA соответствующего типа NA_character_, NA_integer_, NA_real_, NA_complex_ (см. @ref(na)).\nУ ifelse() тоже есть недостаток: он не может включать в себя дополнительных условий по типу else if. В простых ситуациях можно вставлять ifelse() внутри ifelse():\n\nifelse(number > 0,\n       \"Положительное число\",\n       ifelse(number < 0, \"Отрицательное число\", \"Ноль\"))\n\n[1] \"Отрицательное число\" \"Отрицательное число\" \"Ноль\"               \n[4] \"Положительное число\" \"Положительное число\"\n\n\nДостаточно симпатичное решение есть в пакете dplyr — функция case_when(), которая работает с использованием формулы:\n\ndplyr::case_when(\n  number > 0 ~ \"Положительное число\",\n  number < 0 ~ \"Отрицательное число\",\n  number == 0 ~ \"Ноль\")\n\n[1] \"Отрицательное число\" \"Отрицательное число\" \"Ноль\"               \n[4] \"Положительное число\" \"Положительное число\"\n\n\nВ data.table тоже есть свой (более быстрый) аналог case_when() — функция fcase(). Синтаксис отличается только тем, что вместо формул используются простые запятые:\n\ndata.table::fcase(\n  number > 0, \"Положительное число\",\n  number < 0, \"Отрицательное число\",\n  number == 0, \"Ноль\")\n\n[1] \"Отрицательное число\" \"Отрицательное число\" \"Ноль\"               \n[4] \"Положительное число\" \"Положительное число\"\n\n\nЗадача создания вектора или колонки по множественным условиям из другой колонки плавно перетекает в задачу объединения двух датафреймов по единому ключу, и такое решение может оказаться наиболее быстрым (см. @ref(tidy_join))."
  },
  {
    "objectID": "040-programming.html#create_fun",
    "href": "040-programming.html#create_fun",
    "title": "4  Условные конструкции и циклы",
    "section": "5.1 Создание функций",
    "text": "5.1 Создание функций\nПоздравляю, сейчас мы выйдем на качественно новый уровень владения R. Вместо того, чтобы пользоваться теми функциями, которые уже написали за нас, мы можем сами создавать свои функции! В этом нет ничего сложного.\nСинтаксис создания функции внешне похож на создание циклов или условных конструкций. Мы пишем ключевое слово function, в круглых скобках обозначаем переменные, с которыми собираемся что-то делать. Внутри фигурных скобок пишем выражения, которые будут выполняться при запуске функции. У функции есть свое собственное окружение — место, где хранятся переменные. Именно те объекты, которые мы передаем в скобочках, и будут в окружении, так же как и “обычные” переменные для нас в глобальном окружении. Это означает, что функция будет искать переменные в первую очередь среди объектов, которые переданы в круглых скобочках. С ними функция и будет работать. На выходе функция выдаст то, что вычисляется внутри функции return(). Если return() появляется в теле функции несколько раз, то до результат будет возвращаться из той функции return(), до которой выполнение дошло первым.\n\npow <- function(x, p) {\n  power <- x ^ p\n  return(power)\n}\npow(3, 2)\n\n[1] 9\n\n\nЕсли функция проработала до конца, а функция return() так и не встретилась, то возвращается последнее посчитанное значение.\n\npow <- function(x, p) {\n  x ^ p\n}\npow(3, 2)\n\n[1] 9\n\n\nЕсли в последней строчке будет присвоение, то функция ничего не вернет обратно. Это очень распространенная ошибка: функция вроде бы работает правильно, но ничего не возвращает. Нужно писать так, как будто бы в последней строчке результат выполнения выводится в консоль.\n\npow <- function(x, p) {\n  power <- x ^ p #Функция ничего не вернет, потому что в последней строчке присвоение!\n}\npow(3, 2) #ничего не возвращается из функции\n\nЕсли функция небольшая, то ее можно записать в одну строчку без фигурных скобок.\n\npow <- function(x, p) x ^ p\npow(3, 2) \n\n[1] 9\n\n\nВообще, фигурные скобки используются для того, чтобы выполнить серию выражений, но вернуть только результат выполнения последнего выражения. Это можно использовать, чтобы не создавать лишних временных переменных в глобальном окружении.\nМы можем оставить в функции параметры по умолчанию.\n\npow <- function(x, p = 2) x ^ p\npow(3) \n\n[1] 9\n\npow(3, 3) \n\n[1] 27\n\n\nВ R работают ленивые вычисления (lazy evaluations). Это означает, что параметры функций будут только когда они понадобятся, а не заранее. R будет как самый ленивый прокрастинатор откладывать чтение данных, пока они не понадобятся в вычислениях. Это приводит к тому, что если параметр никак не задан, то обнаружится это только при его непосредственном использовании. Например, эта функция не будет выдавать ошибку, если мы не зададим параметр we_will_not_use_this_parameter =, потому что он нигде не используется в расчетах.\n\npow <- function(x, p = 2, we_will_not_use_this_parameter) x ^ p\npow(x = 3)\n\n[1] 9"
  },
  {
    "objectID": "040-programming.html#sanity_check",
    "href": "040-programming.html#sanity_check",
    "title": "4  Условные конструкции и циклы",
    "section": "5.2 Проверка на адекватность",
    "text": "5.2 Проверка на адекватность\nЛучший способ не бояться ошибок и предупреждений — научиться прописывать их самостоятельно в собственных функциях. Это позволит понять, что за текстом предупреждений и ошибок, которые у вас возникают, стоит забота разработчиков о пользователях, которые хотят максимально обезопасить нас от наших непродуманных действий.\nХорошо написанные функции не только выдают правильный результат на все возможные адекватные данные на входе, но и не дают получить правдоподобные результаты при неадекватных входных данных. Как вы уже знаете, если на входе у вас имеются пропущенные значения, то многие функции будут в ответ тоже выдавать пропущенные значения. И это вполне осознанное решение, которое позволяет избегать ситуаций вроде той, когда около одной пятой научных статей по генетике содержало ошибки в приложенных данных и замечать пропущенные значения на ранней стадии. Кроме того, можно проводить проверки на адекватность входящих данных (sanity check).\nРазберем это на примере самодельной функции imt(), которая выдает индекс массы тела, если на входе задать вес (аргумент weight =) в килограммах и рост (аргумент height =) в метрах.\n\nimt <- function(weight, height) weight / height ^ 2\n\nПроверим, что функция работает верно:\n\nw <- c(60, 80, 120)\nh <- c(1.6, 1.7, 1.8)\nimt(weight = w, height = h)\n\n[1] 23.43750 27.68166 37.03704\n\n\nОчень легко перепутать и написать рост в сантиметрах. Было бы здорово предупредить об этом пользователя, показав ему предупреждающее сообщение, если рост больше, чем, например, 3. Это можно сделать с помощью функции warning()\n\nimt <- function(weight, height) {\n  if (any(height > 3)) warning(\"Рост в аргументе height больше 3: возможно, указан рост в сантиметрах, а не в метрах\\n\")\n  weight / height ^ 2\n}\nimt(78, 167)\n\nWarning in imt(78, 167): Рост в аргументе height больше 3: возможно, указан рост в сантиметрах, а не в метрах\n\n\n[1] 0.002796802\n\n\nВ некоторых случаях ответ будет совершенно точно некорректным, хотя функция все посчитает и выдаст ответ, как будто так и надо. Например, если какой-то из аргументов функции imt() будет меньше или равен 0. В этом случае нужно прописать проверку на это условие, и если это действительно так, то выдать пользователю ошибку.\n\nimt <- function(weight, height) {\n  if (any(weight <= 0 | height <= 0)) stop(\"Индекс массы тела не может быть посчитан для отрицательных значений\")\n  if (any(height > 3)) warning(\"Рост в аргументе height больше 3: возможно, указан рост в сантиметрах, а не в метрах\\n\")\n  weight / height ^ 2\n}\nimt(-78, 167)\n\nError in imt(-78, 167): Индекс массы тела не может быть посчитан для отрицательных значений\n\n\nКогда вы попробуете самостоятельно прописывать предупреждения и ошибки в функциях, то быстро поймете, что ошибки - это вовсе не обязательно результат того, что где-то что-то сломалось и нужно паниковать. Совсем даже наоборот, прописанная ошибка - чья-то забота о пользователях, которых пытаются максимально проинформировать о том, что и почему пошло не так.\nЭто естественно в начале работы с R (и вообще с программированием) избегать ошибок, конечно, в самом начале обучения большая часть из них остается непонятной. Но постарайтесь понять текст ошибки, вспомнить в каких случаях у вас возникала похожая ошибка. Очень часто этого оказывается достаточно чтобы понять причину ошибки даже если вы только-только начали изучать R.\nНу а в дальнейшем я советую ознакомиться со средствами отладки кода в R для того, чтобы научиться справляться с ошибками в своем коде на более продвинутом уровне."
  },
  {
    "objectID": "040-programming.html#why_functions",
    "href": "040-programming.html#why_functions",
    "title": "4  Условные конструкции и циклы",
    "section": "5.3 Когда и зачем создавать функции?",
    "text": "5.3 Когда и зачем создавать функции?\nКогда стоит создавать функции? Существует “правило трех” — если у вас есть три куска очень похожего кода, то самое время превратить код в функцию. Это очень условное правило, но, действительно, стоит избегать копипастинга в коде. В этом случае очень легко ошибиться, а сам код становится нечитаемым.\nЕсть и другой подход к созданию функций: их стоит создавать не столько для того, чтобы использовать тот же код снова, сколько для абстрагирования от того, что происходит в отдельных строчках кода. Если несколько строчек кода были написаны для того, чтобы решить одну задачу, которой можно дать понятное название (например, подсчет какой-то особенной метрики, для которой нет готовой функции в R), то этот код стоит обернуть в функцию. Если функция работает корректно, то теперь не нужно думать над тем, что происходит внутри нее. Вы ее можете мысленно представить как операцию, которая имеет определенный вход и выход — как и встроенные функции в R.\nОтсюда следует важный вывод, что хорошее название для функции — это очень важно. Очень, очень, очень важно."
  },
  {
    "objectID": "040-programming.html#functions_objects",
    "href": "040-programming.html#functions_objects",
    "title": "4  Условные конструкции и циклы",
    "section": "5.4 Функции как объекты первого порядка",
    "text": "5.4 Функции как объекты первого порядка\nРанее мы убедились, что арифметические операторы — это тоже функции. На самом деле, практически все в R — это функции. Даже function — это функция function(). Даже скобочки (, { — это функции!\nА сами функции — это объекты первого порядка в R. Это означает, что с функциями вы можете делать практически все то же самое, что и с другими объектами в R (векторами, датафреймами и т.д.). Небольшой пример, который может взорвать ваш мозг:\n\nlist(mean, min, `{`)\n\n[[1]]\nfunction (x, ...) \nUseMethod(\"mean\")\n<bytecode: 0x7f947bc1d360>\n<environment: namespace:base>\n\n[[2]]\nfunction (..., na.rm = FALSE)  .Primitive(\"min\")\n\n[[3]]\n.Primitive(\"{\")\n\n\nМы можем создать список из функций! Зачем — это другой вопрос, но ведь можем же!\nЕще можно создавать функции внутри функций 3, использовать функции в качестве аргументов функций, сохранять функции как переменные. Пожалуй, самое важное из этого всего - это то, что функция может быть аргументом в функции. Не просто название функции как строковая переменная, не результат выполнения функции, а именно сама функция. Это лежит в основе использования семейства функций apply() (@ref(apply_f) и многих фишек tidyverse.\n\nВ Python дело обстоит похожим образом: функции там тоже являются объектами первого порядка, поэтому все эти фишки функционального программирования (с поправкой на синтаксис, конечно) будут работать и там."
  },
  {
    "objectID": "040-programming.html#apply_f",
    "href": "040-programming.html#apply_f",
    "title": "4  Условные конструкции и циклы",
    "section": "5.5 Семейство функций apply()",
    "text": "5.5 Семейство функций apply()\n\n5.5.1 Применение apply() для матриц\nСемейство? Да, их целое множество: apply(), lapply(),sapply(), vapply(),tapply(),mapply(), rapply()… Ладно, не пугайтесь, всех их знать не придется. Обычно достаточно первых двух-трех. Проще всего пояснить как они работают на простой матрице с числами:\n\nA <- matrix(1:12, 3, 4)\nA \n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n\n\nФункция apply() предназначена для работы с матрицами (или многомерными массивами). Если вы скормите функции apply() датафрейм, то этот датафрейм будет сначала превращен в матрицу. Главное отличие матрицы от датафрейма в том, что в матрице все значения одного типа, поэтому будьте готовы, что сработает имплицитное приведение к общему типу данных. Например, если среди колонок датафрейма есть хотя бы одна строковая колонка, то все колонки станут строковыми.\n\nТеперь представим, что нам нужно посчитать что-нибудь (например, сумму) по каждой из строк. С помощью функции apply() вы можете в буквальном смысле “применить” функцию к матрице или датафрейму. Синтаксис такой: apply(X, MARGIN, FUN, ...), где X — данные, MARGIN это 1 (для строк), 2 (для колонок), c(1,2) для строк и колонок (т.е. для каждого элемента по отдельности), а FUN — это функция, которую вы хотите применить! apply() будет брать строки/колонки из X в качестве первого аргумента для функции.\n\n\n\napply\n\n\n\nЗаметьте, мы вставляем функцию без скобок и кавычек как аргумент в функцию. Это как раз тот случай, когда аргументом в функции выступает сама функция, а не ее название или результат ее выполнения.\n\nДавайте разберем на примере:\n\napply(A, 1, sum) #сумма по каждой строчке\n\n[1] 22 26 30\n\napply(A, 2, sum) #сумма по каждой колонке\n\n[1]  6 15 24 33\n\napply(A, c(1,2), sum) #кхм... сумма каждого элемента\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n\n\nКонкретно для подсчета сумм и средних по столбцам и строкам в R есть функции colSums(), rowSums(), colMeans() и rowMeans(), которые можно использовать как альтернативы apply() в данном случае.\n\nЕсли же мы хотим прописать дополнительные аргументы для функции, то их можно перечислить через запятую после функции:\n\napply(A, 1, sum, na.rm = TRUE)\n\n[1] 22 26 30\n\n\n\napply(A, 1, weighted.mean, w = c(0.2, 0.4, 0.3, 0.1)) \n\n[1] 4.9 5.9 6.9\n\n\n\n\n5.5.2 Анонимные функции\nЧто делать, если мы хотим сделать что-то более сложное, чем просто применить одну функцию? А если функция принимает не первым, а вторым аргументом данные из матрицы? В этом случае нам помогут анонимные функции.\nАнонимные функции - это функции, которые будут использоваться один раз и без названия.\n\nПитонистам знакомо понятие лямбда-функций. Да, это то же самое.\n\nНапример, мы можем посчитать сумму квадратичных отклонений от среднего без называния этой функции:\n\napply(A, 1, function(x) sum((x - mean(x))^2)) #отклонения от среднего по строчке\n\n[1] 45 45 45\n\napply(A, 2, function(x) sum((x - mean(x))^2)) #отклонения от среднего по столбцу\n\n[1] 2 2 2 2\n\napply(A, c(1, 2), function(x) sum((x - mean(x))^2)) #отклонения от одного значения, т.е. ноль\n\n     [,1] [,2] [,3] [,4]\n[1,]    0    0    0    0\n[2,]    0    0    0    0\n[3,]    0    0    0    0\n\n\nКак и в случае с обычной функцией, в качестве x выступает объект, с которым мы хотим что-то сделать, а дальше следует функция, которую мы собираемся применить к х. Можно использовать не х, а что угодно, как и в обычных функциях:\n\napply(A, 1, function(whatevername) sum((whatevername - mean(whatevername))^2))\n\n[1] 45 45 45\n\n\n\n\n5.5.3 Другие функции семейства apply()\nОк, с apply() разобрались. А что с остальными? Некоторые из них еще проще и не требуют индексов, например, lapply (для применения к каждому элементу списка) и sapply() - упрощенная версия lapply(), которая пытается по возможности “упростить” результат до вектора или матрицы.\n\nsome_list <- list(some = 1:10, list = letters)\nlapply(some_list, length)\n\n$some\n[1] 10\n\n$list\n[1] 26\n\nsapply(some_list, length)\n\nsome list \n  10   26 \n\n\n\nДостаточно сложно предсказать, в каких именно случаях будет произведено упрощение, а в каких нет. Поэтому sapply() удобен в исследовании данных, но использовать эту функцию в скриптах не очень рекомендуется. Один из вариантов решения этой проблемы — это функция vapply(), которая позволяет управлять результатом lapply(), но гораздо более красиво эта проблема решена в пакете {purrr} (см. @ref(purrr)).\n\nИспользование sapply() на векторе приводит к тем же результатам, что и просто применить векторизованную функцию обычным способом.\n\nsapply(1:10, sqrt)\n\n [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427\n [9] 3.000000 3.162278\n\nsqrt(1:10)\n\n [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427\n [9] 3.000000 3.162278\n\n\nЗачем вообще тогда нужен sapply(), если мы можем просто применить векторизованную функцию? Ключевое слово здесь векторизованная функция. Если функция не векторизована, то sapply() становится удобным вариантом для того, чтобы избежать итерирования с помощью циклов for.\n\nЕще одна альтернатива - это векторизация невекторизованной функции с помощью Vectorize(). Эта функция просто оборачивает функцию одним из вариантов apply().\n\nМожно применять функции lapply() и sapply() на датафреймах. Поскольку фактически датафрейм - это список из векторов одинаковой длины (см. @ref(df)), то итерироваться эти функции будут по колонкам:\n\nheroes <- read.csv(\"https://raw.githubusercontent.com/Pozdniakov/tidy_stats/master/data/heroes_information.csv\", \n                   na.strings = c(\"-\", \"-99\"))\nsapply(heroes, class)\n\n          X        name      Gender   Eye.color        Race  Hair.color \n  \"integer\" \"character\" \"character\" \"character\" \"character\" \"character\" \n     Height   Publisher  Skin.color   Alignment      Weight \n  \"numeric\" \"character\" \"character\" \"character\"   \"integer\" \n\n\nЕще одна функция из семейства apply() - функция replicate() - самый простой способ повторить одну и ту же операцию много раз. Обычно эта функция используется при симуляции данных и моделировании. Например, давайте сделаем выборку из логнормального распределения:\n\nsamp <- rlnorm(30)\nhist(samp)\n\n\n\n\nА теперь давайте сделаем 1000 таких выборок и из каждой возьмем среднее:\n\nsampdist <- replicate(1000, mean(rlnorm(30)))\nhist(sampdist)\n\n\n\n\n\nПро функции для генерации случайных чисел и про визуализацию мы поговорим в следующие дни.\n\nЕсли хотите познакомиться с семейством apply() чуточку ближе, то рекомендую вот этот туториал.\nВ заключение стоит сказать, что семейство функций apply() — это очень сильное колдунство, но в tidyverse оно практически полностью перекрывается функциями из пакета purrr. Впрочем, если вы поняли логику apply(), то при желании вы легко сможете переключиться на альтернативы из пакета purrr (см. @ref(purrr))"
  },
  {
    "objectID": "020-install.html",
    "href": "020-install.html",
    "title": "2  Пакеты в R",
    "section": "",
    "text": "R — очень богатый язык с широкими возможностями. Однако очень скоро мы поймем, что этих возможностей нам не хватает. Эти возможности нам могут предоставить дополнительные пакеты (packages).\nВ большинстве случаев основным содержанием пакетов является набор дополнительных функций. Кроме функций, пакеты могут содержать наборы данных и новые структуры данных.\nОбычно пакеты посвящены решению какого-то класса задач в определенной области. Например, есть множество пакетов для создания какого-то одного типа визуализации. Еще один пример — пакет beepr, который содержит всего две функции: beep() и beep_on_error() для воспроизведения звукового сигнала. Это может быть удобно, если ваш скрипт работает долго, но вы хотите получить уведомление, когда его выполнение завершится.\nБолее крупные пакеты посвящены целому классу задач. Например, пакеты stringi и stringr посвящены работе со строками, значительно расширяя и делая более удобной работу со строковыми данными в R. Еще один пример: пакет igraph для работы с графами (сетями). Этот пакет предоставляет дополнительный класс данных igraph для хранения и работы с сетями.\nЕсть и совсем крупные пакеты, которые значительно расширяют базовый функционал R, изменяя основные принципы работы в нем. Это пакеты data.table и tidyverse. Это настолько крупные пакеты, что их даже называют отдельными диалектами R, потому что код, написанный с использованием этих пакетов, довольно сильно отличается от базового R. Кроме того, tidyverse - это не просто пакет, а целая экосистема пакетов, который взаимодополняют друг друга, но для удобства их можно устанавливать и загружать как один пакет tidyverse. Еще один пример крупной экосистемы из пакетов — это пакет mlr3 для машинного обучения, который представляет собой большой расширяемый “пакет пакетов”, где отдельные пакеты посвящены отдельным этапам и задачам машинного обучения."
  },
  {
    "objectID": "020-install.html#r_built_in",
    "href": "020-install.html#r_built_in",
    "title": "2  Пакеты в R",
    "section": "2.2 Встроенные пакеты R",
    "text": "2.2 Встроенные пакеты R\nВообще, даже сам R является набором из нескольких пакетов: основного base и нескольких других, таких как stats, utils, graphics. Вот их полный список:\n\nrownames(installed.packages(priority = \"base\"))\n\n [1] \"base\"      \"compiler\"  \"datasets\"  \"graphics\"  \"grDevices\" \"grid\"     \n [7] \"methods\"   \"parallel\"  \"splines\"   \"stats\"     \"stats4\"    \"tcltk\"    \n[13] \"tools\"     \"utils\"    \n\n\nЧтобы пользоваться этими пакетами ничего дополнительно делать не нужно."
  },
  {
    "objectID": "020-install.html#install_cran",
    "href": "020-install.html#install_cran",
    "title": "2  Пакеты в R",
    "section": "2.3 Установка пакетов с CRAN",
    "text": "2.3 Установка пакетов с CRAN\nФункция install.packages() позволяет скачивать пакеты с Comprehensive R Archive Network (CRAN). На репозитории CRAN собрано более 16000 пакетов. Каждый из этих пакетов проходит проверку перед попаданием в CRAN: он должен быть хорошо задокументирован, стабильно работать и решать какую-то задачу.\nДля примера установим пакет remotes. Это пакет для удобной установки пакетов не с CRAN и скоро нам понадобится.\n\ninstall.packages(\"remotes\")\n\nПри установке вы увидите много непонятных надписей красным шрифтом. Не пугайтесь, это нормально, происходит скачивание и установка пакетов. В конце вы увидите что-то вроде этого:\n!()images/install_success.png\nИногда установка бывает очень долгой, потому что большие пакеты склонны иметь много зависимостей: для работы какого-то пакета может понадобиться другие пакеты, а для тех пакетов - еще какие-то пакеты. Таким образом, устанавливая какой-нибудь современный пакет, вы, возможно, установите десятки других пакетов! Зато если они понадобятся сами по себе, то их уже не нужно будет устанавливать."
  },
  {
    "objectID": "020-install.html#package_load",
    "href": "020-install.html#package_load",
    "title": "2  Пакеты в R",
    "section": "2.4 Загрузка установленного пакета",
    "text": "2.4 Загрузка установленного пакета\nУстановить пакет с помощью install.packages() недостаточно, пакет нужно еще загрузить. Для этого есть функция library().\n\nlibrary(\"remotes\")\n\nВ отличие от install.packages(), функция library() принимает название пакета и как строчку в кавычках, и как название без кавычек.\n\nlibrary(remotes)\n\nТеперь функции, данные и классы из пакета доступны для работы."
  },
  {
    "objectID": "020-install.html#from_package",
    "href": "020-install.html#from_package",
    "title": "2  Пакеты в R",
    "section": "2.5 Вызов функции из пакета с помощью ::",
    "text": "2.5 Вызов функции из пакета с помощью ::\nЕсли пакетом нужно воспользоваться всего один-два раза, то имеет смысл не подключать весь пакет, а загрузить отдельную функцию из него. Для этого есть специальный оператор ::, который использует функцию (указанную справа от ::) из выбранного пакета (указанного слева от ::), не загружая пакет полностью.\nДля примера воспользуемся функцией package_deps() из только что установленного пакета remotes, которая возвращает все зависимости пакета:\n\nremotes::package_deps(\"tidyverse\")\n\nNeeds update -----------------------------\n package      installed    available    is_cran remote\n utf8         1.2.1        1.2.2        TRUE    CRAN  \n withr        2.4.2        2.5.0        TRUE    CRAN  \n fansi        0.5.0        1.0.3        TRUE    CRAN  \n cli          3.2.0        3.4.1        TRUE    CRAN  \n pillar       1.7.0        1.8.1        TRUE    CRAN  \n generics     0.1.2        0.1.3        TRUE    CRAN  \n cpp11        0.4.2        0.4.3        TRUE    CRAN  \n vctrs        0.4.0        0.5.0        TRUE    CRAN  \n tidyselect   1.1.2        1.2.0        TRUE    CRAN  \n tibble       3.1.6        3.1.8        TRUE    CRAN  \n rlang        1.0.2        1.0.6        TRUE    CRAN  \n purrr        0.3.4        0.3.5        TRUE    CRAN  \n magrittr     2.0.1        2.0.3        TRUE    CRAN  \n lifecycle    1.0.1        1.0.3        TRUE    CRAN  \n dplyr        1.0.8        1.0.10       TRUE    CRAN  \n stringi      1.6.2        1.7.8        TRUE    CRAN  \n sys          3.4          3.4.1        TRUE    CRAN  \n stringr      1.4.0        1.4.1        TRUE    CRAN  \n openssl      1.4.5        2.0.4        TRUE    CRAN  \n jsonlite     1.7.2        1.8.3        TRUE    CRAN  \n curl         4.3.2        4.3.3        TRUE    CRAN  \n xml2         1.3.2        1.3.3        TRUE    CRAN  \n httr         1.4.2        1.4.4        TRUE    CRAN  \n ps           1.6.0        1.7.2        TRUE    CRAN  \n digest       0.6.27       0.6.30       TRUE    CRAN  \n memoise      2.0.0        2.0.1        TRUE    CRAN  \n cachem       1.0.5        1.0.6        TRUE    CRAN  \n sass         0.4.0        0.4.2        TRUE    CRAN  \n tinytex      0.35         0.42         TRUE    CRAN  \n htmltools    0.5.1.1      0.5.3        TRUE    CRAN  \n bslib        0.2.5.1      0.4.0        TRUE    CRAN  \n xfun         0.24         0.34         TRUE    CRAN  \n yaml         2.2.1        2.3.6        TRUE    CRAN  \n evaluate     0.14         0.17         TRUE    CRAN  \n processx     3.5.2        3.8.0        TRUE    CRAN  \n rstudioapi   0.13         0.14         TRUE    CRAN  \n rmarkdown    2.11         2.17         TRUE    CRAN  \n knitr        05ccb074d... 36efc0001... FALSE   GitHub\n fs           1.5.0        1.5.2        TRUE    CRAN  \n clipr        0.7.1        0.8.0        TRUE    CRAN  \n callr        3.7.0        3.7.2        TRUE    CRAN  \n crayon       1.4.1        1.5.2        TRUE    CRAN  \n hms          1.1.0        1.1.2        TRUE    CRAN  \n tzdb         0.1.0        0.3.0        TRUE    CRAN  \n vroom        1.3.2        1.6.0        TRUE    CRAN  \n colorspace   2.0-1        2.0-3        TRUE    CRAN  \n viridisLite  0.4.0        0.4.1        TRUE    CRAN  \n RColorBrewer 1.1-2        1.1-3        TRUE    CRAN  \n farver       2.1.0        2.1.1        TRUE    CRAN  \n scales       1.1.1        1.2.1        TRUE    CRAN  \n isoband      0.2.4        0.2.6        TRUE    CRAN  \n gtable       0.3.0        0.3.1        TRUE    CRAN  \n ggplot2      3.3.5        3.3.6        TRUE    CRAN  \n backports    1.2.0        1.4.1        TRUE    CRAN  \n tidyr        1.2.0        1.2.1        TRUE    CRAN  \n broom        0.8.0        1.0.1        TRUE    CRAN  \n readr        1.4.0        2.1.3        TRUE    CRAN  \n forcats      0.5.1        0.5.2        TRUE    CRAN  \n uuid         0.1-4        1.1-0        TRUE    CRAN  \n gargle       1.2.0        1.2.1        TRUE    CRAN  \n data.table   1.14.2       1.14.4       TRUE    CRAN  \n DBI          1.1.1        1.1.3        TRUE    CRAN  \n blob         1.2.1        1.2.3        TRUE    CRAN  \n rvest        1.0.0        1.0.3        TRUE    CRAN  \n reprex       1.0.0        2.0.2        TRUE    CRAN  \n readxl       1.3.1        1.4.1        TRUE    CRAN  \n modelr       0.1.8        0.1.9        TRUE    CRAN  \n lubridate    1.7.10       1.8.0        TRUE    CRAN  \n haven        2.3.1        2.5.1        TRUE    CRAN  \n googleshe... 1.0.0        1.0.1        TRUE    CRAN  \n dtplyr       NA           1.2.2        TRUE    CRAN  \n dbplyr       2.0.0        2.2.1        TRUE    CRAN  \n tidyverse    1.3.0        1.3.2        TRUE    CRAN  \n\n\nВ дальнейшем использование оператора :: будет иногда использоваться, чтобы указать, из какого пакета взята функция.\nОператор :: полезен еще и в тех случаях, когда в разных пакетах присутствуют функции с одинаковым названием. Например, у основного пакета tidyverse, dplyr, есть функция filter(). Функция с точно таким же названием есть в базовом R в пакете stats, в котором та выполняет совершенно другую задачу. Если у вас уже загружен dplyr, то использование :: укажет на то, что вы хотите воспользоваться именно функцией filter() из пакета stats:\n\nstats::filter(1:20, rep(1,3))\n\nTime Series:\nStart = 1 \nEnd = 20 \nFrequency = 1 \n [1] NA  6  9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 NA\n\n\nПодобные путаницы могут возникнуть, если у вас загружено много пакетов, поэтому старайтесь не загружать слишком много пакетов, а если есть функции с одинаковым названием, то обязательно используйте оператор ::. Иначе слишком велик риск загрузить пакеты не в том порядке и получить из-за этого ошибку или некорректный результат. Выгрузить ненужный пакет можно с помощью функции detach().\n\ndetach(package:remotes)"
  },
  {
    "objectID": "020-install.html#install_bioc",
    "href": "020-install.html#install_bioc",
    "title": "2  Пакеты в R",
    "section": "2.6 Установка пакетов c Bioconductor",
    "text": "2.6 Установка пакетов c Bioconductor\nУ биологов есть свой большой репозиторий, который является альтернативой CRAN, — Bioconductor. С него можно скачать множество специализированных пакетов для работы с биологическими данными.\nДля установки пакетов с Bioconductor сначала нужно скачать пакет BiocManager с CRAN.\n\ninstall.packages(\"BiocManager\")\n\nТеперь можно воспользоваться функцией install() из пакета BiocManager для установки пакета flowCore — пакета для анализа данных проточной цитометрии.\n\nBiocManager::install(\"flowCore\")"
  },
  {
    "objectID": "020-install.html#install_github",
    "href": "020-install.html#install_github",
    "title": "2  Пакеты в R",
    "section": "2.7 Установка пакетов с Github",
    "text": "2.7 Установка пакетов с Github\nНекоторых пакетов нет ни на CRAN, ни на Bioconductor. Обычно это касается пакетов, разработчики которых по каким-либо причинам решили не проходить проверки или не прошли проверки на строгие требования CRAN. Иногда бывает, что пакет был удален с CRAN (например, автор давно не занимается им) или же версия пакета на CRAN отстает от последней, а именно в ней реализованы так нужные вам функции. В некоторых случаях пакета может не быть на CRAN, потому что его разработчики активно занимаются его развитием и постоянно переделывают уже имеющийся функционал, добавляя новые возможности и удаляя старые. Это нужно делать с осторожностью, когда пакет уже выложен на CRAN, потому что если функции новой версии пакета будут работать по-другому, то это может вызвать массу проблем.\nВо всех этих случаях пакет обычно можно скачать с репозитория Github. Для этого нам понадобится уже установленный (с CRAN, разумеется) пакет remotes1.\n\nremotes::install_github(\"dracor-org/rdracor\")\n\nТеперь установленный пакет осталось загрузить, после чего им можно пользоваться.\n\nlibrary(rdracor)\n\nWarning: replacing previous import 'igraph::as_data_frame' by\n'tibble::as_data_frame' when loading 'rdracor'\n\ngodunov <- play_igraph(corpus = \"rus\",\n                       play = \"pushkin-boris-godunov\")\nplot(godunov)\n\n\n\n\nПакет remotes можно так же использовать для загрузки пакетов из Bioconductor:\n\nremotes::install_bioc(\"flowCore\")"
  },
  {
    "objectID": "020-install.html#where_packages",
    "href": "020-install.html#where_packages",
    "title": "2  Пакеты в R",
    "section": "2.8 Где искать нужные пакеты",
    "text": "2.8 Где искать нужные пакеты\nМы разобрались с тем, как устанавливать пакеты. А где же их находить?\nЭто вопрос гораздо более сложный чем может показаться. Например, можно работать в R и не знать, что существует пакет, который решает нужную для вас задачу. Или же найти такой пакет и не знать, что есть более современный пакет, который делает это еще лучше!\nЗдесь нет каких-то готовых решений. CRAN пытается создавать и поддерживать тематические списки (Task View) пакетов с описанием задач, которые они решают:\nhttps://cran.r-project.org/web/views/\nБезусловно, если вы глубоко занимаетесь какой-либо темой из списка, то стоит изучить соотвестствующий Task View, но начинать знакомство с помощью Task View достаточно тяжело.\nДругой вариант — просто погуглить, найти релевантные статьи или книги. Внимательно смотрите на дату публикации: R — очень быстро развивающийся язык, поэтому с большой вероятностью то, что было написано пять лет назад уже потеряло актуальность. Нет, работать это будет, но, скорее всего, появился более удобный и продвинутый инструмент."
  },
  {
    "objectID": "005-whole_r_intro.html",
    "href": "005-whole_r_intro.html",
    "title": "Основы R и Rstudio",
    "section": "",
    "text": "В части ВВЕДЕНИЕ разбирается установка R и RStudio, как вводить команды и сохранять скрипты, создавать переменные, испо"
  },
  {
    "objectID": "010-intro.html",
    "href": "010-intro.html",
    "title": "2  Введение в R",
    "section": "",
    "text": "Для работы с R необходимо его сначала скачать и установить.\n\nR\n\nна Windows, найдите большую кнопку Download R (номер версии) for Windows.\nна Mac, если маку меньше, чем 5 лет, то смело ставьте *.pkg файл с последней версией. Если старше, то поищите на той же странице версию для вашей системы.\nна Linux, также можно добавить зеркало и установить из командной строки:\n\n\n\nsudo apt-get install r-cran-base\nВ данной книге используется следующая версия R:\n\nsessionInfo()$R.version$version.string\n\n[1] \"R version 4.0.2 (2020-06-22)\"\n\n\nПосле установки R необходимо скачать и установить RStudio:\n\nRStudio\n\nЕсли вдруг что-то установить не получается (или же вы просто не хотите устанавливать на компьютер лишние программы), то можно работать в облаке, делая все то же самое в веб-браузере:\n\nRStudio cloud\n\nПервый и вполне закономерный вопрос: зачем мы ставили R и отдельно еще какой-то RStudio? Если опустить незначительные детали, то R – это сам язык программирования, а RStudio – это среда (IDE), которая позволяет в этом языке очень удобно работать.\n\nRStudio – это не единственная среда для R, но, определенно, самая удобная на сегодняшний день. Почти все пользуются именно ею и не стоит тратить время на поиск чего-то более удобного и лучшего. Если же вы привыкли работать с Jupyter Notebook, то в R обычно вместо него используется великолепный RMarkdown – с помощью которого и написан этот онлайн-учебник, кстати говоря. И с RMarkdown мы тоже будем разбираться!"
  },
  {
    "objectID": "010-intro.html#rstudio",
    "href": "010-intro.html#rstudio",
    "title": "2  Введение в R",
    "section": "2.2 Знакомство с RStudio",
    "text": "2.2 Знакомство с RStudio\nТак, давайте взглянем на то, что нам тут открылось:\n\nВ первую очередь нас интересуют два окна: 1 - Code Editor (окно для написания скриптов) 1 и 2 - R Console (консоль). Здесь можно писать команды и запускать их. При этом работа в консоли и работа со скриптом немного различается.\nВ 2 - R Console вы пишите команду и запускаете ее нажиманием Enter. Иногда после запуска команды появляется какой-то результат. Если нажимать стрелку вверх на клавиатуре, то можно выводить в консоль предыдущие команды. Это очень удобно для запуска предыдущих команд с небольшими изменениями.\nВ 1 - Code Editor для запуска команды вы должны выделить ее и нажать Ctrl + Enter (Cmd + Enter на macOS). Если не нажать эту комбинацию клавиш, то команда не запустится. Можно выделить и запустить сразу несколько команд или даже все команды скрипта. Все команды скрипта можно выделить с помощью сочетания клавиш Ctrl + A на Windows и Linux, Cmd + A на macOS 2. Как только вы запустите команду (или несколько команд), соответствующие строчки кода появятся в 2 - R Console, как будто бы вы запускали их прямо там.\nОбычно в консоли удобно что-то писать, чтобы быстро что-то посчитать. Скрипты удобнее при работе с длинными командами и как способ сохранения написанного кода для дальнейшей работы. Для сохранения скрипта нажмите File - Save As.... R скрипты сохраняются с разрешением .R, но по своей сути это просто текстовые файлы, которые можно открыть и модифицировать в любом текстовом редакторе а-ля “Блокнот”.\n3 - Workspace and History – здесь можно увидеть переменные. Это поле будет автоматически обновляться по мере того, как Вы будете запускать строчки кода и создавать новые переменные. Еще там есть вкладка с историей всех команд, которые были запущены.\n4 - Plots and files. Здесь есть очень много всего. Во-первых, небольшой файловый менеджер, во-вторых, там будут появляться графики, когда вы будете их рисовать. Там же есть вкладка с вашими пакетами (Packages) и Help по функциям. Но об этом потом."
  },
  {
    "objectID": "010-intro.html#calc",
    "href": "010-intro.html#calc",
    "title": "2  Введение в R",
    "section": "2.3 R как калькулятор",
    "text": "2.3 R как калькулятор\nR – полноценный язык программирования, который позволяет решать широкий спектр задач. Но в первую очередь R используется для анализа данных и статистических вычислений. Тем не менее, многими R до сих пор воспринимается как просто продвинутый калькулятор. Ну что ж, калькулятор, так калькулятор.\nДавайте начнем с самого простого и попробуем использовать R как калькулятор с помощью арифметических операторов +, -, *, /, ^ (степень), () и т.д.\nПросто запускайте в консоли пока не надоест:\n\n40+2\n\n[1] 42\n\n3-2\n\n[1] 1\n\n5*6\n\n[1] 30\n\n99/9 #деление\n\n[1] 11\n\n2^3 #степень\n\n[1] 8\n\n13 %/% 3 #целочисленное деление\n\n[1] 4\n\n13 %% 3 #остаток от деления\n\n[1] 1\n\n\nПопробуйте самостоятельно посчитать что-нибудь с разными числами.\n\nНичего сложного, верно? Вводим выражение и получаем результат.\nВы могли заметить, что некоторые команды у меня заканчиваются знаком решетки (#). Все, что написано в строчке после # игнорируется R при выполнении команды. Написанные команды в скрипте рекомендуется сопровождать комментариями, которые будут объяснять вам же в будущем (или кому-то еще), что конкретно происходит в соответствующем куске кода 3. Кроме того, комментарии можно использовать в тех случаях, когда вы хотите написать кусок кода по-другому, не стирая полностью предыдущий код: достаточно “закомментить” нужные строчки - поставить # в начало каждой строки, которую вы хотите переписать. Для этого есть специальное сочетание горячих клавиш: Ctrl + Shift + C (Cmd + Shift + C на macOS) – во всех выделенных строчках будет написан # в начале.\nСогласно данным навязчивых рекламных баннеров в интернете, только 14% россиян могут справиться с этим примером:\n\n2 + 2 * 2\n\n[1] 6\n\n\nНа самом деле, разные языки программирования ведут себя по-разному в таких ситуациях, поэтому ответ 6 (сначала умножаем, потом складываем) не так очевиден.\nПорядок выполнения арифметических операций (т.е. приоритет операторов, operator precedence) в R как в математике, так что не забывайте про скобочки.\n\n(2+2)*2\n\n[1] 8\n\n\nЕсли Вы не уверены в том, какие операторы имеют приоритет, то используйте скобочки, чтобы точно обозначить, в каком порядке нужно производить операции. Или же смотрите на таблицу приоритета операторов с помощью команды ?Syntax."
  },
  {
    "objectID": "010-intro.html#func",
    "href": "010-intro.html#func",
    "title": "2  Введение в R",
    "section": "2.4 Функции",
    "text": "2.4 Функции\nДавайте теперь извлечем корень из какого-нибудь числа. В принципе, тем, кто помнит школьный курс математики, возведения в степень вполне достаточно:\n\n16 ^ 0.5\n\n[1] 4\n\n\nНу а если нет, то можете воспользоваться специальной функцией: это обычно какие-то буквенные символы с круглыми скобками сразу после названия функции. Мы подаем на вход (внутрь скобочек) какие-то данные, внутри этих функций происходят какие-то вычисления, которые выдает в ответ какие-то другие данные (или же функция записывает файл, рисует график и т.д.).\nВот, например, функция для корня:\n\nsqrt(16)\n\n[1] 4\n\n\n\nR – case-sensitive язык, т.е. регистр важен. SQRT(16) не будет работать.\n\nА вот так выглядит функция логарифма:\n\nlog(8)\n\n[1] 2.079442\n\n\nТак, вроде бы все нормально, но… Если Вы еще что-то помните из школьной математики, то должны понимать, что что-то здесь не так.\nЗдесь не хватает основания логарифма!\n\nЛогарифм – показатель степени, в которую надо возвести число, называемое основанием, чтобы получить данное число.\n\nТо есть у логарифма 8 по основанию 2 будет значение 3:\n\\(\\log_2 8 = 3\\)\nТо есть если возвести 2 в степень 3 у нас будет 8:\n\\(2^3 = 8\\)\nТолько наша функция считает все как-то не так.\nЧтобы понять, что происходит, нам нужно залезть в хэлп этой функции:\n\n?log\n\nСправа внизу в RStudio появится вот такое окно:\n\nДействительно, у этой функции есть еще аргумент base =. По умолчанию он равен числу Эйлера (2.7182818…), т.е. функция считает натуральный логарифм. В большинстве функций R есть какой-то основной инпут – данные в том или ином формате, а есть и дополнительные параметры, которые можно прописывать вручную, если параметры по умолчанию вас не устраивают.\n\nlog(x = 8, base = 2)\n\n[1] 3\n\n\n…или просто (если Вы уверены в порядке переменных):\n\nlog(8,2)\n\n[1] 3\n\n\nБолее того, Вы можете использовать результат выполнения одних функций в качестве аргумента для других:\n\nlog(8, sqrt(4))\n\n[1] 3\n\n\nЕсли эксплицитно писать имена аргументов, то их порядок в функции не важен:\n\nlog(base = 2, x = 8)\n\n[1] 3\n\n\nА еще можно писать имена аргументов не полностью, если они не совпадают с другими:\n\nlog(b = 2, x = 8)\n\n[1] 3\n\n\nМы еще много раз будем возвращаться к функциям. Вообще, функции – это одна из важнейших штук в R (примерно так же как и в Python). Мы будем создавать свои функции, использовать функции как инпут для функций и многое-многое другое. В R очень крутые возможности работы с функциями. Поэтому подружитесь с функциями, они клевые.\n\nАрифметические знаки, которые мы использовали: +,-,/,^ и т.д. называются операторами и на самом деле тоже являются функциями:\n\n\n'+'(3,4)\n\n[1] 7"
  },
  {
    "objectID": "010-intro.html#google",
    "href": "010-intro.html#google",
    "title": "2  Введение в R",
    "section": "2.5 В любой непонятной ситуации – гуглите",
    "text": "2.5 В любой непонятной ситуации – гуглите\nЕсли вдруг вы не знаете, что искать в хэлпе, или хэлпа попросту недостаточно, то… гуглите!\n\nНет ничего постыдного в том, чтобы гуглить решения проблем. Это абсолютно нормально. Используйте силу интернета во благо и да помогут вам Stackoverflow4 и бесчисленные R-туториалы!\n\n\nComputer Programming To Be Officially Renamed “Googling Stack Overflow”Source: http://t.co/xu7acfXvFF pic.twitter.com/iJ9k7aAVhd\n\n— Stack Exchange ((StackExchange?)) July 20, 2015\n\n\n\nГлавное, помните: загуглить работающий ответ всегда недостаточно. Надо понять, как и почему решение работает. Иначе что-то обязательно пойдет не так.\nКроме того, правильно загуглить проблему – не так уж и просто.\n\n\nDoes anyone ever get good at R or do they just get good at googling how to do things in R\n\n— 🔬🖤Lauren M. Seyler, Ph.D.❤️⚒ ((mousquemere?)) May 6, 2019\n\n\nКороче говоря: гуглить – хорошо, бездумно копировать чужие решения – плохо."
  },
  {
    "objectID": "010-intro.html#variables",
    "href": "010-intro.html#variables",
    "title": "2  Введение в R",
    "section": "2.6 Переменные",
    "text": "2.6 Переменные\nВажная штука в программировании на практически любом языке – возможность сохранять значения в переменных. В R это обычно делается с помощью вот этих символов: <- (но можно использовать и обычное =, хотя это не очень принято). Для этого есть удобное сочетание клавиш: нажмите одновременно Alt + - (или option + - на macOS).\n\nЗаметьте, при присвоении результат вычисления не выводится в консоль! Если опустить детали, то обычно результат выполнения комманды либо выводится в консоль, либо записывается в переменную.\n\n\na <- 2\na\n\n[1] 2\n\n\nСправа от <- находится значение, которое вы хотите сохранить, или же какое-то выражение, результат которого вы хотите сохранить в эту переменную5:\nСлева от <- находится название будущей переменной. Название переменных может быть самым разным. Есть несколько ограничений для синтаксически валидных имен переменных: они должны включать в себя буквы, цифры, . или _, начинаться на букву (или точку, за которой не будет следовать цифра), не должны совпадать с коротким списком зарезервированных слов. Короче говоря, название не должно включать в себя пробелы и большинство других знаков.\nНельзя: - new variable - _new_variable - .1var - v-r\nМожно: - new_variable - .new.variable - var_2\nОбязательно делайте названия переменных осмысленными! Старайтесь делать при этом их понятными и короткими, это сохранит вам очень много времени, когда вы (или кто-то еще) будете пытаться разобраться в написанном ранее коде. Если название все-таки получается длинным и состоящим из нескольких слов, то лучше всего использовать нижнее подчеркивание в качестве разделителя: some_variable6.\nПосле присвоения переменная появляется во вкладке Environment в RStudio:\n\nМожно использовать переменные в функциях и просто вычислениях:\n\nb <- a ^ a + a * a\nb\n\n[1] 8\n\nlog(b, a)\n\n[1] 3"
  },
  {
    "objectID": "010-intro.html#logic",
    "href": "010-intro.html#logic",
    "title": "2  Введение в R",
    "section": "2.7 Логические операторы",
    "text": "2.7 Логические операторы\nВы можете сравнивать разные переменные:\n\na == b\n\n[1] FALSE\n\n\nЗаметьте, что сравнивая две переменные мы используем два знака равно ==, а не один =. Иначе это будет означать присвоение.\n\na = b\na\n\n[1] 8\n\n\nТеперь Вы сможете понять комикс про восстание роботов на следующей странице (пусть он и совсем про другой язык программирования)\n\nЭтот комикс объясняет, как важно не путать присваивание и сравнение (хотя я иногда путаю до сих пор =( ).\nИногда нам нужно проверить на неравенство:\n\na <- 2\nb <- 3\n\na == b\n\n[1] FALSE\n\na != b\n\n[1] TRUE\n\n\nВосклицательный язык в программировании вообще и в R в частности стандартно означает отрицание.\nЕще мы можем сравнивать на больше/меньше:\n\na > b\n\n[1] FALSE\n\na < b\n\n[1] TRUE\n\na >= b\n\n[1] FALSE\n\na <= b\n\n[1] TRUE\n\n\nЭтим мы будем пользоваться в дальнейшем регулярно! Именно на таких простых логических операциях построено большинство операций с данными.\n##Типы данных {#data_types}\nДо этого момента мы работали только с числами (numeric):\n\nclass(a)\n\n[1] \"numeric\"\n\n\nНа самом деле, в R три типа numeric: integer (целые), double (дробные), complex (комплексные числа)7. R сам будет конвертировать числа в нужный тип numeric при необходимости, поэтому этим можно не заморачиваться.\nЕсли же все-таки нужно задать конкретный тип числа эксплицитно, то можно воспользоваться функциями as.integer(), as.double() и as.complex(). Кроме того, при создании числа можно поставить в конце L, чтобы обозначить число как integer:\n\nis.integer(5)\n\n[1] FALSE\n\nis.integer(5L)\n\n[1] TRUE\n\n\nПро double есть еще один маленький секрет. Дело в том, что дробные числа хранятся в R как числа с плавающей запятой двойной точности. Дробные числа в компьютере могут быть записаны только с определенной степенью точности, поэтому иногда встречаются вот такие вот ситуации:\n\nsqrt(2)^2 == 2\n\n[1] FALSE\n\n\nЭто довольно стандартная ситуация, характерная не только для R. Чтобы ее избежать, можно воспользоваться функцией all.equal():\n\nall.equal(sqrt(2)^2, 2)\n\n[1] TRUE\n\n\nТеперь нам нужно ознакомиться с двумя другими важными типами данных в R:\n\nСтроковые (character) данные: набор букв, цифр и символов, которые должны выделяться кавычками.\n\n\ns <- \"Всем привет!\"\ns\n\n[1] \"Всем привет!\"\n\nclass(s)\n\n[1] \"character\"\n\n\nМожно использовать как \", так и ' (что удобно, когда строчка внутри уже содержит какие-то кавычки).\n\n\"Ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn\"\n\n[1] \"Ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn\"\n\n\n\nЛогические (logical) данные: просто TRUE или FALSE.\n\n\nt1 <- TRUE\nf1 <- FALSE\n\nt1\n\n[1] TRUE\n\nf1\n\n[1] FALSE\n\n\nВообще, можно еще писать T и F (но не True и False!)\n\nt2 <- T\nf2 <- F\n\nЭто плохая практика, так как R защищает от перезаписи переменные TRUE и FALSE, но не защищает от этого T и F.\n\nTRUE <- FALSE\n\nError in TRUE <- FALSE: invalid (do_set) left-hand side to assignment\n\nTRUE\n\n[1] TRUE\n\nT <- FALSE\nT\n\n[1] FALSE\n\n\nФункция rm() позволяет удалить ненужную переменную:\n\nrm(T)\n\nМы уже встречались с логическими значениями при сравнении двух числовых переменных. Теперь вы можете догадаться, что результаты сравнения, например, числовых или строковых переменных, можно тоже сохранять в переменные!\n\ncomparison <- a == b\ncomparison\n\n[1] FALSE\n\n\nЭто нам очень понадобится, когда мы будем работать с реальными данными: нам нужно будет постоянно вытаскивать какие-то данные из датасета, что как раз и построено на игре со сравнением переменных.\nЧтобы этим хорошо уметь пользоваться, нам нужно еще освоить как работать с логическими операторами. Про один мы немного уже говорили – это логическое НЕ (!). ! превращает TRUE в FALSE, а FALSE в TRUE:\n\nt1\n\n[1] TRUE\n\n!t1\n\n[1] FALSE\n\n!!t1 #Двойное отрицание!\n\n[1] TRUE\n\n\nЕще есть логическое И (выдаст TRUE только в том случае если обе переменные TRUE):\n\nt1 & t2\n\n[1] TRUE\n\nt1 & f1\n\n[1] FALSE\n\n\nА еще логическое ИЛИ (выдаст TRUE в случае если хотя бы одна из переменных TRUE):\n\nt1 | f1\n\n[1] TRUE\n\nf1 | f2\n\n[1] FALSE\n\n\nЕсли кому-то вдруг понадобится другое ИЛИ (строгое ЛИБО) – есть функция xor(), принимающая два аргумента и возвращая TRUE только в том случае, если ровно один из двух аргументов равен TRUE.\nИтак, мы только что разобрались с самой занудной (хотя и важной) частью - с основными типа данных в R и как с ними работать8. Пора переходить к чему-то более интересному и специфическому для R. Вперед к ВЕКТОРАМ!"
  },
  {
    "objectID": "013-vector.html",
    "href": "013-vector.html",
    "title": "3  Вектор",
    "section": "",
    "text": "Если у вас не было линейной алгебры (или у вас с ней было все плохо), то просто запомните, что вектор (atomic vector или просто atomic) – это набор (столбик) чисел в определенном порядке.\nЕсли вы привыкли из школьного курса физики считать вектора стрелочками, то не спешите возмущаться и паниковать. Представьте стрелочки как точки из нуля координат {0,0} до какой-то точки на координатной плоскости, например, {2,3}:\n\nВот последние два числа и будем считать вектором. Попытайтесь теперь мысленно стереть координатную плоскость и выбросить стрелочки из головы, оставив только последовательность чисел {2,3}:\n\nНа самом деле, мы уже работали с векторами в R, но, возможно, вы об этом даже не догадывались. Дело в том, что в R нет как таковых скалярных (т.е. одиночных) значений, есть вектора длиной 1. Такие дела!\nЧтобы создать вектор из нескольких значений, нужно воспользоваться функцией c():\n\nc(4, 8, 15, 16, 23, 42)\n\n[1]  4  8 15 16 23 42\n\nc(\"Хэй\", \"Хэй\", \"Ха\")\n\n[1] \"Хэй\" \"Хэй\" \"Ха\" \n\nc(TRUE, FALSE)\n\n[1]  TRUE FALSE\n\n\n\nОдна из самых мерзких и раздражающих причин ошибок в коде – это использование с из кириллицы вместо c из латиницы. Видите разницу? И я не вижу. А R видит. И об этом сообщает:\n\n\nс(3, 4, 5)\n\nError in с(3, 4, 5): could not find function \"с\"\n\n\nДля создания числовых векторов есть удобный оператор :.\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n5:-3\n\n[1]  5  4  3  2  1  0 -1 -2 -3\n\n\nЭтот оператор создает вектор от первого числа до второго с шагом 1. Вы не представляете, как часто эта штука нам пригодится… Если же нужно сделать вектор с другим шагом, то есть функция seq():\n\nseq(10, 100, by = 10)\n\n [1]  10  20  30  40  50  60  70  80  90 100\n\n\nКроме того, можно задавать не шаг, а длину вектора. Тогда функция seq() сама посчитает шаг:\n\nseq(1, 13, length.out = 4)\n\n[1]  1  5  9 13\n\n\nДругая функция – rep() – позволяет создавать вектора с повторяющимися значениями. Первый аргумент – значение, которое нужно повторять, а второй аргумент – сколько раз повторять.\n\nrep(1, 5)\n\n[1] 1 1 1 1 1\n\n\nИ первый, и второй аргумент могут быть векторами!\n\nrep(1:3, 3)\n\n[1] 1 2 3 1 2 3 1 2 3\n\nrep(1:3, 1:3)\n\n[1] 1 2 2 3 3 3\n\n\nЕще можно объединять вектора (что мы, по сути, и делали, просто с векторами длиной 1):\n\nv1 <- c(\"Hey\", \"Ho\")\nv2 <- c(\"Let's\", \"Go!\")\nc(v1, v2)\n\n[1] \"Hey\"   \"Ho\"    \"Let's\" \"Go!\"  \n\n\nОчень многие функции в R работают именно с векторами. Например, функции sum() (считает сумму значений вектора) и mean() (считает среднее арифметическое всех значений в векторе):\n\nsum(1:10)\n\n[1] 55\n\nmean(1:10)\n\n[1] 5.5"
  },
  {
    "objectID": "013-vector.html#coercion",
    "href": "013-vector.html#coercion",
    "title": "3  Вектор",
    "section": "3.2 Приведение типов",
    "text": "3.2 Приведение типов\nЧто будет, если вы объедините два вектора с значениями разных типов? Ошибка?\nМы уже обсуждали, что в обычных векторах (atomic векторах) может быть только один тип данных. В некоторых языках программирования при операции с данными разных типов мы бы получили ошибку. А вот в R при несовпадении типов произойдет попытка привести типы к “общему знаменателю”, то есть конвертировать данные в более “широкий” тип (а иногда – более “узкий” тип, если того требует функция).\nНапример:\n\nc(FALSE, 2)\n\n[1] 0 2\n\n\nFALSE превратился в 0 (а TRUE превратился бы в 1), чтобы оба значения можно было объединить в вектор. То же самое произошло бы в случае операций с векторами:\n\n2 + TRUE\n\n[1] 3\n\n\nЭто называется неявным приведением типов (implicit coercion).\nВот более сложный пример:\n\nc(TRUE, 3, \"Привет\")\n\n[1] \"TRUE\"   \"3\"      \"Привет\"\n\n\nЗдесь все значения были приведены сразу к строковому типу данных.\nУ R есть иерархия приведения типов:\nNULL < raw < logical < integer < double < complex < character < list < expression.\nМы из этого списка еще многого не знаем, сейчас важно запомнить, что логические данные – TRUE и FALSE – превращаются в 0 и 1 соответственно, а 0 и 1 в строчки \"0\" и \"1\".\nЕсли Вы боитесь полагаться на приведение типов, то можете воспользоваться функциями as.нужныйтипданных для явного приведения типов (explicit coercion):\n\nas.numeric(c(TRUE, FALSE, FALSE))\n\n[1] 1 0 0\n\nas.character(as.numeric(c(TRUE, FALSE, FALSE)))\n\n[1] \"1\" \"0\" \"0\"\n\n\nМожно превращать и обратно, например, строковые значения в числовые. Если среди числа встретится буква или другой неподходящий знак, то мы получим предупреждение NA – пропущенное значение (мы очень скоро научимся с ними работать).\n\nas.numeric(c(\"1\", \"2\", \"три\"))\n\nWarning: NAs introduced by coercion\n\n\n[1]  1  2 NA\n\n\n\nОдин из распространенных примеров использования неявного приведения типов – использования функций sum() и mean() для подсчета в логическом векторе количества и доли TRUE соответсвенно. Мы будем много раз пользоваться этим приемом в дальнейшем!"
  },
  {
    "objectID": "013-vector.html#vector_op",
    "href": "013-vector.html#vector_op",
    "title": "3  Вектор",
    "section": "3.3 Векторизация",
    "text": "3.3 Векторизация\nВсе те арифметические операторы, что мы использовали ранее, можно использовать с векторами одинаковой длины:\n\nn <- 1:4\nm <- 4:1\nn + m\n\n[1] 5 5 5 5\n\nn - m\n\n[1] -3 -1  1  3\n\nn * m\n\n[1] 4 6 6 4\n\nn / m\n\n[1] 0.2500000 0.6666667 1.5000000 4.0000000\n\nn ^ m + m * (n - m)\n\n[1] -11   5  11   7\n\n\nЕсли применить операторы на двух векторах одинаковой длины, то мы получим результат поэлементного применения оператора к двум векторам. Это называется векторизацией (vectorization).\n\nЕсли после какого-нибудь MATLAB Вы привыкли, что по умолчанию операторы работают по правилам линейной алгебры и m * n будет давать скалярное произведение (dot product), то снова нет. Для скалярного произведения нужно использовать операторы с % по краям:\n\n\nn %*% m\n\n     [,1]\n[1,]   20\n\n\n\nАбсолютно так же и с операциями с матрицами в R, хотя про матрицы будет немного позже.\n\nВ принципе, большинство функций в R, которые работают с отдельными значениями, так же хорошо работают и с целыми векторами. Скажем, если вы хотите извлечь корень из нескольких чисел, то для этого не нужны никакие циклы (как это обычно делается во многих других языках программирования). Можно просто “скормить” вектор функции и получить результат применения функции к каждому элементу вектора:\n\nsqrt(1:10)\n\n [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427\n [9] 3.000000 3.162278\n\n\nТаких векторизованных функций в R очень много. Многие из них написаны на более низкоуровневых языках программирования (C, C++, FORTRAN), за счет чего использование таких функций приводит не только к более элегантному, лаконичному, но и к более быстрому коду.\n\nВекторизация в R – это очень важная фишка, которая отличает этот язык программирования от многих других. Если вы уже имеете опыт программирования на другом языке, то вам во многих задачах захочется использовать циклы типа for и while @ref(for). Не спешите этого делать! В очень многих случаях циклы можно заменить векторизацией. Тем не менее, векторизация – это не единственный способ избавить от циклов типа for и while @ref(apply)."
  },
  {
    "objectID": "013-vector.html#recycling",
    "href": "013-vector.html#recycling",
    "title": "3  Вектор",
    "section": "3.4 Ресайклинг",
    "text": "3.4 Ресайклинг\nДопустим мы хотим совершить какую-нибудь операцию с двумя векторами. Как мы убедились, с этим обычно нет никаких проблем, если они совпадают по длине. А что если вектора не совпадают по длине? Ничего страшного! Здесь будет работать правило ресайклинга (правило переписывания, recycling rule). Это означает, что если мы делаем операцию на двух векторах разной длины, то если короткий вектор кратен по длине длинному, короткий вектор будет повторяться необходимое количество раз:\n\nn <- 1:4\nm <- 1:2\nn * m\n\n[1] 1 4 3 8\n\n\nА что будет, если совершать операции с вектором и отдельным значением? Можно считать это частным случаем ресайклинга: короткий вектор длиной 1 будет повторятся столько раз, сколько нужно, чтобы он совпадал по длине с длинным:\n\nn * 2\n\n[1] 2 4 6 8\n\n\nЕсли же меньший вектор не кратен большему (например, один из них длиной 3, а другой длиной 4), то R посчитает результат, но выдаст предупреждение.\n\nn + c(3,4,5)\n\nWarning in n + c(3, 4, 5): longer object length is not a multiple of shorter\nobject length\n\n\n[1] 4 6 8 7\n\n\nПроблема в том, что эти предупреждения могут в неожиданный момент стать причиной ошибок. Поэтому не стоит полагаться на ресайклинг некратных по длине векторов. А вот ресайклинг кратных по длине векторов – это очень удобная штука, которая используется очень часто."
  },
  {
    "objectID": "013-vector.html#index_atomic",
    "href": "013-vector.html#index_atomic",
    "title": "3  Вектор",
    "section": "3.5 Индексирование векторов",
    "text": "3.5 Индексирование векторов\nИтак, мы подошли к одному из самых сложных моментов. И одному из основных. От того, как хорошо вы научись с этим работать, зависит весь ваш дальнейший успех на R-поприще!\nРечь пойдет об индексировании векторов. Задача, которую Вам придется решать каждые пять минут работы в R – как выбрать из вектора (или же списка, матрицы и датафрейма) какую-то его часть. Для этого используются квадратные скобочки [] (не круглые – они для функций!).\nСамое простое – индексировать по номеру индекса, т.е. порядку значения в векторе.\n\nn <- c(0, 1, 1, 2, 3, 5, 8, 13, 21, 34)\nn[1]\n\n[1] 0\n\nn[10]\n\n[1] 34\n\n\n\nЕсли вы знакомы с другими языками программирования (не MATLAB, там все так же) и уже научились думать, что индексация с 0 – это очень удобно и очень правильно (ну или просто свыклись с этим), то в R вам придется переучиться обратно. Здесь первый индекс – это 1, а последний равен длине вектора – ее можно узнать с помощью функции length(). С обоих сторон индексы берутся включительно.\n\nС помощью индексирования можно не только вытаскивать имеющиеся значения в векторе, но и присваивать им новые:\n\nn[3] <- 20\nn\n\n [1]  0  1 20  2  3  5  8 13 21 34\n\n\nКонечно, можно использовать целые векторы для индексирования:\n\nn[4:7]\n\n[1] 2 3 5 8\n\nn[10:1]\n\n [1] 34 21 13  8  5  3  2 20  1  0\n\nn[4:6] <- 0\nn\n\n [1]  0  1 20  0  0  0  8 13 21 34\n\n\nИндексирование с минусом выдаст вам все значения вектора кроме выбранных:\n\nn[-1]\n\n[1]  1 20  0  0  0  8 13 21 34\n\nn[c(-4, -5)]\n\n[1]  0  1 20  0  8 13 21 34\n\n\nМинус здесь “выключает” выбранные значения из вектора, а не означает отсчет с конца как в Python.\nБолее того, можно использовать логический вектор для индексирования. В этом случае нужен логический вектор такой же длины:\n\nn[c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE)]\n\n[1]  0 20  0  8 21\n\n\nЛогический вектор работает здесь как фильтр: пропускает только те значения, где на соответствующей позиции в логическом векторе для индексирования содержится TRUE, и не пропускает те значения, где на соответствующей позиции в логическом векторе для индексирования содержится FALSE.\n\nНу а если эти два вектора (исходный вектор и логический вектор индексов) не равны по длине, то тут будет снова работать правило ресайклинга!\n\nn[c(TRUE, FALSE)] #то же самое - recycling rule!\n\n[1]  0 20  0  8 21\n\n\nЕсть еще один способ индексирования векторов, но он несколько более редкий: индексирование по имени. Дело в том, что для значений векторов можно (но не обязательно) присваивать имена:\n\nmy_named_vector <- c(first = 1,\n                     second = 2,\n                     third = 3)\nmy_named_vector['first']\n\nfirst \n    1 \n\n\nА еще можно “вытаскивать” имена из вектора с помощью функции names() и присваивать таким образом новые имена.\n\nd <- 1:4\nnames(d) <- letters[1:4]\nnames(d)\n\n[1] \"a\" \"b\" \"c\" \"d\"\n\nd[\"a\"]\n\na \n1 \n\n\n\nletters – это “зашитая” в R константа – вектор букв от a до z. Иногда это очень удобно! Кроме того, есть константа LETTERS – то же самое, но заглавными буквами. А еще в R есть названия месяцев на английском и числовая константа pi.\n\nВернемся к нашему вектору n и посчитаем его среднее с помощью функции mean():\n\nmean(n)\n\n[1] 9.7\n\n\nА как вытащить все значения, которые больше среднего?\nСначала получим логический вектор – какие значения больше среднего:\n\nlarger <- n > mean(n)\nlarger\n\n [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n\n\nА теперь используем его для индексирования вектора n:\n\nn[larger]\n\n[1] 20 13 21 34\n\n\nМожно все это сделать в одну строчку:\n\nn[n > mean(n)]\n\n[1] 20 13 21 34\n\n\nПредыдущая строчка отражает то, что мы будем постоянно делать в R: вычленять (subset) из данных отдельные куски на основании разных условий."
  },
  {
    "objectID": "013-vector.html#logic_vectors",
    "href": "013-vector.html#logic_vectors",
    "title": "3  Вектор",
    "section": "3.6 Работа с логическими векторами",
    "text": "3.6 Работа с логическими векторами\nНа работе с логическими векторами построено очень много удобных фишек, связанных со сравнением условий.\n\neyes <- c(\"green\", \"blue\", \"blue\", \"brown\", \"green\", \"blue\")\n\n\n3.6.1 mean() и sum() для подсчета пропорций и количества TRUE\nУже знакомая нам функция sum() позволяет посчитать количество TRUE в логическом векторе. Например, можно удобно посчитать сколько раз значение \"blue\" встречается в векторе eyes:\n\neyes == \"blue\"\n\n[1] FALSE  TRUE  TRUE FALSE FALSE  TRUE\n\nsum(eyes == \"blue\")\n\n[1] 3\n\n\nФункцию mean() можно использовать для подсчета пропорций TRUE в логическом векторе.\n\neyes == \"blue\"\n\n[1] FALSE  TRUE  TRUE FALSE FALSE  TRUE\n\nmean(eyes == \"blue\")\n\n[1] 0.5\n\n\nУмножив на 100, мы получим долю выраженную в процентах:\n\nmean(eyes == \"blue\") * 100\n\n[1] 50\n\n\n\n\n3.6.2 all() и any()\nФункция all() выдает TRUE только когда все значения логического вектора на входе равны TRUE:\n\nall(eyes == \"blue\")\n\n[1] FALSE\n\n\nФункция any() выдает TRUE когда есть хотя бы одно значение TRUE:\n\nany(eyes == \"blue\")\n\n[1] TRUE\n\n\nВместе с оператором ! можно получить много дополнительных вариантов. Например, есть ли хотя бы один FALSE в векторе?\n\nany(!eyes == \"blue\")\n\n[1] TRUE\n\n!all(eyes == \"blue\")\n\n[1] TRUE\n\n\nВсе ли значения в векторе равны FALSE?\n\nall(!eyes == \"blue\")\n\n[1] FALSE\n\n!any(eyes == \"blue\")\n\n[1] FALSE\n\n\n\n\n3.6.3 Превращение логических значений в индексы: which()\nКак вы уже знаете, и логические векторы, и числовые вектора с индексами могут использоваться для индексирования векторов. Иногда может понадобиться превратить логический вектор в вектор индексов. Для этого есть функция which()\n\nwhich(eyes == \"blue\")\n\n[1] 2 3 6\n\n\n\n\n3.6.4 оператор %in% и match()\nЧасто возникает такая задача: нужно проверить вектор на равенство с хотя бы одним значением из другого вектора. Например, мы хотим вычленить всех зеленоглазых и голубоглазых. Может возникнуть идея сделать так:\n\neyes[eyes == c(\"green\", \"blue\")]\n\n[1] \"green\" \"blue\"  \"green\" \"blue\" \n\n\nПеред нами самый страшный случай: результат похож на правильный, но не правильный! Попытайтесь самостоятельно понять почему этот ответ неверный и что произошло на самом деле.\nА на самом деле мы просто сравнили два вектора, один из которых короче другого, следовательно, у нас сработало правило ресайклинга.\n\nКак мы видим, это совсем не то, что нам нужно! В данной ситуации нам подойдет сравнение с двумя значениями вместе с логическим ИЛИ.\n\neyes[eyes == \"green\" | eyes == \"blue\"]\n\n[1] \"green\" \"blue\"  \"blue\"  \"green\" \"blue\" \n\n\nОднако это не очень удобно, особенно если значений больше 2. Тогда на помощь приходит оператор %in%, который выполняет именно то, что нам изначально нужно: выдает для каждого значения в векторе слева, есть ли это значение среди значений вектора справа.\n\neyes[eyes %in% c(\"green\", \"blue\")]\n\n[1] \"green\" \"blue\"  \"blue\"  \"green\" \"blue\" \n\n\nОсновное преимущество оператора %in% в его простоте и понятности. У оператора %in% есть старший брат, более сложный и более мощный. Функция match() работает похожим образом на %in%, но при совпадении значения в левом векторе с одним из значений в правом выдает индекс соответствующего значения вместо TRUE. Если же совпадений нет, то вместо FALSE функция match() выдает NA (что можно поменять параметром nomatch =).\n\nmatch(eyes, c(\"green\", \"blue\"))\n\n[1]  1  2  2 NA  1  2\n\n\nЗачем это может понадобиться? Во-первых, это способ соединить два набора данных (хотя для этого есть и более подходящие инструменты), во-вторых, так можно заменить все значения кроме выбранных заменить на NA.\n\nc(\"green\", \"blue\")[match(eyes, c(\"green\", \"blue\"))]\n\n[1] \"green\" \"blue\"  \"blue\"  NA      \"green\" \"blue\""
  },
  {
    "objectID": "013-vector.html#na",
    "href": "013-vector.html#na",
    "title": "3  Вектор",
    "section": "3.7 NA - пропущенные значения",
    "text": "3.7 NA - пропущенные значения\nВ реальных данных у нас часто чего-то не хватает. Например, из-за технической ошибки или невнимательности не получилось записать какое-то измерение. Для обозначения пропущенных значений в R есть специальное значение NA (расшифровывается как Not Available - недоступное значение). NA – это не строка \"NA\", не 0, не пустая строка \"\" и не FALSE. NA – это NA. Большинство операций с векторами, содержащими NA будут выдавать NA:\n\nmissed <- NA\nmissed == \"NA\"\n\n[1] NA\n\nmissed == \"\"\n\n[1] NA\n\nmissed == NA\n\n[1] NA\n\n\nЗаметьте, даже сравнение NA c NA выдает NA. Это может прозвучать абсурдно: ну как же так, и то NA, и другое NA – это же одно и то же, они должны быть равны! Не совсем: NA – это отсутствие информации об объекте, неопределенность, неизвестная нам величина. Если мы не знаем двух значений (т.е. имеем два NA), то это еще не значит, что они равны.\nИногда наличие NA в данных очень бесит:\n\nn[5] <- NA\nn\n\n [1]  0  1 20  0 NA  0  8 13 21 34\n\nmean(n)\n\n[1] NA\n\n\nПолучается, что наличие NA “заражает” неопределенностью все последующие действия. Что же делать?\nНаверное, надо сравнить вектор с NA и исключить этих пакостников. Давайте попробуем:\n\nn == NA\n\n [1] NA NA NA NA NA NA NA NA NA NA\n\n\nАх да, мы ведь только что узнали, что даже сравнение NA c NA приводит к NA! Сначала это может показаться нелогичным: ведь с обоих сторон NA, почему же тогда результат их сравнения – это тоже NA, а не TRUE?\nДело в том, что сравнивая две неопределенности, вы не можете установить между ними знак равенства. Представим себе двух супергероев: Бэтмена и Спайдермена. Допустим, мы не знаем их рост:\n\nBatman <- NA\nSpiderman <- NA\n\nОдинаковый ли у них рост?\n\nBatman == Spiderman\n\n[1] NA\n\n\nМы не знаем! Возможно, да, возможно, и нет. Поэтому у нас здесь остается неопределенность.\nТак как же избавиться от NA в данных? Самый простой способ – это функция is.na():\n\nis.na(n)\n\n [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n\n\nРезультат выполнения is.na(n) выдает FALSE на тех позициях, где у нас числа (или другие значения), и TRUE там, где у нас NA. Чтобы вычленить из вектора n все значения кроме NA нам нужно, чтобы было наоборот: TRUE, если это не NA, FALSE, если это NA. Здесь нам понадобится логический оператор НЕ ! (мы его уже встречали – см. @ref(data_types)), который инвертирует логические значения:\n\nn[!is.na(n)]\n\n[1]  0  1 20  0  0  8 13 21 34\n\n\nУра, мы можем считать среднее без NA!\n\nmean(n[!is.na(n)])\n\n[1] 10.77778\n\n\nТеперь Вы понимаете, зачем нужно отрицание (!)\nВообще, есть еще один из способов посчитать среднее, если есть NA. Для этого надо залезть в хэлп по функции mean():\n\n?mean()\n\nВ хэлпе мы найдем параметр na.rm =, который по умолчанию FALSE. Вы знаете, что нужно делать!\n\nmean(n, na.rm = T)\n\n[1] 10.77778\n\n\nNA может появляться в векторах разных типов. На самом деле, NA - это специальное значение в логических векторах, тогда как в векторах других типов NA появляется как NA_integer_, NA_real_, NA_complex_ или NA_character_, но R обычно сам все переводит в нужный формат и показывает как просто NA. Таким образом, NA в векторах разных типов – это разные NA, хотя на практике эта деталь обычно несущественна.\n\nКроме NA есть еще NaN – это разные вещи. NaN расшифровывается как Not a Number и получается в результате таких операций как 0 / 0. Тем не менее, функция is.na() выдает TRUE на NaN, а вот функция is.nan() выдает TRUE на NaN и FALSE на NA:\n\n\nis.na(NA)\n\n[1] TRUE\n\nis.na(NaN)\n\n[1] TRUE\n\nis.nan(NA)\n\n[1] FALSE\n\nis.nan(NaN)\n\n[1] TRUE"
  },
  {
    "objectID": "013-vector.html#vector_end",
    "href": "013-vector.html#vector_end",
    "title": "3  Вектор",
    "section": "3.8 Заключение",
    "text": "3.8 Заключение\nИтак, с векторами мы более-менее разобрались. Помните, что вектора – это один из краеугольных камней вашей работы в R. Если вы хорошо с ними разобрались, то дальше все будет довольно несложно. Тем не менее, вектора – это не все. Есть еще два важных типа данных: списки (list) и матрицы (matrix). Их можно рассматривать как своеобразное “расширение” векторов, каждый в свою сторону. Ну а списки и матрицы нужны чтобы понять основной тип данных в R – data.frame."
  },
  {
    "objectID": "016-complex_structures.html",
    "href": "016-complex_structures.html",
    "title": "4  Сложные структуры данных в R",
    "section": "",
    "text": "Если вдруг вас пугает это слово, то совершенно зря. Матрица (matrix) – это всего лишь “двумерный” вектор: вектор, у которого есть не только длина, но и ширина. Создать матрицу можно с помощью функции matrix() из вектора, указав при этом количество строк и столбцов.\n\nA <- matrix(1:20, nrow=5,ncol=4)\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n\n\n\nЗаметьте, значения вектора заполняются следующим образом: сначала заполняется первый столбик сверху вниз, потом второй сверху вниз и так до конца, т.е. заполнение значений матрицы идет в первую очередь по вертикали. Это довольно стандартный способ создания матриц, характерный не только для R.\n\nЕсли мы знаем сколько значений в матрице и сколько мы хотим строк, то количество столбцов указывать необязательно:\n\nA <- matrix(1:20, nrow=5)\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n\n\nВсе остальное так же как и с векторами: внутри находится данные только одного типа. Поскольку матрица – это уже двумерный массив, то у него имеется два индекса. Эти два индекса разделяются запятыми.\n\nA[2,3]\n\n[1] 12\n\nA[2:4, 1:3]\n\n     [,1] [,2] [,3]\n[1,]    2    7   12\n[2,]    3    8   13\n[3,]    4    9   14\n\n\nПервый индекс – выбор строк, второй индекс – выбор колонок. Если же мы оставляем пустое поле вместо числа, то мы выбираем все строки/колонки в зависимости от того, оставили мы поле пустым до или после запятой:\n\nA[, 1:3]\n\n     [,1] [,2] [,3]\n[1,]    1    6   11\n[2,]    2    7   12\n[3,]    3    8   13\n[4,]    4    9   14\n[5,]    5   10   15\n\nA[2:4, ]\n\n     [,1] [,2] [,3] [,4]\n[1,]    2    7   12   17\n[2,]    3    8   13   18\n[3,]    4    9   14   19\n\nA[, ]\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2    7   12   17\n[3,]    3    8   13   18\n[4,]    4    9   14   19\n[5,]    5   10   15   20\n\n\nТак же как и в случае с обычными векторами, часть матрицы можно переписать:\n\nA[2:4, 2:4] <- 100\nA\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   11   16\n[2,]    2  100  100  100\n[3,]    3  100  100  100\n[4,]    4  100  100  100\n[5,]    5   10   15   20\n\n\nВ принципе, это все, что нам нужно знать о матрицах. Матрицы используются в R довольно редко, особенно по сравнению, например, с MATLAB. Но вот индексировать матрицы хорошо бы уметь: это понадобится в работе с датафреймами.\n\nТо, что матрица – это просто двумерный вектор, не является метафорой: в R матрица – это по сути своей вектор с дополнительными атрибутами dim и (опционально) dimnames. Атрибуты – это свойства объектов, своего рода “метаданные”. Для всех объектов есть обязательные атрибуты типа и длины и могут быть любые необязательные атрибуты. Можно задавать свои атрибуты или удалять уже присвоенные: удаление атрибута dim у матрицы превратит ее в обычный вектор. Про атрибуты подробнее можно почитать здесь или на стр. 99-101 книги “R in a Nutshell” (Adler 2010)."
  },
  {
    "objectID": "016-complex_structures.html#arrays",
    "href": "016-complex_structures.html#arrays",
    "title": "4  Сложные структуры данных в R",
    "section": "4.2 Массив",
    "text": "4.2 Массив\nДва измерения – это не предел! Структура с одним типом данных внутри, но с тремя измерениями или больше, называется массивом (array). Создание массива очень похоже на создание матрицы: задаем вектор, из которого будет собран массив, и размерность массива.\n\narray_3d <- array(1:12, c(3, 2, 2))\narray_3d\n\n, , 1\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n, , 2\n\n     [,1] [,2]\n[1,]    7   10\n[2,]    8   11\n[3,]    9   12"
  },
  {
    "objectID": "016-complex_structures.html#list",
    "href": "016-complex_structures.html#list",
    "title": "4  Сложные структуры данных в R",
    "section": "4.3 Список",
    "text": "4.3 Список\nТеперь представим себе вектор без ограничения на одинаковые данные внутри. И получим список (list)!\n\nsimple_list <- list(42, \"Пам пам\", TRUE)\nsimple_list\n\n[[1]]\n[1] 42\n\n[[2]]\n[1] \"Пам пам\"\n\n[[3]]\n[1] TRUE\n\n\nА это значит, что там могут содержаться самые разные данные, в том числе и другие списки и векторы!\n\ncomplex_list <- list(c(\"Wow\", \"this\", \"list\", \"is\", \"so\", \"big\"), \"16\", simple_list)\ncomplex_list\n\n[[1]]\n[1] \"Wow\"  \"this\" \"list\" \"is\"   \"so\"   \"big\" \n\n[[2]]\n[1] \"16\"\n\n[[3]]\n[[3]][[1]]\n[1] 42\n\n[[3]][[2]]\n[1] \"Пам пам\"\n\n[[3]][[3]]\n[1] TRUE\n\n\nЕсли у нас сложный список, то есть очень классная функция, чтобы посмотреть, как он устроен, под названием str():\n\nstr(complex_list)\n\nList of 3\n $ : chr [1:6] \"Wow\" \"this\" \"list\" \"is\" ...\n $ : chr \"16\"\n $ :List of 3\n  ..$ : num 42\n  ..$ : chr \"Пам пам\"\n  ..$ : logi TRUE\n\n\n\nПредставьте, что список - это такое дерево с ветвистой структурой. А на конце этих ветвей - листья-векторы.\n\nКак и в случае с векторами мы можем давать имена элементам списка:\n\nnamed_list <- list(age = 24, PhDstudent = T, language = \"Russian\")\nnamed_list\n\n$age\n[1] 24\n\n$PhDstudent\n[1] TRUE\n\n$language\n[1] \"Russian\"\n\n\nК списку можно обращаться как с помощью индексов, так и по именам. Начнем с последнего:\n\nnamed_list$age\n\n[1] 24\n\n\nА вот с индексами сложнее, и в этом очень легко запутаться. Давайте попробуем сделать так, как мы делали это раньше:\n\nnamed_list[1]\n\n$age\n[1] 24\n\n\nМы, по сути, получили элемент списка – просто как часть списка, т.е. как список длиной один:\n\nclass(named_list)\n\n[1] \"list\"\n\nclass(named_list[1])\n\n[1] \"list\"\n\n\nА вот чтобы добраться до самого элемента списка (и сделать с ним что-то хорошее), нам нужна не одна, а две квадратных скобочки:\n\nnamed_list[[1]]\n\n[1] 24\n\nclass(named_list[[1]])\n\n[1] \"numeric\"\n\n\n\n\nIndexing lists in #rstats. Inspired by the Residence Inn pic.twitter.com/YQ6axb2w7t\n\n— Hadley Wickham ((hadleywickham?)) September 14, 2015\n\n\nКак и в случае с вектором, к элементу списка можно обращаться по имени.\n\nnamed_list[['age']]\n\n[1] 24\n\n\nХотя последнее – практически то же самое, что и использование знака $.\n\nСписки довольно часто используются в R, но реже, чем в Python. Со многими объектами в R, такими как результаты статистических тестов, удобно работать именно как со списками – к ним все вышеописанное применимо. Кроме того, некоторые данные мы изначально получаем в виде древообразной структуры – хочешь не хочешь, а придется работать с этим как со списком. Но обычно после этого стоит как можно скорее превратить список в датафрейм."
  },
  {
    "objectID": "016-complex_structures.html#df",
    "href": "016-complex_structures.html#df",
    "title": "4  Сложные структуры данных в R",
    "section": "4.4 Датафрейм",
    "text": "4.4 Датафрейм\nИтак, мы перешли к самому главному. Самому-самому. Датафреймы (data.frames). Более того, сейчас станет понятно, зачем нам нужно было разбираться со всеми предыдущими темами.\nБез векторов мы не смогли бы разобраться с матрицами и списками. А без последних мы не сможем понять, что такое датафрейм.\n\nname <- c(\"Petr\", \"Eugeny\", \"Lena\", \"Misha\", \"Sasha\") \nage <- c(26, 34, 23, 27, 26) \nstudent <- c(F, F, T, T, T) \ndf <- data.frame(name, age, student)  \ndf\n\n    name age student\n1   Petr  26   FALSE\n2 Eugeny  34   FALSE\n3   Lena  23    TRUE\n4  Misha  27    TRUE\n5  Sasha  26    TRUE\n\nstr(df)\n\n'data.frame':   5 obs. of  3 variables:\n $ name   : chr  \"Petr\" \"Eugeny\" \"Lena\" \"Misha\" ...\n $ age    : num  26 34 23 27 26\n $ student: logi  FALSE FALSE TRUE TRUE TRUE\n\n\nВообще, очень похоже на список, не правда ли? Так и есть, датафрейм – это что-то вроде проименованного списка, каждый элемент которого является atomic вектором фиксированной длины. Скорее всего, вы представляли список “горизонтально”. Если это так, то теперь “переверните” список у себя в голове на 90 градусов. Так, чтобы названия векторов оказались сверху, а элементы списка стали столбцами. Поскольку длина всех этих векторов одинаковая (обязательное условие!), то данные представляют собой табличку, похожую на матрицу. Но в отличие от матрицы, разные столбцы могут иметь разные типы данных. В нашем случае первая колонка – character, вторая колонка – numeric, третья колонка – logical. Тем не менее, обращаться с датафреймом можно и как с проименованным списком, и как с матрицей:\n\ndf$age[2:3]\n\n[1] 34 23\n\n\nЗдесь мы сначала ивлекли колонку age с помощью оператора $. Результатом этой операции является числовой вектор, из которого мы вытащили кусок, выбрав индексы 2 и 3.\nИспользуя оператор $ и присваивание можно создавать новые колонки датафрейма:\n\ndf$lovesR <- TRUE #правило recycling - узнали? \ndf\n\n    name age student lovesR\n1   Petr  26   FALSE   TRUE\n2 Eugeny  34   FALSE   TRUE\n3   Lena  23    TRUE   TRUE\n4  Misha  27    TRUE   TRUE\n5  Sasha  26    TRUE   TRUE\n\n\nНу а можно просто обращаться с помощью двух индексов через запятую, как мы это делали с матрицей:\n\ndf[3:5, 2:3]\n\n  age student\n3  23    TRUE\n4  27    TRUE\n5  26    TRUE\n\n\nКак и с матрицами, первый индекс означает строчки, а второй – столбцы.\nА еще можно использовать названия колонок внутри квадратных скобок:\n\ndf[1:2, \"age\"]\n\n[1] 26 34\n\n\nИ здесь перед нами открываются невообразимые возможности! Узнаем, любят ли R те, кто моложе среднего возраста в группе:\n\ndf[df$age < mean(df$age), 4]\n\n[1] TRUE TRUE TRUE TRUE\n\n\nЭту же задачу можно выполнить другими способами:\n\ndf$lovesR[df$age < mean(df$age)]\n\n[1] TRUE TRUE TRUE TRUE\n\ndf[df$age < mean(df$age), 'lovesR']\n\n[1] TRUE TRUE TRUE TRUE\n\n\nВ большинстве случаев подходят сразу несколько способов – тем не менее, стоит овладеть ими всеми.\nДатафреймы удобно просматривать в RStudio. Для это нужно написать команду View(df) или же просто нажать на названии нужной переменной из списка вверху справа (там где Environment). Тогда увидите табличку, очень похожую на Excel и тому подобные программы для работы с таблицами. Там же есть и всякие возможности для фильтрации, сортировки и поиска 1.\n\nНо, конечно, интереснее все эти вещи делать руками, т.е. с помощью написания кода.\n\n\n\n\nAdler, Joseph. 2010. R in a Nutshell: A Desktop Quick Reference. \" O’Reilly Media, Inc.\"."
  },
  {
    "objectID": "110-tidyverse_basic.html#загрузка-данных-с-помощью-readr",
    "href": "110-tidyverse_basic.html#загрузка-данных-с-помощью-readr",
    "title": "8  Введение в tidyverse",
    "section": "8.2 Загрузка данных с помощью readr",
    "text": "8.2 Загрузка данных с помощью readr\nСтандартной функцией для чтения .csv файлов в R является функция read.csv(), но мы будем использовать функцию read_csv() из пакета readr. Синтаксис функции read_csv() очень похож на read.csv(): первым аргументом является путь к файлу (в том числе можно использовать URL), некоторые остальные параметры тоже совпадают.\n\nheroes <- read_csv(\"https://raw.githubusercontent.com/Pozdniakov/tidy_stats/master/data/heroes_information.csv\",\n                   na = c(\"-\", \"-99\"))\n\nWarning: Missing column names filled in: 'X1' [1]\n\n\n\n── Column specification ────────────────────────────────────────────────────────\ncols(\n  X1 = col_double(),\n  name = col_character(),\n  Gender = col_character(),\n  `Eye color` = col_character(),\n  Race = col_character(),\n  `Hair color` = col_character(),\n  Height = col_double(),\n  Publisher = col_character(),\n  `Skin color` = col_character(),\n  Alignment = col_character(),\n  Weight = col_double()\n)\n\n\nПодробнее про импорт данных, в том числе в tidyverse, смотри в @ref(real_data).\n##tibble\nКогда мы загрузили данные с помощью read_csv(), то мы получили tibble, а не data.frame:\n\nclass(heroes)\n\n[1] \"spec_tbl_df\" \"tbl_df\"      \"tbl\"         \"data.frame\" \n\n\nТиббл (tibble) - это такой “усовершенствованный” data.frame. Почти все, что работает с data.frame, работает и с тибблами. Однако у тибблов есть свои дополнительные фишки. Самая очевидная из них - более аккуратный вывод в консоль:\n\nheroes\n\n# A tibble: 734 × 11\n      X1 name          Gender `Eye color` Race     `Hair color` Height Publisher\n   <dbl> <chr>         <chr>  <chr>       <chr>    <chr>         <dbl> <chr>    \n 1     0 A-Bomb        Male   yellow      Human    No Hair         203 Marvel C…\n 2     1 Abe Sapien    Male   blue        Icthyo … No Hair         191 Dark Hor…\n 3     2 Abin Sur      Male   blue        Ungaran  No Hair         185 DC Comics\n 4     3 Abomination   Male   green       Human /… No Hair         203 Marvel C…\n 5     4 Abraxas       Male   blue        Cosmic … Black            NA Marvel C…\n 6     5 Absorbing Man Male   blue        Human    No Hair         193 Marvel C…\n 7     6 Adam Monroe   Male   blue        <NA>     Blond            NA NBC - He…\n 8     7 Adam Strange  Male   blue        Human    Blond           185 DC Comics\n 9     8 Agent 13      Female blue        <NA>     Blond           173 Marvel C…\n10     9 Agent Bob     Male   brown       Human    Brown           178 Marvel C…\n# … with 724 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <dbl>\n\n\nВыводятся только первые 10 строк, если какие-то колонки не влезают на экран, то они просто перечислены внизу. Ну а тип данных написан прямо под названием колонки.\nФункции различных пакетов tidyverse сами конвертируют в тиббл при необходимости. Если же нужно это сделать самостоятельно, то можно это сделать так:\n\nheroes_df <- as.data.frame(heroes) #создаем простой датафрейм\nclass(heroes_df)\n\n[1] \"data.frame\"\n\nas_tibble(heroes_df) #превращаем обратно в тиббл\n\n# A tibble: 734 × 11\n      X1 name          Gender `Eye color` Race     `Hair color` Height Publisher\n   <dbl> <chr>         <chr>  <chr>       <chr>    <chr>         <dbl> <chr>    \n 1     0 A-Bomb        Male   yellow      Human    No Hair         203 Marvel C…\n 2     1 Abe Sapien    Male   blue        Icthyo … No Hair         191 Dark Hor…\n 3     2 Abin Sur      Male   blue        Ungaran  No Hair         185 DC Comics\n 4     3 Abomination   Male   green       Human /… No Hair         203 Marvel C…\n 5     4 Abraxas       Male   blue        Cosmic … Black            NA Marvel C…\n 6     5 Absorbing Man Male   blue        Human    No Hair         193 Marvel C…\n 7     6 Adam Monroe   Male   blue        <NA>     Blond            NA NBC - He…\n 8     7 Adam Strange  Male   blue        Human    Blond           185 DC Comics\n 9     8 Agent 13      Female blue        <NA>     Blond           173 Marvel C…\n10     9 Agent Bob     Male   brown       Human    Brown           178 Marvel C…\n# … with 724 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <dbl>\n\n\n\nВ дальнейшем мы будем работать только с tidyverse, а это значит, что только с тибблами, а не обычными датафреймами. Тем не менее, тибблы и датафреймы будут в дальнейшем использоваться как синонимы.\n\nМожно создавать тибблы вручную с помощью функции tibble(), которая работает аналогично функции data.frame():\n\ntibble(\n  a = 1:3,\n  b = letters[1:3]\n)\n\n# A tibble: 3 × 2\n      a b    \n  <int> <chr>\n1     1 a    \n2     2 b    \n3     3 c"
  },
  {
    "objectID": "110-tidyverse_basic.html#pipe",
    "href": "110-tidyverse_basic.html#pipe",
    "title": "8  Введение в tidyverse",
    "section": "8.3 magrittr::%>%",
    "text": "8.3 magrittr::%>%\nОператор %>% называется “пайпом” (pipe), т.е. “трубой”. Он означает, что следующая функция (справа от пайпа) принимает на вход в качестве первого аргумента результат выполнения предыдущей функции (той, что слева). Фактически, это примерно то же самое, что и вставлять результат выполнения функции в качестве первого аргумента в другую функцию. Просто выглядит это красивее и читабельнее. Как будто данные пропускаются через трубы функций или конвеерную ленту на заводе, если хотите. А то, что первый параметр функции - это почти всегда данные, работает нам здесь на руку. Этот оператор взят из пакета magrittr2. Возможно, даже если вы не захотите пользоваться tidyverse, использование пайпов Вам понравится.\nВажно понимать, что пайп не дает какой-то дополнительной функциональности или дополнительной скорости работы3. Он создан исключительно для читабельности и комфорта.\nС помощью пайпов вот эту команду…\n\nsum(sqrt(abs(sin(1:22))))\n\n[1] 16.72656\n\n\n…можно переписать вот так:\n\n1:22 %>% \n  sin() %>% \n  abs() %>% \n  sqrt() %>% \n  sum()\n\n[1] 16.72656\n\n\n\nВ очень редких случаях результат выполнения функции нужно вставить не на первую позицию (или же мы хотим использовать его несколько раз). В этих случаях можно использовать ., чтобы обозначить, куда мы хотим вставить результат выполнения выражения слева от %>%.\n\n\"Всем привет!\" %>%\n  c(\"--\", ., \"--\")\n\n[1] \"--\"           \"Всем привет!\" \"--\"          \n\n\nОсновные функции в tidyverse …"
  },
  {
    "objectID": "110-tidyverse_basic.html#главные-пакеты-tidyverse-dplyr-и-tidyr",
    "href": "110-tidyverse_basic.html#главные-пакеты-tidyverse-dplyr-и-tidyr",
    "title": "8  Введение в tidyverse",
    "section": "8.4 Главные пакеты tidyverse: dplyr и tidyr",
    "text": "8.4 Главные пакеты tidyverse: dplyr и tidyr\ndplyr4 — это самая основа всего tidyverse. Этот пакет предоставляет основные функции для манипуляции с тибблами. Пакет dplyr является наследником и более усовершенствованной версией plyr, так что если увидите использование пакета plyr, то, скорее всего, скрипт был написан очень давно.\nПакет tidyr дополняет dplyr, предоставляя полезные функции для тайдификации тибблов. Тайдификация (“аккуратизация”) данных означает приведение табличных данных к такому формату, в котором:\n\nКаждая переменная имеет собственный столбец\nКаждый наблюдение имеет собственную строку\nКаждое значение имеет свою собственную ячейку\n\nВпрочем, многие функции dplyr часто используются при тайдификации, так же как и многие функции tidyr имеет применение вне тайдификации. В общем, функционал этих двух пакетов несколько смешался, поэтому мы будем рассматривать их вместе. А чтобы представлять, какая функция относится к какому пакету (хотя запоминать это необязательно), я буду использовать запись с двумя двоеточиями ::, которая обычно используется для использования функции без подгрузки всего пакета, при первом упоминании функции.\nПакет tidyr — это более усовершенствованная версия пакета reshape2, который в свою очередь является усовершенствованной версией reshape. По аналогии с plyr, если вы видите использование этих пакетов, то это указывает на то, что перед вами морально устаревший код.\nКод с использованием dplyr и tidyrсильно непохож на то, что мы видели раньше. Большинство функций dplyr и tidyr работают с целым тибблом сразу, принимая его в качестве первого аргумента и возвращая измененный тиббл. Это позволяет превратить весь код в последовательный набор применяемых функций, соединенный пайпами. На практике это выглядит очень элегантно, и вы в этом скоро убедитесь."
  },
  {
    "objectID": "110-tidyverse_basic.html#tidy_select_cols",
    "href": "110-tidyverse_basic.html#tidy_select_cols",
    "title": "8  Введение в tidyverse",
    "section": "8.5 Работа с колонками тиббла",
    "text": "8.5 Работа с колонками тиббла\n\n8.5.1 Выбор колонок: dplyr::select()\nФункция dplyr::select() позволяет выбирать колонки по номеру или имени (кавычки не нужны).\n\nheroes %>%\n  select(1,5)\n\n# A tibble: 734 × 2\n      X1 Race             \n   <dbl> <chr>            \n 1     0 Human            \n 2     1 Icthyo Sapien    \n 3     2 Ungaran          \n 4     3 Human / Radiation\n 5     4 Cosmic Entity    \n 6     5 Human            \n 7     6 <NA>             \n 8     7 Human            \n 9     8 <NA>             \n10     9 Human            \n# … with 724 more rows\n\n\n\nheroes %>%\n  select(name, Race, Publisher, `Hair color`)\n\n# A tibble: 734 × 4\n   name          Race              Publisher         `Hair color`\n   <chr>         <chr>             <chr>             <chr>       \n 1 A-Bomb        Human             Marvel Comics     No Hair     \n 2 Abe Sapien    Icthyo Sapien     Dark Horse Comics No Hair     \n 3 Abin Sur      Ungaran           DC Comics         No Hair     \n 4 Abomination   Human / Radiation Marvel Comics     No Hair     \n 5 Abraxas       Cosmic Entity     Marvel Comics     Black       \n 6 Absorbing Man Human             Marvel Comics     No Hair     \n 7 Adam Monroe   <NA>              NBC - Heroes      Blond       \n 8 Adam Strange  Human             DC Comics         Blond       \n 9 Agent 13      <NA>              Marvel Comics     Blond       \n10 Agent Bob     Human             Marvel Comics     Brown       \n# … with 724 more rows\n\n\nОбратите внимание, если в названии колонки присутствует пробел или, например, колонка начинается с цифры или точки и цифры, то это синтаксически невалидное имя (@ref(variables)). Это не значит, что такие названия колонок недопустимы. Но такие названия колонок нужно обособлять ` грависом (правый штрих, на клавиатуре находится там же где и буква ё и ~).\nЕще обратите внимание на то, что функции tidyverse не изменяют сами изначальные тибблы/датафреймы. Это означает, что если вы хотите полученный результат сохранить, то нужно добавить присвоение:\n\nheroes_some_cols <- heroes %>%\n  select(name, Race, Publisher, `Hair color`)\nheroes_some_cols\n\n# A tibble: 734 × 4\n   name          Race              Publisher         `Hair color`\n   <chr>         <chr>             <chr>             <chr>       \n 1 A-Bomb        Human             Marvel Comics     No Hair     \n 2 Abe Sapien    Icthyo Sapien     Dark Horse Comics No Hair     \n 3 Abin Sur      Ungaran           DC Comics         No Hair     \n 4 Abomination   Human / Radiation Marvel Comics     No Hair     \n 5 Abraxas       Cosmic Entity     Marvel Comics     Black       \n 6 Absorbing Man Human             Marvel Comics     No Hair     \n 7 Adam Monroe   <NA>              NBC - Heroes      Blond       \n 8 Adam Strange  Human             DC Comics         Blond       \n 9 Agent 13      <NA>              Marvel Comics     Blond       \n10 Agent Bob     Human             Marvel Comics     Brown       \n# … with 724 more rows\n\n\n\n\n8.5.2 Мини-язык tidyselect для выбора колонок\nДля выбора столбцов (не только в select(), но и для других функций tidyverse) используется специальный мини-язык tidyselect из одноименного пакета5. tidyselect дает очень широкие возможности для выбора колонок.\nМожно использовать оператор : для выбора нескольких соседних колонок (по аналогии с созданием числового вектора с шагом 1).\n\nheroes %>%\n  select(name:Publisher)\n\n# A tibble: 734 × 7\n   name          Gender `Eye color` Race           `Hair color` Height Publisher\n   <chr>         <chr>  <chr>       <chr>          <chr>         <dbl> <chr>    \n 1 A-Bomb        Male   yellow      Human          No Hair         203 Marvel C…\n 2 Abe Sapien    Male   blue        Icthyo Sapien  No Hair         191 Dark Hor…\n 3 Abin Sur      Male   blue        Ungaran        No Hair         185 DC Comics\n 4 Abomination   Male   green       Human / Radia… No Hair         203 Marvel C…\n 5 Abraxas       Male   blue        Cosmic Entity  Black            NA Marvel C…\n 6 Absorbing Man Male   blue        Human          No Hair         193 Marvel C…\n 7 Adam Monroe   Male   blue        <NA>           Blond            NA NBC - He…\n 8 Adam Strange  Male   blue        Human          Blond           185 DC Comics\n 9 Agent 13      Female blue        <NA>           Blond           173 Marvel C…\n10 Agent Bob     Male   brown       Human          Brown           178 Marvel C…\n# … with 724 more rows\n\n\n\nheroes %>%\n  select(name:`Eye color`, Publisher:Weight)\n\n# A tibble: 734 × 7\n   name          Gender `Eye color` Publisher      `Skin color` Alignment Weight\n   <chr>         <chr>  <chr>       <chr>          <chr>        <chr>      <dbl>\n 1 A-Bomb        Male   yellow      Marvel Comics  <NA>         good         441\n 2 Abe Sapien    Male   blue        Dark Horse Co… blue         good          65\n 3 Abin Sur      Male   blue        DC Comics      red          good          90\n 4 Abomination   Male   green       Marvel Comics  <NA>         bad          441\n 5 Abraxas       Male   blue        Marvel Comics  <NA>         bad           NA\n 6 Absorbing Man Male   blue        Marvel Comics  <NA>         bad          122\n 7 Adam Monroe   Male   blue        NBC - Heroes   <NA>         good          NA\n 8 Adam Strange  Male   blue        DC Comics      <NA>         good          88\n 9 Agent 13      Female blue        Marvel Comics  <NA>         good          61\n10 Agent Bob     Male   brown       Marvel Comics  <NA>         good          81\n# … with 724 more rows\n\n\nИспользуя ! можно вырезать ненужные колонки.\n\nheroes %>%\n  select(!X1)\n\n# A tibble: 734 × 10\n   name      Gender `Eye color` Race  `Hair color` Height Publisher `Skin color`\n   <chr>     <chr>  <chr>       <chr> <chr>         <dbl> <chr>     <chr>       \n 1 A-Bomb    Male   yellow      Human No Hair         203 Marvel C… <NA>        \n 2 Abe Sapi… Male   blue        Icth… No Hair         191 Dark Hor… blue        \n 3 Abin Sur  Male   blue        Unga… No Hair         185 DC Comics red         \n 4 Abominat… Male   green       Huma… No Hair         203 Marvel C… <NA>        \n 5 Abraxas   Male   blue        Cosm… Black            NA Marvel C… <NA>        \n 6 Absorbin… Male   blue        Human No Hair         193 Marvel C… <NA>        \n 7 Adam Mon… Male   blue        <NA>  Blond            NA NBC - He… <NA>        \n 8 Adam Str… Male   blue        Human Blond           185 DC Comics <NA>        \n 9 Agent 13  Female blue        <NA>  Blond           173 Marvel C… <NA>        \n10 Agent Bob Male   brown       Human Brown           178 Marvel C… <NA>        \n# … with 724 more rows, and 2 more variables: Alignment <chr>, Weight <dbl>\n\nheroes %>%\n  select(!(Gender:Height))\n\n# A tibble: 734 × 6\n      X1 name          Publisher         `Skin color` Alignment Weight\n   <dbl> <chr>         <chr>             <chr>        <chr>      <dbl>\n 1     0 A-Bomb        Marvel Comics     <NA>         good         441\n 2     1 Abe Sapien    Dark Horse Comics blue         good          65\n 3     2 Abin Sur      DC Comics         red          good          90\n 4     3 Abomination   Marvel Comics     <NA>         bad          441\n 5     4 Abraxas       Marvel Comics     <NA>         bad           NA\n 6     5 Absorbing Man Marvel Comics     <NA>         bad          122\n 7     6 Adam Monroe   NBC - Heroes      <NA>         good          NA\n 8     7 Adam Strange  DC Comics         <NA>         good          88\n 9     8 Agent 13      Marvel Comics     <NA>         good          61\n10     9 Agent Bob     Marvel Comics     <NA>         good          81\n# … with 724 more rows\n\n\nДругие известные нам логические операторы (& и |) тоже работают в tidyselect.\nВ дополнение к логическим операторам и :, в tidyselect есть набор вспомогательных функций, работающих исключительно в контексте выбора колонок с помощью tidyselect.\nВспомогательная функция last_col() позволит обратиться к последней колонке тиббла:\n\nheroes %>%\n  select(name:last_col())\n\n# A tibble: 734 × 10\n   name      Gender `Eye color` Race  `Hair color` Height Publisher `Skin color`\n   <chr>     <chr>  <chr>       <chr> <chr>         <dbl> <chr>     <chr>       \n 1 A-Bomb    Male   yellow      Human No Hair         203 Marvel C… <NA>        \n 2 Abe Sapi… Male   blue        Icth… No Hair         191 Dark Hor… blue        \n 3 Abin Sur  Male   blue        Unga… No Hair         185 DC Comics red         \n 4 Abominat… Male   green       Huma… No Hair         203 Marvel C… <NA>        \n 5 Abraxas   Male   blue        Cosm… Black            NA Marvel C… <NA>        \n 6 Absorbin… Male   blue        Human No Hair         193 Marvel C… <NA>        \n 7 Adam Mon… Male   blue        <NA>  Blond            NA NBC - He… <NA>        \n 8 Adam Str… Male   blue        Human Blond           185 DC Comics <NA>        \n 9 Agent 13  Female blue        <NA>  Blond           173 Marvel C… <NA>        \n10 Agent Bob Male   brown       Human Brown           178 Marvel C… <NA>        \n# … with 724 more rows, and 2 more variables: Alignment <chr>, Weight <dbl>\n\n\nА функция everything() позволяет выбрать все колонки.\n\nheroes %>%\n  select(everything())\n\n# A tibble: 734 × 11\n      X1 name          Gender `Eye color` Race     `Hair color` Height Publisher\n   <dbl> <chr>         <chr>  <chr>       <chr>    <chr>         <dbl> <chr>    \n 1     0 A-Bomb        Male   yellow      Human    No Hair         203 Marvel C…\n 2     1 Abe Sapien    Male   blue        Icthyo … No Hair         191 Dark Hor…\n 3     2 Abin Sur      Male   blue        Ungaran  No Hair         185 DC Comics\n 4     3 Abomination   Male   green       Human /… No Hair         203 Marvel C…\n 5     4 Abraxas       Male   blue        Cosmic … Black            NA Marvel C…\n 6     5 Absorbing Man Male   blue        Human    No Hair         193 Marvel C…\n 7     6 Adam Monroe   Male   blue        <NA>     Blond            NA NBC - He…\n 8     7 Adam Strange  Male   blue        Human    Blond           185 DC Comics\n 9     8 Agent 13      Female blue        <NA>     Blond           173 Marvel C…\n10     9 Agent Bob     Male   brown       Human    Brown           178 Marvel C…\n# … with 724 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <dbl>\n\n\nПри этом everything() не будет дублировать выбранные колонки, поэтому можно использовать everything() для перестановки колонок в тиббле:\n\nheroes %>%\n  select(name, Publisher, everything())\n\n# A tibble: 734 × 11\n   name          Publisher       X1 Gender `Eye color` Race  `Hair color` Height\n   <chr>         <chr>        <dbl> <chr>  <chr>       <chr> <chr>         <dbl>\n 1 A-Bomb        Marvel Comi…     0 Male   yellow      Human No Hair         203\n 2 Abe Sapien    Dark Horse …     1 Male   blue        Icth… No Hair         191\n 3 Abin Sur      DC Comics        2 Male   blue        Unga… No Hair         185\n 4 Abomination   Marvel Comi…     3 Male   green       Huma… No Hair         203\n 5 Abraxas       Marvel Comi…     4 Male   blue        Cosm… Black            NA\n 6 Absorbing Man Marvel Comi…     5 Male   blue        Human No Hair         193\n 7 Adam Monroe   NBC - Heroes     6 Male   blue        <NA>  Blond            NA\n 8 Adam Strange  DC Comics        7 Male   blue        Human Blond           185\n 9 Agent 13      Marvel Comi…     8 Female blue        <NA>  Blond           173\n10 Agent Bob     Marvel Comi…     9 Male   brown       Human Brown           178\n# … with 724 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <dbl>\n\n\nВпрочем, для перестановки колонок удобнее использовать специальную функцию relocate() (@ref(tidy_relocate)) Можно даже выбирать колонки по паттернам в названиях. Например, с помощью ends_with() можно выбрать все колонки, заканчивающиеся одинаковым суффиксом:\n\nheroes %>%\n  select(ends_with(\"color\"))\n\n# A tibble: 734 × 3\n   `Eye color` `Hair color` `Skin color`\n   <chr>       <chr>        <chr>       \n 1 yellow      No Hair      <NA>        \n 2 blue        No Hair      blue        \n 3 blue        No Hair      red         \n 4 green       No Hair      <NA>        \n 5 blue        Black        <NA>        \n 6 blue        No Hair      <NA>        \n 7 blue        Blond        <NA>        \n 8 blue        Blond        <NA>        \n 9 blue        Blond        <NA>        \n10 brown       Brown        <NA>        \n# … with 724 more rows\n\n\nАналогично, с помощью функции starts_with() можно найти колонки с одинаковым префиксом, с помощью contains() — все колонки с выбранным паттерном в любой части названия колонки6.\n\nheroes %>%\n  select(starts_with(\"Eye\") & ends_with(\"color\"))\n\n# A tibble: 734 × 1\n   `Eye color`\n   <chr>      \n 1 yellow     \n 2 blue       \n 3 blue       \n 4 green      \n 5 blue       \n 6 blue       \n 7 blue       \n 8 blue       \n 9 blue       \n10 brown      \n# … with 724 more rows\n\nheroes %>%\n  select(contains(\"eight\"))\n\n# A tibble: 734 × 2\n   Height Weight\n    <dbl>  <dbl>\n 1    203    441\n 2    191     65\n 3    185     90\n 4    203    441\n 5     NA     NA\n 6    193    122\n 7     NA     NA\n 8    185     88\n 9    173     61\n10    178     81\n# … with 724 more rows\n\n\nНу и наконец, можно выбирать по содержимому колонок с помощью where(). Это напоминает применение sapply()(@ref(apply_other)) на датафрейме для индексирования колонок: в качестве аргумента для where принимается функция, которая применяется для каждой из колонок, после чего выбираются только те колонки, для которых было получено TRUE.\n\nheroes %>%\n  select(where(is.numeric))\n\n# A tibble: 734 × 3\n      X1 Height Weight\n   <dbl>  <dbl>  <dbl>\n 1     0    203    441\n 2     1    191     65\n 3     2    185     90\n 4     3    203    441\n 5     4     NA     NA\n 6     5    193    122\n 7     6     NA     NA\n 8     7    185     88\n 9     8    173     61\n10     9    178     81\n# … with 724 more rows\n\n\nФункция where() дает невиданную мощь. Например, можно выбрать все колонки без NA:\n\nheroes %>%\n  select(where(function(x) !any(is.na(x))))\n\n# A tibble: 734 × 3\n      X1 name          Publisher        \n   <dbl> <chr>         <chr>            \n 1     0 A-Bomb        Marvel Comics    \n 2     1 Abe Sapien    Dark Horse Comics\n 3     2 Abin Sur      DC Comics        \n 4     3 Abomination   Marvel Comics    \n 5     4 Abraxas       Marvel Comics    \n 6     5 Absorbing Man Marvel Comics    \n 7     6 Adam Monroe   NBC - Heroes     \n 8     7 Adam Strange  DC Comics        \n 9     8 Agent 13      Marvel Comics    \n10     9 Agent Bob     Marvel Comics    \n# … with 724 more rows\n\n\n###Переименование колонок: dplyr::rename()\nВнутри select() можно не только выбирать колонки, но и переименовывать их:\n\nheroes %>%\n  select(id = X1)\n\n# A tibble: 734 × 1\n      id\n   <dbl>\n 1     0\n 2     1\n 3     2\n 4     3\n 5     4\n 6     5\n 7     6\n 8     7\n 9     8\n10     9\n# … with 724 more rows\n\n\nОднако удобнее для этого использовать специальную функцию dplyr::rename(). Синтаксис у нее такой же, как и у select(), но rename() не выбрасывает колонки, которые не были упомянуты.\n\nheroes %>%\n  rename(id = X1)\n\n# A tibble: 734 × 11\n      id name          Gender `Eye color` Race     `Hair color` Height Publisher\n   <dbl> <chr>         <chr>  <chr>       <chr>    <chr>         <dbl> <chr>    \n 1     0 A-Bomb        Male   yellow      Human    No Hair         203 Marvel C…\n 2     1 Abe Sapien    Male   blue        Icthyo … No Hair         191 Dark Hor…\n 3     2 Abin Sur      Male   blue        Ungaran  No Hair         185 DC Comics\n 4     3 Abomination   Male   green       Human /… No Hair         203 Marvel C…\n 5     4 Abraxas       Male   blue        Cosmic … Black            NA Marvel C…\n 6     5 Absorbing Man Male   blue        Human    No Hair         193 Marvel C…\n 7     6 Adam Monroe   Male   blue        <NA>     Blond            NA NBC - He…\n 8     7 Adam Strange  Male   blue        Human    Blond           185 DC Comics\n 9     8 Agent 13      Female blue        <NA>     Blond           173 Marvel C…\n10     9 Agent Bob     Male   brown       Human    Brown           178 Marvel C…\n# … with 724 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <dbl>\n\n\nДля массового переименования колонок можно использовать функцию rename_with(). Эта функция так же использует tidyselect синтаксис для выбора колонок (по умолчанию выбираются все колонки) и применяет функцию в качестве аргумента, которая изменяет\n\nheroes %>%\n  rename_with(make.names)\n\n# A tibble: 734 × 11\n      X1 name      Gender Eye.color Race  Hair.color Height Publisher Skin.color\n   <dbl> <chr>     <chr>  <chr>     <chr> <chr>       <dbl> <chr>     <chr>     \n 1     0 A-Bomb    Male   yellow    Human No Hair       203 Marvel C… <NA>      \n 2     1 Abe Sapi… Male   blue      Icth… No Hair       191 Dark Hor… blue      \n 3     2 Abin Sur  Male   blue      Unga… No Hair       185 DC Comics red       \n 4     3 Abominat… Male   green     Huma… No Hair       203 Marvel C… <NA>      \n 5     4 Abraxas   Male   blue      Cosm… Black          NA Marvel C… <NA>      \n 6     5 Absorbin… Male   blue      Human No Hair       193 Marvel C… <NA>      \n 7     6 Adam Mon… Male   blue      <NA>  Blond          NA NBC - He… <NA>      \n 8     7 Adam Str… Male   blue      Human Blond         185 DC Comics <NA>      \n 9     8 Agent 13  Female blue      <NA>  Blond         173 Marvel C… <NA>      \n10     9 Agent Bob Male   brown     Human Brown         178 Marvel C… <NA>      \n# … with 724 more rows, and 2 more variables: Alignment <chr>, Weight <dbl>\n\n\n###Перестановка колонок: dplyr::relocate() {#tidy_relocate}\nДля изменения порядка колонок можно использовать функцию relocate(). Она тоже работает похожим образом на select() и rename()7. Как и rename(), функция relocate() не выкидывает неиспользованные колонки:\n\nheroes %>%\n  relocate(Publisher)\n\n# A tibble: 734 × 11\n   Publisher            X1 name     Gender `Eye color` Race  `Hair color` Height\n   <chr>             <dbl> <chr>    <chr>  <chr>       <chr> <chr>         <dbl>\n 1 Marvel Comics         0 A-Bomb   Male   yellow      Human No Hair         203\n 2 Dark Horse Comics     1 Abe Sap… Male   blue        Icth… No Hair         191\n 3 DC Comics             2 Abin Sur Male   blue        Unga… No Hair         185\n 4 Marvel Comics         3 Abomina… Male   green       Huma… No Hair         203\n 5 Marvel Comics         4 Abraxas  Male   blue        Cosm… Black            NA\n 6 Marvel Comics         5 Absorbi… Male   blue        Human No Hair         193\n 7 NBC - Heroes          6 Adam Mo… Male   blue        <NA>  Blond            NA\n 8 DC Comics             7 Adam St… Male   blue        Human Blond           185\n 9 Marvel Comics         8 Agent 13 Female blue        <NA>  Blond           173\n10 Marvel Comics         9 Agent B… Male   brown       Human Brown           178\n# … with 724 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <dbl>\n\n\nПри этом relocate() имеет дополнительные параметры .after = и .before =, которые позволяют выбирать, куда поместить выбранные колонки.\n\nheroes %>%\n  relocate(Publisher, .after = name)\n\n# A tibble: 734 × 11\n      X1 name          Publisher    Gender `Eye color` Race  `Hair color` Height\n   <dbl> <chr>         <chr>        <chr>  <chr>       <chr> <chr>         <dbl>\n 1     0 A-Bomb        Marvel Comi… Male   yellow      Human No Hair         203\n 2     1 Abe Sapien    Dark Horse … Male   blue        Icth… No Hair         191\n 3     2 Abin Sur      DC Comics    Male   blue        Unga… No Hair         185\n 4     3 Abomination   Marvel Comi… Male   green       Huma… No Hair         203\n 5     4 Abraxas       Marvel Comi… Male   blue        Cosm… Black            NA\n 6     5 Absorbing Man Marvel Comi… Male   blue        Human No Hair         193\n 7     6 Adam Monroe   NBC - Heroes Male   blue        <NA>  Blond            NA\n 8     7 Adam Strange  DC Comics    Male   blue        Human Blond           185\n 9     8 Agent 13      Marvel Comi… Female blue        <NA>  Blond           173\n10     9 Agent Bob     Marvel Comi… Male   brown       Human Brown           178\n# … with 724 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <dbl>\n\n\nrelocate() очень хорошо работает в сочетании с выбором колонок с помощью tidyselect. Например, можно передвинуть в одно место все колонки с одним типом данных:\n\nheroes %>%\n  relocate(Publisher, where(is.numeric), .after = name)\n\n# A tibble: 734 × 11\n   name      Publisher    X1 Height Weight Gender `Eye color` Race  `Hair color`\n   <chr>     <chr>     <dbl>  <dbl>  <dbl> <chr>  <chr>       <chr> <chr>       \n 1 A-Bomb    Marvel C…     0    203    441 Male   yellow      Human No Hair     \n 2 Abe Sapi… Dark Hor…     1    191     65 Male   blue        Icth… No Hair     \n 3 Abin Sur  DC Comics     2    185     90 Male   blue        Unga… No Hair     \n 4 Abominat… Marvel C…     3    203    441 Male   green       Huma… No Hair     \n 5 Abraxas   Marvel C…     4     NA     NA Male   blue        Cosm… Black       \n 6 Absorbin… Marvel C…     5    193    122 Male   blue        Human No Hair     \n 7 Adam Mon… NBC - He…     6     NA     NA Male   blue        <NA>  Blond       \n 8 Adam Str… DC Comics     7    185     88 Male   blue        Human Blond       \n 9 Agent 13  Marvel C…     8    173     61 Female blue        <NA>  Blond       \n10 Agent Bob Marvel C…     9    178     81 Male   brown       Human Brown       \n# … with 724 more rows, and 2 more variables: `Skin color` <chr>,\n#   Alignment <chr>\n\n\nПоследняя важная функция для выбора колонок — pull(). Эта функция делает то же самое, что и индексирование с помощью $, т.е. вытаскивает из тиббла вектор с выбранным названием. Это лучше вписывается в логику tidyverse, поскольку позволяет извлечь колонку из тиббла с использованием пайпа:\n\nheroes %>%\n  select(Height) %>%\n  pull() %>%\n  head()\n\n[1] 203 191 185 203  NA 193\n\nheroes %>%\n  pull(Height) %>%\n  head()\n\n[1] 203 191 185 203  NA 193\n\n\nУ функции pull() есть аргумент name =, который позволяет создать проименованный вектор:\n\nheroes %>%\n  pull(Height, name) %>%\n  head()\n\n       A-Bomb    Abe Sapien      Abin Sur   Abomination       Abraxas \n          203           191           185           203            NA \nAbsorbing Man \n          193 \n\n\nВ отличие от базового R, tidyverse нигде не сокращает имплицитно результат вычислений до вектора, поэтому функция pull() - это основной способ извлечения колонки из тиббла как вектора."
  },
  {
    "objectID": "110-tidyverse_basic.html#tidy_select_rows",
    "href": "110-tidyverse_basic.html#tidy_select_rows",
    "title": "8  Введение в tidyverse",
    "section": "8.6 Работа со строками тиббла",
    "text": "8.6 Работа со строками тиббла\n\n8.6.1 Выбор строк по номеру: dplyr::slice()\nНачнем с выбора строк. Функция dplyr::slice() выбирает строчки по их числовому индексу.\n\nheroes %>%\n  slice(1:3)\n\n# A tibble: 3 × 11\n     X1 name       Gender `Eye color` Race         `Hair color` Height Publisher\n  <dbl> <chr>      <chr>  <chr>       <chr>        <chr>         <dbl> <chr>    \n1     0 A-Bomb     Male   yellow      Human        No Hair         203 Marvel C…\n2     1 Abe Sapien Male   blue        Icthyo Sapi… No Hair         191 Dark Hor…\n3     2 Abin Sur   Male   blue        Ungaran      No Hair         185 DC Comics\n# … with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>\n\n\n\n\n8.6.2 Выбор строк по условию: dplyr::filter()\nФункция dplyr::filter() делает то же самое, что и slice(), но уже по условию. Причем для условий нужно использовать не векторы из тиббла, а название колонок (без кавычек) как будто бы они были переменными в окружении.\n\nheroes %>% \n  filter(Publisher == \"DC Comics\")\n\n# A tibble: 215 × 11\n      X1 name             Gender `Eye color` Race  `Hair color` Height Publisher\n   <dbl> <chr>            <chr>  <chr>       <chr> <chr>         <dbl> <chr>    \n 1     2 Abin Sur         Male   blue        Unga… No Hair         185 DC Comics\n 2     7 Adam Strange     Male   blue        Human Blond           185 DC Comics\n 3    13 Alan Scott       Male   blue        <NA>  Blond           180 DC Comics\n 4    16 Alfred Pennywor… Male   blue        Human Black           178 DC Comics\n 5    19 Amazo            Male   red         Andr… <NA>            257 DC Comics\n 6    27 Animal Man       Male   blue        Human Blond           183 DC Comics\n 7    31 Anti-Monitor     Male   yellow      God … No Hair          61 DC Comics\n 8    35 Aquababy         Male   blue        <NA>  Blond            NA DC Comics\n 9    36 Aqualad          Male   blue        Atla… Black           178 DC Comics\n10    37 Aquaman          Male   blue        Atla… Blond           185 DC Comics\n# … with 205 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <dbl>\n\n\n\n\n8.6.3 Семейство функций slice()\nУ функции slice() есть множество родственников, которые объединяют функционал обычного slice() и filter(). Например, с помощью функций dplyr::slice_max() и dplyr::slice_min() можно выбрать заданное количество строк, содержащих наибольшие или наименьшие значения по колонке соответственно:\n\nheroes %>%\n  slice_max(Weight, n = 3)\n\n# A tibble: 3 × 11\n     X1 name       Gender `Eye color` Race    `Hair color` Height Publisher    \n  <dbl> <chr>      <chr>  <chr>       <chr>   <chr>         <dbl> <chr>        \n1   575 Sasquatch  Male   red         <NA>    Orange          305 Marvel Comics\n2   373 Juggernaut Male   blue        Human   Red             287 Marvel Comics\n3   203 Darkseid   Male   red         New God No Hair         267 DC Comics    \n# … with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>\n\nheroes %>%\n  slice_min(Weight, n = 3)\n\n# A tibble: 3 × 11\n     X1 name        Gender `Eye color` Race        `Hair color` Height Publisher\n  <dbl> <chr>       <chr>  <chr>       <chr>       <chr>         <dbl> <chr>    \n1   346 Iron Monger Male   blue        <NA>        No Hair          NA Marvel C…\n2   302 Groot       Male   yellow      Flora Colo… <NA>            701 Marvel C…\n3   350 Jack-Jack   Male   blue        Human       Brown            71 Dark Hor…\n# … with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>\n\n\nФункция slice_sample() позволяет выбирать заданное количество случайных строчек:\n\nheroes %>%\n  slice_sample(n = 3)\n\n# A tibble: 3 × 11\n     X1 name         Gender `Eye color` Race  `Hair color` Height Publisher    \n  <dbl> <chr>        <chr>  <chr>       <chr> <chr>         <dbl> <chr>        \n1   329 Hope Summers Female green       <NA>  Red             168 Marvel Comics\n2   257 Firelord     <NA>   white       <NA>  Yellow          193 Marvel Comics\n3   406 Light Lass   Female blue        <NA>  Red             165 DC Comics    \n# … with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>\n\n\nИли же долю строчек:\n\nheroes %>%\n  slice_sample(prop = .01)\n\n# A tibble: 7 × 11\n     X1 name             Gender `Eye color` Race  `Hair color`  Height Publisher\n  <dbl> <chr>            <chr>  <chr>       <chr> <chr>          <dbl> <chr>    \n1   188 Crimson Crusader Male   blue        <NA>  Strawberry B…     NA Marvel C…\n2   142 Bumbleboy        Male   <NA>        <NA>  <NA>              NA Marvel C…\n3   613 Space Ghost      Male   <NA>        Human <NA>             188 DC Comics\n4   621 Spider-Gwen      Female blue        Human Blond            165 Marvel C…\n5   316 Hawkwoman        Female green       <NA>  Red              175 DC Comics\n6   329 Hope Summers     Female green       <NA>  Red              168 Marvel C…\n7   360 Jessica Jones    Female brown       Human Brown            170 Marvel C…\n# … with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>\n\n\nЕсли поставить значение параметра prop = равным 1, то таким образом можно перемешать порядок строчек в тиббле:\n\nheroes %>%\n  slice_sample(prop = 1)\n\n# A tibble: 734 × 11\n      X1 name             Gender `Eye color` Race  `Hair color` Height Publisher\n   <dbl> <chr>            <chr>  <chr>       <chr> <chr>         <dbl> <chr>    \n 1   223 Doctor Fate      Male   blue        Human Blond           188 DC Comics\n 2   644 Superboy-Prime   Male   blue        Kryp… Black / Blue    180 DC Comics\n 3   553 Red Tornado      Male   green       Andr… No Hair         185 DC Comics\n 4   493 Nina Theroux     Female <NA>        Alpha <NA>             NA SyFy     \n 5   109 Blackwing        Male   blue        <NA>  Black           185 Marvel C…\n 6    14 Alex Mercer      Male   <NA>        Human <NA>             NA Wildstorm\n 7   411 Liz Sherman      Female <NA>        <NA>  <NA>             NA Dark Hor…\n 8   395 Kraven the Hunt… Male   brown       Human Black           183 Marvel C…\n 9   705 War Machine      Male   brown       Human Brown           185 Marvel C…\n10   384 Kid Flash        Male   green       Human Red              NA DC Comics\n# … with 724 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <dbl>\n\n\n\n\n8.6.4 Удаление строчек с NA: tidyr::drop_na()\nЕсли нужно выбрать только строчки без пропущенных значений, то можно воспользоваться удобной функцией tidyr::drop_na().\n\nheroes %>%\n  drop_na()\n\n# A tibble: 50 × 11\n      X1 name       Gender `Eye color` Race        `Hair color` Height Publisher\n   <dbl> <chr>      <chr>  <chr>       <chr>       <chr>         <dbl> <chr>    \n 1     1 Abe Sapien Male   blue        Icthyo Sap… No Hair         191 Dark Hor…\n 2     2 Abin Sur   Male   blue        Ungaran     No Hair         185 DC Comics\n 3    34 Apocalypse Male   red         Mutant      Black           213 Marvel C…\n 4    39 Archangel  Male   blue        Mutant      Blond           183 Marvel C…\n 5    41 Ardina     Female white       Alien       Orange          193 Marvel C…\n 6    56 Azazel     Male   yellow      Neyaphem    Black           183 Marvel C…\n 7    74 Beast      Male   blue        Mutant      Blue            180 Marvel C…\n 8    75 Beast Boy  Male   green       Human       Green           173 DC Comics\n 9    92 Bizarro    Male   black       Bizarro     Black           191 DC Comics\n10   108 Blackout   Male   red         Demon       White           191 Marvel C…\n# … with 40 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <dbl>\n\n\nМожно выбрать колонки, наличие NA в которых будет приводить к удалению соответствующих строчек (не затрагивая другие строчки, в которых есть NA в остальных столбцах).\n\nheroes %>%\n  drop_na(Weight)\n\n# A tibble: 495 × 11\n      X1 name          Gender `Eye color` Race     `Hair color` Height Publisher\n   <dbl> <chr>         <chr>  <chr>       <chr>    <chr>         <dbl> <chr>    \n 1     0 A-Bomb        Male   yellow      Human    No Hair         203 Marvel C…\n 2     1 Abe Sapien    Male   blue        Icthyo … No Hair         191 Dark Hor…\n 3     2 Abin Sur      Male   blue        Ungaran  No Hair         185 DC Comics\n 4     3 Abomination   Male   green       Human /… No Hair         203 Marvel C…\n 5     5 Absorbing Man Male   blue        Human    No Hair         193 Marvel C…\n 6     7 Adam Strange  Male   blue        Human    Blond           185 DC Comics\n 7     8 Agent 13      Female blue        <NA>     Blond           173 Marvel C…\n 8     9 Agent Bob     Male   brown       Human    Brown           178 Marvel C…\n 9    10 Agent Zero    Male   <NA>        <NA>     <NA>            191 Marvel C…\n10    11 Air-Walker    Male   blue        <NA>     White           188 Marvel C…\n# … with 485 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <dbl>\n\n\nДля выбора колонок в drop_na() используется tidyselect, с которым мы недавно познакомились (@ref(tidyselect)).\n\n\n8.6.5 Сортировка строк: dplyr::arrange()\nФункция dplyr::arrange() сортирует строчки от меньшего к большему (или по алфавиту - для текстовых значений) по выбранной колонке.\n\nheroes %>%\n  arrange(Weight)\n\n# A tibble: 734 × 11\n      X1 name            Gender `Eye color` Race   `Hair color` Height Publisher\n   <dbl> <chr>           <chr>  <chr>       <chr>  <chr>         <dbl> <chr>    \n 1   346 Iron Monger     Male   blue        <NA>   No Hair          NA Marvel C…\n 2   302 Groot           Male   yellow      Flora… <NA>            701 Marvel C…\n 3   350 Jack-Jack       Male   blue        Human  Brown            71 Dark Hor…\n 4   272 Galactus        Male   black       Cosmi… Black           876 Marvel C…\n 5   731 Yoda            Male   brown       Yoda'… White            66 George L…\n 6   255 Fin Fang Foom   Male   red         Kakar… No Hair         975 Marvel C…\n 7   330 Howard the Duck Male   brown       <NA>   Yellow           79 Marvel C…\n 8   396 Krypto          Male   blue        Krypt… White            64 DC Comics\n 9   568 Rocket Raccoon  Male   brown       Animal Brown           122 Marvel C…\n10   208 Dash            Male   blue        Human  Blond           122 Dark Hor…\n# … with 724 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <dbl>\n\n\nЧтобы отсортировать в обратном порядке, воспользуйтесь функцией desc().\n\nheroes %>%\n  arrange(desc(Weight))\n\n# A tibble: 734 × 11\n      X1 name       Gender `Eye color` Race        `Hair color` Height Publisher\n   <dbl> <chr>      <chr>  <chr>       <chr>       <chr>         <dbl> <chr>    \n 1   575 Sasquatch  Male   red         <NA>        Orange        305   Marvel C…\n 2   373 Juggernaut Male   blue        Human       Red           287   Marvel C…\n 3   203 Darkseid   Male   red         New God     No Hair       267   DC Comics\n 4   283 Giganta    Female green       <NA>        Red            62.5 DC Comics\n 5   331 Hulk       Male   green       Human / Ra… Green         244   Marvel C…\n 6   549 Red Hulk   Male   yellow      Human / Ra… Black         213   Marvel C…\n 7   119 Bloodaxe   Female blue        Human       Brown         218   Marvel C…\n 8   718 Wolfsbane  Female green       <NA>        Auburn        366   Marvel C…\n 9   657 Thanos     Male   red         Eternal     No Hair       201   Marvel C…\n10     0 A-Bomb     Male   yellow      Human       No Hair       203   Marvel C…\n# … with 724 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <dbl>\n\n\nМожно сортировать по нескольким колонкам сразу. В таких случаях удобно в качестве первой переменной выбирать переменную, обозначающую принадлежность к группе, а в качестве второй — континуальную числовую переменную:\n\nheroes %>%\n  arrange(Gender, desc(Weight))\n\n# A tibble: 734 × 11\n      X1 name      Gender `Eye color` Race         `Hair color` Height Publisher\n   <dbl> <chr>     <chr>  <chr>       <chr>        <chr>         <dbl> <chr>    \n 1   283 Giganta   Female green       <NA>         Red            62.5 DC Comics\n 2   119 Bloodaxe  Female blue        Human        Brown         218   Marvel C…\n 3   718 Wolfsbane Female green       <NA>         Auburn        366   Marvel C…\n 4   591 She-Hulk  Female green       Human        Green         201   Marvel C…\n 5   320 Hela      Female green       Asgardian    Black         213   Marvel C…\n 6   686 Valkyrie  Female blue        <NA>         Blond         191   Marvel C…\n 7   596 Sif       Female blue        Asgardian    Black         188   Marvel C…\n 8   271 Frigga    Female blue        <NA>         White         180   Marvel C…\n 9   667 Thundra   Female green       <NA>         Red           218   Marvel C…\n10   592 She-Thing Female blue        Human / Rad… No Hair       183   Marvel C…\n# … with 724 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <dbl>"
  },
  {
    "objectID": "110-tidyverse_basic.html#tidy_mutate",
    "href": "110-tidyverse_basic.html#tidy_mutate",
    "title": "8  Введение в tidyverse",
    "section": "8.7 Создание колонок: dplyr::mutate() и dplyr::transmute()",
    "text": "8.7 Создание колонок: dplyr::mutate() и dplyr::transmute()\nФункция dplyr::mutate() позволяет создавать новые колонки в тиббле.\n\nheroes %>%\n  mutate(imt = Weight/(Height/100)^2) %>%\n  select(name, imt) %>%\n  arrange(desc(imt))\n\n# A tibble: 734 × 2\n   name          imt\n   <chr>       <dbl>\n 1 Utgard-Loki 2510.\n 2 Giganta     1613.\n 3 Red Hulk     139.\n 4 Darkseid     115.\n 5 Machine Man  114.\n 6 Thanos       110.\n 7 Destroyer    108.\n 8 A-Bomb       107.\n 9 Abomination  107.\n10 Hulk         106.\n# … with 724 more rows\n\n\ndplyr::transmute() - это аналог mutate(), который не только создает новые колонки, но и сразу же выкидывает все старые:\n\nheroes %>%\n  transmute(imt = Weight/(Height/100)^2)\n\n# A tibble: 734 × 1\n     imt\n   <dbl>\n 1 107. \n 2  17.8\n 3  26.3\n 4 107. \n 5  NA  \n 6  32.8\n 7  NA  \n 8  25.7\n 9  20.4\n10  25.6\n# … with 724 more rows\n\n\nВнутри mutate() и transmute() мы можем использовать либо векторизованные операции (длина новой колонки должна равняться длине датафрейма), либо операции, которые возвращают одно значение. В последнем случае значение будет одинаковым на всю колонку, т.е. будет работать правило ресайклинга (@ref(recycling)):\n\nheroes %>%\n  transmute(name, weight_mean = mean(Weight, na.rm = TRUE))\n\n# A tibble: 734 × 2\n   name          weight_mean\n   <chr>               <dbl>\n 1 A-Bomb               112.\n 2 Abe Sapien           112.\n 3 Abin Sur             112.\n 4 Abomination          112.\n 5 Abraxas              112.\n 6 Absorbing Man        112.\n 7 Adam Monroe          112.\n 8 Adam Strange         112.\n 9 Agent 13             112.\n10 Agent Bob            112.\n# … with 724 more rows\n\n\nОднако в функциях mutate() и transmute() правило ресайклинга не будет работать в остальных случаях: если полученный вектор будет не равен 1 или длине датафрейма, то мы получим ошибку.\n\nheroes %>%\n  mutate(one_and_two = 1:2)\n\nError in `mutate()`:\n! Problem while computing `one_and_two = 1:2`.\nx `one_and_two` must be size 734 or 1, not 2.\n\n\nЭто не баг, а фича: авторы пакета dplyr считают, что ресайклинг кратных друг другу векторов — это слишком удобное место для выстрелов себе в ногу. Поэтому в таких случаях разработчики dplyr рекомендуют использовать функцию rep(), знакомую нам уже очень давно (@ref(atomic)).\n\nheroes %>%\n  mutate(one_and_two = rep(1:2, length.out = nrow(.)))\n\n# A tibble: 734 × 12\n      X1 name          Gender `Eye color` Race     `Hair color` Height Publisher\n   <dbl> <chr>         <chr>  <chr>       <chr>    <chr>         <dbl> <chr>    \n 1     0 A-Bomb        Male   yellow      Human    No Hair         203 Marvel C…\n 2     1 Abe Sapien    Male   blue        Icthyo … No Hair         191 Dark Hor…\n 3     2 Abin Sur      Male   blue        Ungaran  No Hair         185 DC Comics\n 4     3 Abomination   Male   green       Human /… No Hair         203 Marvel C…\n 5     4 Abraxas       Male   blue        Cosmic … Black            NA Marvel C…\n 6     5 Absorbing Man Male   blue        Human    No Hair         193 Marvel C…\n 7     6 Adam Monroe   Male   blue        <NA>     Blond            NA NBC - He…\n 8     7 Adam Strange  Male   blue        Human    Blond           185 DC Comics\n 9     8 Agent 13      Female blue        <NA>     Blond           173 Marvel C…\n10     9 Agent Bob     Male   brown       Human    Brown           178 Marvel C…\n# … with 724 more rows, and 4 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <dbl>, one_and_two <int>"
  },
  {
    "objectID": "110-tidyverse_basic.html#tidy_aggregate",
    "href": "110-tidyverse_basic.html#tidy_aggregate",
    "title": "8  Введение в tidyverse",
    "section": "8.8 Агрегация данных в тиббле",
    "text": "8.8 Агрегация данных в тиббле\n\n8.8.1 Подытоживание: summarise()\nАггрегация по группам - это очень часто возникающая задача, например, это может использоваться для усреднения данных по испытуемым или условиям. Сделать аггрегацию в датафрейме удобной Хэдли Уикхэм пытался еще в предшественнике dplyr, пакете plyr. dplyr позволяет делать аггрегацию очень симпатичным и понятным способым. Аггрегация в dplyr состоит из двух этапов: группировки (group_by()) и подытоживания (summarise()). Начнем с последнего.\nФункция dplyr::summarise()8 позволяет аггрегировать данные в тиббле. Работает она очень похоже на mutate(), но если внутри mutate() используются векторизованные функции, возвращающие вектор такой же длины, что и колонки, использовавшиеся для расчетов, то в summarise() используются функции, которые возвращают вектор длиной 1. Например, min(), mean(), max() и т.д. Можно создавать несколько колонок через запятую (это работает и для mutate()).\n\nheroes %>%\n  mutate(imt = Weight/(Height/100)^2) %>%\n  summarise(min(imt, na.rm = TRUE),\n            max(imt, na.rm = TRUE))\n\n# A tibble: 1 × 2\n  `min(imt, na.rm = TRUE)` `max(imt, na.rm = TRUE)`\n                     <dbl>                    <dbl>\n1                   0.0814                    2510.\n\n\nВ dplyr есть дополнительные суммирующие функции для более удобного индексирования в стиле tidyverse. Например, функции dplyr::nth(), dplyr::first() и dplyr::last(), которые позволяют вытаскивать значения из вектора по индексу (что-то вроде slice(), но для векторов)\n\nheroes %>%\n  mutate(imt = Weight/(Height/100)^2) %>%\n  arrange(imt) %>%\n  summarise(first = first(imt),\n            tenth = nth(imt, 10),\n            last = last(imt))\n\n# A tibble: 1 × 3\n   first tenth  last\n   <dbl> <dbl> <dbl>\n1 0.0814  16.7    NA\n\n\nВ отличие от mutate(), функции внутри summarise() вполне позволяют функциям внутри возвращать вектор из нескольких значений, создавая тиббл такой же длины, как и получившийся вектор.\n\nheroes %>%\n  mutate(imt = Weight/(Height/100)^2) %>%\n  summarise(imt_range = range(imt, na.rm = TRUE)) #функция range() возвращает вектор из двух значений: минимальное и максимальное\n\n# A tibble: 2 × 1\n  imt_range\n      <dbl>\n1    0.0814\n2 2510.    \n\n\n\n\n8.8.2 Группировка: group_by()\ndplyr::group_by() - это функция для группировки данных в тиббле по дискретной переменной для дальнейшей аггрегации с помощью summarise(). После применения group_by() тиббл будет выглядеть так же, но у него появятся атрибут groups9:\n\nheroes %>%\n  group_by(Gender)\n\n# A tibble: 734 × 11\n# Groups:   Gender [3]\n      X1 name          Gender `Eye color` Race     `Hair color` Height Publisher\n   <dbl> <chr>         <chr>  <chr>       <chr>    <chr>         <dbl> <chr>    \n 1     0 A-Bomb        Male   yellow      Human    No Hair         203 Marvel C…\n 2     1 Abe Sapien    Male   blue        Icthyo … No Hair         191 Dark Hor…\n 3     2 Abin Sur      Male   blue        Ungaran  No Hair         185 DC Comics\n 4     3 Abomination   Male   green       Human /… No Hair         203 Marvel C…\n 5     4 Abraxas       Male   blue        Cosmic … Black            NA Marvel C…\n 6     5 Absorbing Man Male   blue        Human    No Hair         193 Marvel C…\n 7     6 Adam Monroe   Male   blue        <NA>     Blond            NA NBC - He…\n 8     7 Adam Strange  Male   blue        Human    Blond           185 DC Comics\n 9     8 Agent 13      Female blue        <NA>     Blond           173 Marvel C…\n10     9 Agent Bob     Male   brown       Human    Brown           178 Marvel C…\n# … with 724 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <dbl>\n\n\nЕсли после этого применить на тиббле функцию summarise(), то мы получим не тиббл длиной один, а тиббл со значением для каждой из групп.\n\nheroes %>%\n  mutate(imt = Weight/(Height/100)^2) %>%\n  group_by(Gender) %>%\n  summarise(min(imt, na.rm = TRUE),\n            max(imt, na.rm = TRUE))\n\n# A tibble: 3 × 3\n  Gender `min(imt, na.rm = TRUE)` `max(imt, na.rm = TRUE)`\n  <chr>                     <dbl>                    <dbl>\n1 Female                  15.5                       1613.\n2 Male                     0.0814                    2510.\n3 <NA>                    16.3                        114.\n\n\nСхематически это выглядит вот так:\n\n\n\n8.8.3 Подсчет строк: dplyr::n(), dplyr::count()\nДля подсчет количества значений можно воспользоваться функцией n().\n\nheroes %>%\n  group_by(Gender) %>%\n  summarise(n = n())\n\n# A tibble: 3 × 2\n  Gender     n\n  <chr>  <int>\n1 Female   200\n2 Male     505\n3 <NA>      29\n\n\nФункция n() вместе с group_by() внутри filter() позволяет удобным образом “отрезать” от тиббла редкие группы…\n\nheroes %>%\n  group_by(Race) %>%\n  filter(n() > 10) %>%\n  select(name, Race)\n\n# A tibble: 611 × 2\n# Groups:   Race [6]\n   name          Race             \n   <chr>         <chr>            \n 1 A-Bomb        Human            \n 2 Abomination   Human / Radiation\n 3 Absorbing Man Human            \n 4 Adam Monroe   <NA>             \n 5 Adam Strange  Human            \n 6 Agent 13      <NA>             \n 7 Agent Bob     Human            \n 8 Agent Zero    <NA>             \n 9 Air-Walker    <NA>             \n10 Ajax          Cyborg           \n# … with 601 more rows\n\n\nили же наоборот, выделить только маленькие группы:\n\nheroes %>%\n  group_by(Race) %>%\n  filter(n() == 1) %>%\n  select(name, Race)\n\n# A tibble: 34 × 2\n# Groups:   Race [34]\n   name          Race              \n   <chr>         <chr>             \n 1 Abe Sapien    Icthyo Sapien     \n 2 Abin Sur      Ungaran           \n 3 Alien         Xenomorph XX121   \n 4 Azazel        Neyaphem          \n 5 Bizarro       Bizarro           \n 6 Boba Fett     Human / Clone     \n 7 Darth Maul    Dathomirian Zabrak\n 8 Fin Fang Foom Kakarantharaian   \n 9 Gamora        Zen-Whoberian     \n10 Gladiator     Strontian         \n# … with 24 more rows\n\n\nТаблицу частот можно создать без group_by() и summarise(n = n()). Функция count() заменяет эту конструкцию:\n\nheroes %>%\n  count(Gender)\n\n# A tibble: 3 × 2\n  Gender     n\n  <chr>  <int>\n1 Female   200\n2 Male     505\n3 <NA>      29\n\n\nЭту таблицу частот удобно сразу проранжировать, указав в параметре sort = значение TRUE.\n\nheroes %>%\n  count(Gender, sort = TRUE)\n\n# A tibble: 3 × 2\n  Gender     n\n  <chr>  <int>\n1 Male     505\n2 Female   200\n3 <NA>      29\n\n\n\nФункция count(), несмотря на свою простоту, является одной из наиболее используемых в tidyverse.\n\n\n\n8.8.4 Уникальные значения: dplyr::distinct()\ndplyr::distinct() - это более быстрый аналог unique(), позволяет извлекать уникальные значения для одной или нескольких колонок.\n\nheroes %>%\n  distinct(Gender)\n\n# A tibble: 3 × 1\n  Gender\n  <chr> \n1 Male  \n2 Female\n3 <NA>  \n\n\n\nheroes %>%\n  distinct(Gender, Race)\n\n# A tibble: 81 × 2\n   Gender Race             \n   <chr>  <chr>            \n 1 Male   Human            \n 2 Male   Icthyo Sapien    \n 3 Male   Ungaran          \n 4 Male   Human / Radiation\n 5 Male   Cosmic Entity    \n 6 Male   <NA>             \n 7 Female <NA>             \n 8 Male   Cyborg           \n 9 Male   Xenomorph XX121  \n10 Male   Android          \n# … with 71 more rows\n\n\nИногда нужно аггрегировать данные, но при этом сохранить исходную структуру тиббла. Например, нужно посчитать размер групп или посчитать средние значения по группе для последующего сравнения с индивидуальными значениями.\n\n\n8.8.5 Создание колонок с группировкой\nВ tidyverse это можно сделать с помощью сочетания group_by() и mutate() (вместо summarise()):\n\nheroes %>%\n  group_by(Race) %>%\n  mutate(Race_n = n()) %>%\n  select(Race, name, Gender, Race_n)\n\n# A tibble: 734 × 4\n# Groups:   Race [62]\n   Race              name          Gender Race_n\n   <chr>             <chr>         <chr>   <int>\n 1 Human             A-Bomb        Male      208\n 2 Icthyo Sapien     Abe Sapien    Male        1\n 3 Ungaran           Abin Sur      Male        1\n 4 Human / Radiation Abomination   Male       11\n 5 Cosmic Entity     Abraxas       Male        4\n 6 Human             Absorbing Man Male      208\n 7 <NA>              Adam Monroe   Male      304\n 8 Human             Adam Strange  Male      208\n 9 <NA>              Agent 13      Female    304\n10 Human             Agent Bob     Male      208\n# … with 724 more rows\n\n\nРезультаты аггрегации были записаны в отдельную колонку, при этом значения этой колонки внутри одной группы повторяются:"
  },
  {
    "objectID": "205-eda.html",
    "href": "205-eda.html",
    "title": "Разведочный анализ и создание отчетов",
    "section": "",
    "text": "В главе ОПИС СТАТ мы впервые познакомимся со статистикой, а именно с ее наиболее простой частью – описательной статистикой. Здесь разобраны как сами статистики, так и функции, которые позволяют удобным образом посчитать их все вместе для имеющихся данных\nВ главах ВИЗ разобраны различные инструменты визуализации данных: как простые встроенные инструменты, более сложный и гибкий пакет ggplot2 с его дополнениями и даже интерактивные визуализации!\nВ главе РМАРКДАУН мы научимся делать отчеты и презентации с помощью R Markdown, совмещая отформатированный текст, картинки, ссылки и прочее с кусками кода. Кстати, эта книга написана именно с помощью R Markdown!"
  },
  {
    "objectID": "210-desc_stats.html#типы-шкал",
    "href": "210-desc_stats.html#типы-шкал",
    "title": "10  Описательная статистика",
    "section": "10.2 Типы шкал",
    "text": "10.2 Типы шкал\nПеред тем, как начать речь об описательных статистиках, нужно разобраться с существующими типами шкал. Типы шкал классифицируются на основании типа измеряемых данных, которые задают допустимые для данной шкалы отношения.\n- Шкала наименований (номинальная шкала) — самая простая шкала, где единственное отношение между элементами — это отношения равенства и неравенства. Это любая качественная шкала, между элементами которой не могут быть установлены отношения “больше — меньше”. Это большинство группирующих переменных (экспериментальная группа, пол, политическая партия, страна), переменные с id. Еще один пример - номера на майках у футболистов.\n- Шкала порядка (ранговая шкала) — шкала следующего уровня, для которой можно установить отношения “больше — меньше”, причем если B больше A, а C больше B, то и C должно быть больше A. Если это верно, то мы можем выстроить последовательность значений. Однако мы еще не можем говорить о разнице между значениями. Ответы на вопросы “Как часто вы курите?” по шкале “Никогда”, “Редко” и “Часто” являются примером ранговой шкалы. “Часто” — это чаще, чем “Редко”, “Редко” — это чаще чем “Никогда”, и, соотвественно, “Часто” — это чаще, чем “Никогда”. Но мы не можем сказать, что разница между “Часто” и “Редко” такая же, как и между “Редко” и “Никогда”. Соответственно, даже если мы обозначим “Часто”, “Редко” и “Никогда” как 3, 2 и 1 соответственно, то многого не можем сделать с этой шкалой, Например, мы не можем посчитать арифметическое среднее для такой шкалы.\n- Шкала разностей (интервальная шкала) — шкала, для которой мы уже можем говорить про разницы между интервалами. Например, разница между 10 Cº и 20 Cº такая же как и между 80 Cº и 90 Cº. Для шкалы разностей уже можно сравнивать средние, но операции умножения и деления не имеют смысл, потому что ноль в шкале разностей относительный. Например, мы не можем сказать, что 20 Cº — это в два раза теплее, чем 10 Cº, потому что 0 Cº — это просто условно взятая точка — температура плавления льда.\n- Шкала отношений (абсолютная шкала) — самая “полноценная” шкала, которая отличается от интервальной наличием естественного и однозначного начала координат. Например, масса в килограммах или та же температура, но в градусах Кельвина, а не Цельсия."
  },
  {
    "objectID": "210-desc_stats.html#cent_tend",
    "href": "210-desc_stats.html#cent_tend",
    "title": "10  Описательная статистика",
    "section": "10.3 Меры центральной тенденции",
    "text": "10.3 Меры центральной тенденции\nПродолжим работать с данными про супергероев.\n\nlibrary(\"tidyverse\")\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──\n\n\n✓ ggplot2 3.3.5     ✓ purrr   0.3.4\n✓ tibble  3.1.6     ✓ dplyr   1.0.8\n✓ tidyr   1.2.0     ✓ stringr 1.4.0\n✓ readr   1.4.0     ✓ forcats 0.5.1\n\n\nWarning: package 'tidyr' was built under R version 4.0.5\n\n\nWarning: package 'dplyr' was built under R version 4.0.5\n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\nx dplyr::filter() masks stats::filter()\nx dplyr::lag()    masks stats::lag()\n\nheroes <- read_csv(\"https://raw.githubusercontent.com/Pozdniakov/tidy_stats/master/data/heroes_information.csv\",\n                   na = c(\"-\", \"-99\"))\n\nWarning: Missing column names filled in: 'X1' [1]\n\n\n\n── Column specification ────────────────────────────────────────────────────────\ncols(\n  X1 = col_double(),\n  name = col_character(),\n  Gender = col_character(),\n  `Eye color` = col_character(),\n  Race = col_character(),\n  `Hair color` = col_character(),\n  Height = col_double(),\n  Publisher = col_character(),\n  `Skin color` = col_character(),\n  Alignment = col_character(),\n  Weight = col_double()\n)\n\n\nДля примера мы возьмем массу супергероев, предварительно удалив из нее все NA для удобства.\n\nweight <- heroes %>%\n  drop_na(Weight) %>%\n  pull(Weight)\n\nМера центральной тенденции - это число для описания центра распределения.\n\n10.3.1 Арифметическое среднее\nСамая распространенная мера центральных тенденций - арифметическое среднее, то самое, которые мы считаем с помощью функции mean().\n\\[\\overline{x}= \\frac{\\sum\\limits_{i=1}^{n} x_{i}} {n}\\]\nНе пугайтесь значка \\[\\sum\\limits_{i=1}^{n}\\] - это означает сумму от i = 1 до n. Что-то вроде цикла for!\nВ качестве упражнения попробуйте самостоятельно превратить эту формулу в функцию mymean() c помощью sum() и length(). Можете убирать NA по дефолту! Сравните с результатом функции mean().\n\nmean(weight)\n\n[1] 112.2525\n\n\n\n\n10.3.2 Медиана\nМедиана - это середина распределения. Представим, что мы расставили значения по порядку (от меньшего к большему) и взяли значение по середине. Если у нас четное количество значений, то берется среднее значение между теми двумя, что по середине. Для расчета медианы есть функция median():\n\nmedian(weight)\n\n[1] 81\n\n\nРазница медианы со средним не очень существенная. Это значит, что распределение довольно “симметричное”. Но бывает и по-другому.\nПредставьте себе, что кто-то говорит про среднюю зарплату в Москве. Но ведь эта средняя зарплата становится гораздо больше, если учитывать относительно небольшое количество мультимиллионеров и миллиардеров! А вот медианная зарплата будет гораздо меньше.\nПредставьте себе, что в среде супергероев поялвяется кто-то, кто весит 9000 килограммов! Тогда среднее сильно изменится:\n\nmean(c(weight, 9000))\n\n[1] 130.1714\n\n\nА вот медиана останется той же.\n\nmedian(c(weight, 9000))\n\n[1] 81\n\n\nТаким образом, экстремально большие или маленькие значения оказывают сильное влияние на арифметическое среднее, но не на медиану. Поэтому медиана считается более “робастной” оценкой, т.е. более устойчивой к выбросам и крайним значениям.\n\n\n10.3.3 Усеченное среднее (trimmed mean)\nЕсли про среднее и медиану слышали все, то про усеченное (тримленное) среднее известно гораздо меньше. Тем не менее, на практике это довольно удобная штука, потому что представляет собой некий компромисс между арифметическим средним и медианой.\nВ усеченном среднем значения ранжируются так же, как и для медианы, но отбрасывается только какой-то процент крайних значений. Усеченное среднее можно посчитать с помощью обычной функции mean(), поставив нужное значение параметра trim =:\n\nmean(weight, trim = 0.1)\n\n[1] 89.56423\n\n\ntrim = 0.1 означает, что мы отбросили 10% слева и 10% справа. trim может принимать значения от 0 до 0.5. Что будет, если trim = 0?\n\nmean(weight, trim = 0)\n\n[1] 112.2525\n\n\nОбычное арифметическое среднее! А если trim = 0.5?\n\nmean(weight, trim = 0.5)\n\n[1] 81\n\n\nМедиана!\n\n\n10.3.4 Мода\nМода (mode) - это самое частое значение. Обычно используется для номинальных переменных, для континуальных данных мода неприменима. Что интересно, в R нет встроенной функции для подсчета моды. Обычно она и не нужна: мы можем посчитать таблицу частот и даже проранжировать ее (и мы уже умеем это делать разными способами).\n\nheroes %>%\n  count(Gender, sort = TRUE)\n\n# A tibble: 3 × 2\n  Gender     n\n  <chr>  <int>\n1 Male     505\n2 Female   200\n3 <NA>      29\n\n\n\nМожете попробовать написать свою функцию для моды!"
  },
  {
    "objectID": "210-desc_stats.html#vary",
    "href": "210-desc_stats.html#vary",
    "title": "10  Описательная статистика",
    "section": "10.4 Меры рассеяния",
    "text": "10.4 Меры рассеяния\n\nНачинающий статистик пытался перейти в брод реку, средняя глубина которой 1 метр. И утонул.\nВ чем была его ошибка? Он не учитывал разброс значений глубины!\n\nМер центральной тенденции недостаточно, чтобы описать выборку. Необходимо знать ее вариабельность.\n\n\n10.4.1 Размах {range}\nСамое очевидное - посчитать размах (range), то есть разницу между минимальным и максимальным значением. В R есть функция для вывода максимального и минимального значений:\n\nrange(weight)\n\n[1]   2 900\n\n\nОсталось посчитать разницу между ними:\n\ndiff(range(weight))\n\n[1] 898\n\n\nЕстественно, крайние значения очень сильно влияют на этот размах, поэтому на практике он не очень-то используется.\n\n\n10.4.2 Дисперсия\nДисперсия (variance) вычисляется по следующей формуле:\n\\[s^2= \\frac{\\sum\\limits_{i=1}^{n} (x_{i} - \\overline{x})^2} {n}\\]\nПопробуйте превратить это в функцию myvar()!\n\nmyvar <- function(x) mean((x - mean(x))^2)\n\nЕстественно, в R уже есть готовая функция var(). Но, заметьте, ее результат немного отличается от нашего:\n\nmyvar(weight)\n\n[1] 10825.55\n\nvar(weight)\n\n[1] 10847.46\n\n\nДело в том, что встроенная функция var() делит не на \\(n\\), а на \\(n-1\\). Это связано с тем, что эта функция пытается оценить дисперсию в генеральной совокупности, т.е. относится уже к статистике вывода. Про это мы будем говорить в дальнейших занятиях, сейчас нам нужно только отметить то, что здесь есть небольшое различие.\n\n\n10.4.3 Стандартное отклонение\nЕсли вы заметили, значение дисперсии очень большое. Чтобы вернуться к единицам измерения, соответствующих нашим данным используется корень из дисперсии, то есть стандартное отклонение (standard deviation):\n\\[s= \\sqrt\\frac{\\sum\\limits_{i=1}^{n} (x_{i} - \\overline{x})^2} {n}\\]\nДля этого есть функция sd():\n\nsd(weight)\n\n[1] 104.1511\n\n\nЧто то же самое, что и:\n\nsqrt(var(weight))\n\n[1] 104.1511\n\n\n\n\n10.4.4 Медианное абсолютное отклонение\nПоскольку стандартное отклонение не устойчиво к выбросам, то иногда используют его альтернативу, которая устойчива к выбросам (особенно если эти выбросы нам как раз и нужно удалить) - медианное абсолютное отклонение (median absolute deviation):\n\\[mad= median(|x_{i} - median(x)|)\\]\nДля этого есть функция mad():\n\nmad(weight)\n\n[1] 32.6172\n\n\n\n\n10.4.5 Межквартильный размах\nДругой вариант рабостной оценки вариабельности данных является межквартильный размах (interquartile range, IQR). Это разница между третьим и первым квартилем 1 - значением, которое больше 75% значений в выборке, и значением, которое больше 25% значений в выборке.\n\nIQR(weight)\n\n[1] 47\n\n\n\nНу а второй квартиль - это медиана!"
  },
  {
    "objectID": "210-desc_stats.html#skku",
    "href": "210-desc_stats.html#skku",
    "title": "10  Описательная статистика",
    "section": "10.5 Ассиметрия и эксцесс",
    "text": "10.5 Ассиметрия и эксцесс\n\n10.5.1 Ассиметрия\nАссиметрия (skewness) измеряет симметричность распределения. Положительный показатель ассиметрии (“Right-skewed” или positive skewness) означает, что хвосты с правой части распределения длиннее. Негативный показатель ассиметрии (“Left-skewed” или negative skewness) означает, что левый хвост длиннее.\n\n\nНапример, в психологии положительная ассиметрия встречается очень часто. Например, время реакции: оно ограничено снизу 0 мс (а по факту не меньше 100 мс - быстрее сигнал не успеет по нервной системе пройти до пальцев), а вот с другой стороны оно никак не ограничено. Испытуемый может на полчаса перед монитором затупить, ага.\n\n\n\n10.5.2 Эксцесс\nЭксцесс (kurtosis) - это мера “вытянутости” распределения:\n\nПоложительные показатели эксцесса означают “вытянутое” распределение, а отрицательные - “плоское”.\n\n\n10.5.3 Ассиметрия и эксцесс в R\nК сожалению, в базовом R нет функций для ассиметрии и эксцесса. Зато есть замечательный пакет psych (да-да, специально для психологов).\n\ninstall.packages(\"psych\")\n\n\nlibrary(\"psych\")\n\nWarning: package 'psych' was built under R version 4.0.5\n\n\n\nAttaching package: 'psych'\n\n\nThe following objects are masked from 'package:ggplot2':\n\n    %+%, alpha\n\n\nВ нем есть функции skew() и kurtosi():\n\nskew(weight)\n\n[1] 3.874557\n\nkurtosi(weight)\n\n[1] 19.45699\n\n\nАссиметрия положительная, это значит что распределение выборки асимметричное, хвосты с правой части длиннее. Эксцесс значительно выше нуля - значит распределение довольно “вытянутое”."
  },
  {
    "objectID": "210-desc_stats.html#quantiles",
    "href": "210-desc_stats.html#quantiles",
    "title": "10  Описательная статистика",
    "section": "10.6 Квантили",
    "text": "10.6 Квантили\nВ жизни мы постоянно проходим какие-нибудь тесты, получаем баллы и рано или поздно встает вопрос: ну а как оно у других? Как бы нас ни учили книжки по саморазвитию, что не стоит сравнивать себя с другими, от этого вопроса очень сложно избавиться. А иногда и вовсе не нужно.\nДопустим, вы проходите профессиональный тест с задачами одинаковой сложности. Как понять, если вы решили 10 из 20 задач (допустим, что задачи одинаковой сложности), то это много или мало? Мы договорились, что задачи одинаковой сложности, но не сказали какой. Если все 20 задач очень легкие, то 10 – это мало, а если сложные – то много. В этой ситуации может быть важен относительный успех: сколько людей справились с тестом хуже вас, а сколько - лучше вас. Вот это и позволяют посчитать процентили (percentile rank) – процент значений в распределении ниже заданного значения. То есть 90ый процентиль означает, что вы справились лучше, чем 90% людей, который прошли тот же тест. То есть вы находитесь в 10% самых-самых! Поэтому настоящие понторезы должны меряться не абсолютными значениями, а процентилями.\nЗдесь сразу нужно оговориться, что понятие процентиля имеет несколько неоднозначностей. В английском принято разделять percentile и percentile rank. Percentile rank – это процент значений в распределении ниже заданного, то просто percentile – это само значение, ниже которого находится соответствующий процент значений. А иногда и вовсе процентилем называют сам интервал между процентильными границами. Все эти понятия взаимосвязаны, поэтому о том, в каком именно значении используется понятие “процентиль” можно догадаться из контекста. Другая неоднозначность понятия процентиля связана с тем, в какой процентиль относить пограничные значения. Эта проблема породила целых девять различных подходов к расчету процентилей! Однако если шкала континуальная и имеет достаточно много значений, то разницы между этими подходами не будет.\nМожно делить значения не на 100 интервалов, а на меньшее количество. Например, на 4. Для этого нам нужно три точки: одна отделяет 25% наименьших значений, вторая отделяет нижнее 50% от верхних 50% (то есть это медиана!), третья – верхние 25% отнижних 75%. Эти точки и интервалы, разделяемые ими, называются квартилями.\nКроме процентилей и квартилей есть еще децили, квинтили, секстили, септили и что угодно -тили, хотя и используются они гораздо реже. Общее название для всех них – квантили."
  },
  {
    "objectID": "210-desc_stats.html#summary",
    "href": "210-desc_stats.html#summary",
    "title": "10  Описательная статистика",
    "section": "10.7 А теперь все вместе!",
    "text": "10.7 А теперь все вместе!\nВ базовом R есть функция summary(), которая позволяет получить сразу неплохой набор описательных статистик.\n\nsummary(weight)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n    2.0    61.0    81.0   112.3   108.0   900.0 \n\n\n\nФункция summary() - это универсальная (generic) функция. Это означает, что Вы можете ее применять для разных объектов и получать разные результаты. Попробуйте применить ее к векторам с разными типами данных и даже к дата.фреймам и дата.тейблам. Посмотрите, что получится.\n\nВ пакете psych есть еще и замечательная функция describe(), которая даст Вам еще больше статистик, включая ассиметрию и куртозис:\n\npsych::describe(weight)\n\n   vars   n   mean     sd median trimmed   mad min max range skew kurtosis   se\nX1    1 495 112.25 104.15     81   89.56 32.62   2 900   898 3.87    19.46 4.68\n\n\nДаже усеченное (trimmed) среднее есть (с trim = 0.1)! Все кроме se мы уже знаем. А про этот se узнаем немного позже.\nЭта функция хорошо работает в сочетании с group_by():\n\nheroes %>%\n  group_by(Gender) %>%\n  summarise(describe(Weight))\n\n# A tibble: 3 × 14\n  Gender  vars     n  mean    sd median trimmed   mad   min   max range  skew\n  <chr>  <dbl> <dbl> <dbl> <dbl>  <dbl>   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1 Female     1   142  78.8  77.0     58    60.9  7.41    41   630   589  4.97\n2 Male       1   339 126.  111.      90   103.  23.7      2   900   898  3.76\n3 <NA>       1    14 129.  107.      94   115.  43.0     39   383   344  1.55\n# … with 2 more variables: kurtosis <dbl>, se <dbl>\n\n\nДругой интересный пакет для получения описательных статистик для всего датафрейма — skimr.\n\ninstall.packages(\"skimr\")\n\nЕго основная функция — skim(), выводит симпатичную сводную таблицу для датафрейма.\n\nskimr::skim(heroes)\n\n\nData summary\n\n\nName\nheroes\n\n\nNumber of rows\n734\n\n\nNumber of columns\n11\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n8\n\n\nnumeric\n3\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\nname\n0\n1.00\n1\n25\n0\n715\n0\n\n\nGender\n29\n0.96\n4\n6\n0\n2\n0\n\n\nEye color\n172\n0.77\n3\n23\n0\n22\n0\n\n\nRace\n304\n0.59\n5\n18\n0\n61\n0\n\n\nHair color\n172\n0.77\n3\n16\n0\n29\n0\n\n\nPublisher\n0\n1.00\n0\n17\n15\n25\n0\n\n\nSkin color\n662\n0.10\n3\n14\n0\n16\n0\n\n\nAlignment\n7\n0.99\n3\n7\n0\n3\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nX1\n0\n1.00\n366.50\n212.03\n0.0\n183.25\n366.5\n549.75\n733\n▇▇▇▇▇\n\n\nHeight\n217\n0.70\n186.73\n59.25\n15.2\n173.00\n183.0\n191.00\n975\n▇▁▁▁▁\n\n\nWeight\n239\n0.67\n112.25\n104.15\n2.0\n61.00\n81.0\n108.00\n900\n▇▁▁▁▁\n\n\n\n\n\nЗдесь количество и доля пропущенных значений, среднее, стандартное отклонение, минимальное и максимальное значение (p0 и p100 соответственно), квартили. Ну и вишенкой на торте выступает маленькая гистограмма для каждой колонки!\nКроме того, skimr адаптирован под tidyverse. В нем можно выбирать колонки с помощью tidyselect (@ref(tidyselect)) прямо внутри функции skim().\n\nheroes %>%\n  skimr::skim(ends_with(\"color\"))\n\n\nData summary\n\n\nName\nPiped data\n\n\nNumber of rows\n734\n\n\nNumber of columns\n11\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n3\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\nEye color\n172\n0.77\n3\n23\n0\n22\n0\n\n\nHair color\n172\n0.77\n3\n16\n0\n29\n0\n\n\nSkin color\n662\n0.10\n3\n14\n0\n16\n0\n\n\n\n\n\nА еще можно сочетать с группировкой с помощью group_by().\n\nheroes %>%\n  group_by(Gender) %>%\n  skimr::skim(ends_with(\"color\"))\n\n\nData summary\n\n\nName\nPiped data\n\n\nNumber of rows\n734\n\n\nNumber of columns\n11\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n3\n\n\n________________________\n\n\n\nGroup variables\nGender\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nGender\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\nEye color\nFemale\n41\n0.80\n3\n23\n0\n14\n0\n\n\nEye color\nMale\n121\n0.76\n3\n12\n0\n18\n0\n\n\nEye color\nNA\n10\n0.66\n3\n23\n0\n7\n0\n\n\nHair color\nFemale\n38\n0.81\n3\n16\n0\n18\n0\n\n\nHair color\nMale\n123\n0.76\n3\n16\n0\n23\n0\n\n\nHair color\nNA\n11\n0.62\n4\n14\n0\n10\n0\n\n\nSkin color\nFemale\n186\n0.07\n4\n6\n0\n7\n0\n\n\nSkin color\nMale\n449\n0.11\n3\n14\n0\n14\n0\n\n\nSkin color\nNA\n27\n0.07\n4\n4\n0\n2\n0\n\n\n\n\n\n###Описательных статистик недостаточно {#datasaurus}\n\n\n\nЯ в тайне от Вас загрузил данные в переменную xxx (можете найти этот набор данных здесь, если интересно). Выглядят они примерно так:\n\nhead(xxx)\n\n# A tibble: 6 × 2\n      x     y\n  <dbl> <dbl>\n1  55.4  97.2\n2  51.5  96.0\n3  46.2  94.5\n4  42.8  91.4\n5  40.8  88.3\n6  38.7  84.9\n\nstr(xxx)\n\nspec_tbl_df [142 × 2] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ x: num [1:142] 55.4 51.5 46.2 42.8 40.8 ...\n $ y: num [1:142] 97.2 96 94.5 91.4 88.3 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   x = col_double(),\n  ..   y = col_double()\n  .. )\n\n\nНадеюсь, Вы уже понимаете, как это интерпретировать - два столбца с 142 числами каждый. Представьте себе, как выглядят эти точки на плоскости, если каждая строчка означают координаты одной точки по осям x и y (это называется диаграмма рассеяния, точечная диаграмма или scatterplot).\n\n\n\n\n\nПрименим разные функции, которые мы выучили:\n\nmean(xxx$x)\n\n[1] 54.26327\n\nmean(xxx$y)\n\n[1] 47.83225\n\nmedian(xxx$x)\n\n[1] 53.3333\n\nmedian(xxx$y)\n\n[1] 46.0256\n\n\nСредние и медианы примерно одинаковые, при этом по х они около 53-54, а по у - примерно 46-47. Попытайтесь представить это. Идем дальше:\n\nsd(xxx$x)\n\n[1] 16.76514\n\nsd(xxx$y)\n\n[1] 26.9354\n\n\nПохоже, разброс по у несколько больше, верно?\n\nskew(xxx$x)\n\n[1] 0.2807568\n\nskew(xxx$y)\n\n[1] 0.2472603\n\nkurtosi(xxx$x)\n\n[1] -0.2854912\n\nkurtosi(xxx$y)\n\n[1] -1.063552\n\n\nПохоже, оба распределения немного право-ассиметричны и довольно “плоские”.\nДавайте еще посчитаем коэффициент корреляции (correlation coefficient). Мы про него будем говорить позже гораздо подробнее. Пока что нам нужно знать, что она говорит о линейной связи двух переменных. Если коэффициент корреляции положительный (максимум равен 1), то чем больше х, тем больше у. Если отрицательный (минимум равен -1), то чем больше х, тем меньше у. Если же коэффициент корреляции равна нулю, то такая линейная зависимость отсутствует.\n\ncor(xxx$x, xxx$y)\n\n[1] -0.06447185\n\n\nКоэффициент корреляции очень близка к нулю (делайте выводы и представляйте).\nДавайте напоследок воспользуемся функцией describe() из psych:\n\npsych::describe(xxx)\n\n  vars   n  mean    sd median trimmed   mad   min   max range skew kurtosis\nx    1 142 54.26 16.77  53.33   53.69 15.97 22.31 98.21 75.90 0.28    -0.29\ny    2 142 47.83 26.94  46.03   46.90 30.79  2.95 99.49 96.54 0.25    -1.06\n    se\nx 1.41\ny 2.26\n\n\n\nskimr::skim(xxx)\n\n\nData summary\n\n\nName\nxxx\n\n\nNumber of rows\n142\n\n\nNumber of columns\n2\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n2\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nx\n0\n1\n54.26\n16.77\n22.31\n44.10\n53.33\n64.74\n98.21\n▅▇▇▅▂\n\n\ny\n0\n1\n47.83\n26.94\n2.95\n25.29\n46.03\n68.53\n99.49\n▇▇▇▅▆\n\n\n\n\n\nГотовы узнать, как выглядят эти данные на самом деле?!\n\n\nЖмите сюда если готовы!\n\n\n\n\n\n\n\nИз этого можно сделать важный вывод: не стоит слепо доверять описательным статистикам. Нужно визуализировать данные, иначе можно попасть в такую ситуацию в реальности. По словам знаменитого статитстика Джона Тьюки, величайшая ценность картинки в том, что она заставляет нас заметить то, что мы не ожидали заметить. Поэтому графики — это не просто метод коммуникации — представления ваших результатов сообществу в понятном виде (хотя и это, конечно, тоже), но и сам по себе очень важный метод анализа данных."
  },
  {
    "objectID": "910-tasks.html",
    "href": "910-tasks.html",
    "title": "24  Задания",
    "section": "",
    "text": "Задания, которые помечены звездочкой (*) можно пропускать: это задания повышенной сложности, в них требуется подумать над решением, а не просто применить выученные инструменты."
  },
  {
    "objectID": "910-tasks.html#task_begin",
    "href": "910-tasks.html#task_begin",
    "title": "24  Задания",
    "section": "24.1 Начало работы в R",
    "text": "24.1 Начало работы в R\n\nРазделите 9801 на 9.\n\n\n\n[1] 1089\n\n\n\nПосчитайте логарифм от 2176782336 по основанию 6.\n\n\n\n[1] 12\n\n\n\nТеперь натуральный логарифм 10 и умножьте его на 5.\n\n\n\n[1] 11.51293\n\n\n\nС помощью функции sin() посчитайте \\(\\sin (\\pi), \\sin \\left(\\frac{\\pi}{2}\\right), \\sin \\left(\\frac{\\pi}{6}\\right)\\).\n\n\nЗначение \\(\\pi\\) - зашитая в R константа (pi).\n\n\n\n[1] 1.224647e-16\n\n\n[1] 1\n\n\n[1] 0.5"
  },
  {
    "objectID": "910-tasks.html#task_new_vecs",
    "href": "910-tasks.html#task_new_vecs",
    "title": "24  Задания",
    "section": "24.2 Создание векторов",
    "text": "24.2 Создание векторов\n\nСоздайте вектор из значений 2, 30 и 4000.\n\n\n\n[1]    2   30 4000\n\n\n\nСоздайте вектор от 1 до 20.\n\n\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20\n\n\n\nСоздайте вектор от 20 до 1.\n\n\n\n [1] 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1\n\n\nФункция sum() возвращает сумму элементов вектора на входе. Посчитайте сумму первых 100 натуральных чисел (т.е. всех целых чисел от 1 до 100).\n\n\n[1] 5050\n\n\n\nСоздайте вектор от 1 до 20 и снова до 1. Число 20 должно присутствовать только один раз!\n\n\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 19 18 17 16 15\n[26] 14 13 12 11 10  9  8  7  6  5  4  3  2  1\n\n\n\nСоздайте вектор значений 5, 4, 3, 2, 2, 3, 4, 5:\n\n\n\n[1] 5 4 3 2 2 3 4 5\n\n\n\nСоздайте вектор 2, 4, 6, … , 18, 20.\n\n\n\n [1]  2  4  6  8 10 12 14 16 18 20\n\n\n\nСоздайте вектор 0.1, 0.2, 0.3, …, 0.9, 1.\n\n\n\n [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0\n\n\n\n2020 год – високосный. Следующий високосный год через 4 года – это будет 2024 год. Составьте календарь всех високосных годов XXI века, начиная с 2020 года.\n\n\n2100 год относится к XXI веку, а не к XXII.\n\n\n\n [1] 2020 2024 2028 2032 2036 2040 2044 2048 2052 2056 2060 2064 2068 2072 2076\n[16] 2080 2084 2088 2092 2096 2100\n\n\n\nСоздайте вектор, состоящий из 20 повторений “Хэй!”.\n\n\n\n [1] \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\"\n[11] \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\"\n\n\n\nКак я и говорил, многие функции, работающие с одним значением на входе, так же прекрасно работают и с целыми векторами. Попробуйте посчитать квадратный корень чисел от 1 до 10 с помощью функции sqrt() и сохраните результат в векторе roots. Выведите содержание вектора roots в консоль.\n\n\n\n [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427\n [9] 3.000000 3.162278\n\n\n\n*Создайте вектор из одной единицы, двух двоек, трех троек, …. , девяти девяток.\n\n\n\n [1] 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 6 6 6 6 6 6 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 9 9\n[39] 9 9 9 9 9 9 9"
  },
  {
    "objectID": "910-tasks.html#task_coer",
    "href": "910-tasks.html#task_coer",
    "title": "24  Задания",
    "section": "24.3 Приведение типов",
    "text": "24.3 Приведение типов\n\nСделайте вектор vec1, в котором соедините 3, а также значения \"Мой\" и \"вектор\".\n\n\n\n[1] \"3\"      \"Мой\"    \"вектор\"\n\n\n\nПопробуйте вычесть TRUE из 10.\n\n\n\n[1] 9\n\n\n\nСоедините значение 10 и TRUE в вектор vec2.\n\n\n\n[1] 10  1\n\n\n\nСоедините вектор vec2 и значение \"r\":\n\n\n\n[1] \"10\" \"1\"  \"r\" \n\n\n\nСоедините значения 10, TRUE, \"r\" в вектор.\n\n\n\n[1] \"10\"   \"TRUE\" \"r\""
  },
  {
    "objectID": "910-tasks.html#task_vec_ion",
    "href": "910-tasks.html#task_vec_ion",
    "title": "24  Задания",
    "section": "24.4 Векторизация",
    "text": "24.4 Векторизация\n\nСоздайте вектор p, состоящий из значений 4, 5, 6, 7, и вектор q, состоящий из 0, 1, 2, 3.\n\n\n\n[1] 4 5 6 7\n\n\n[1] 0 1 2 3\n\n\n\nПосчитайте поэлементную сумму векторов p и q:\n\n\n\n[1]  4  6  8 10\n\n\n\nПосчитайте поэлементную разницу p и q:\n\n\n\n[1] 4 4 4 4\n\n\n\nПоделите каждый элемент вектора p на соответствующий ему элемент вектора q:\n\n\nО, да, Вам нужно делить на 0!\n\n\n\n[1]      Inf 5.000000 3.000000 2.333333\n\n\n\nВозведите каждый элемент вектора p в степень соответствующего ему элемента вектора q:\n\n\n\n[1]   1   5  36 343\n\n\n\nУмножьте каждое значение вектора p на 10.\n\n\n\n[1] 40 50 60 70\n\n\n\nСоздайте вектор квадратов чисел от 1 до 10:\n\n\n\n [1]   1   4   9  16  25  36  49  64  81 100\n\n\n\nСоздайте вектор 0, 2, 0, 4, … , 18, 0, 20.\n\n\n\n [1]  0  2  0  4  0  6  0  8  0 10  0 12  0 14  0 16  0 18  0 20\n\n\n\nСоздайте вектор 1, 0, 3, 0, 5, …, 17, 0, 19, 0.\n\n\n\n [1]  1  0  3  0  5  0  7  0  9  0 11  0 13  0 15  0 17  0 19  0\n\n\n\n*Создайте вектор, в котором будут содержаться первые 20 степеней двойки.\n\n\n\n [1]       2       4       8      16      32      64     128     256     512\n[10]    1024    2048    4096    8192   16384   32768   65536  131072  262144\n[19]  524288 1048576\n\n\n\n*Создайте вектор из чисел 1, 10, 100, 1000, 10000:\n\n\n\n[1]     1    10   100  1000 10000\n\n\n\n*Посчитать сумму последовательности \\(\\frac{1}{1 \\cdot 2}+\\frac{1}{2 \\cdot 3}+\\frac{1}{3 \\cdot 4}+\\ldots+\\frac{1}{50 \\cdot 51}\\).\n\n\n\n[1] 0.9803922\n\n\n\n*Посчитать сумму последовательности \\(\\frac{1}{2^{0}}+\\frac{1}{2^{1}}+\\frac{1}{2^{2}}+\\frac{1}{2^{3}}+\\ldots \\frac{1}{2^{20}}\\).\n\n\n\n[1] 1.999999\n\n\n\n*Посчитать сумму последовательности \\(1+\\frac{4}{3}+\\frac{7}{9}+\\frac{10}{27}+\\frac{13}{81}+\\ldots+\\frac{28}{19683}\\).\n\n\n\n[1] 3.749174\n\n\n\n*Сколько чисел из последовательности \\(1+\\frac{4}{3}+\\frac{7}{9}+\\frac{10}{27}+\\frac{13}{81}+\\ldots+\\frac{28}{19683}\\) больше чем 0.5?\n\n\n\n[1] 3"
  },
  {
    "objectID": "910-tasks.html#task_vec_ind",
    "href": "910-tasks.html#task_vec_ind",
    "title": "24  Задания",
    "section": "24.5 Индексирование векторов",
    "text": "24.5 Индексирование векторов\n\nСоздайте вектор troiki со значениями 3, 6, 9, …, 24, 27.\n\n\n\n[1]  3  6  9 12 15 18 21 24 27\n\n\n\nИзвлеките 2, 5 и 7 значения вектора troiki.\n\n\n\n[1]  6 15 21\n\n\n\nИзвлеките предпоследнее значение вектора troiki.\n\n\n\n[1] 24\n\n\n\nИзвлеките все значения вектора troiki кроме предпоследнего:\n\n\n\n[1]  3  6  9 12 15 18 21 27\n\n\nСоздайте вектор vec3, скопировав следующий код:\n\nvec3 <- c(3, 5, 2, 1, 8, 4, 9, 10, 3, 15, 1, 11)\n\n\nНайдите второй элемент вектора vec3.\n\n\n\n[1] 5\n\n\n\nВерните второй и пятый элемент вектора vec3.\n\n\n\n[1] 5 8\n\n\n\nПопробуйте извлечь сотое значение вектора vec3:\n\n\n\n[1] NA\n\n\n\nВерните все элементы вектора vec3 кроме второго элемента.\n\n\n\n [1]  3  2  1  8  4  9 10  3 15  1 11\n\n\n\nВерните все элементы вектора vec3 кроме второго и пятого элемента.\n\n\n\n [1]  3  2  1  4  9 10  3 15  1 11\n\n\n\nНайдите последний элемент вектора vec3.\n\n\n\n[1] 11\n\n\n\nВерните все значения вектора vec3 кроме первого и последнего.\n\n\n\n [1]  5  2  1  8  4  9 10  3 15  1\n\n\n\nНайдите все значения вектора vec3, которые больше 4.\n\n\n\n[1]  5  8  9 10 15 11\n\n\n\nНайдите все значения вектора vec3, которые больше 4, но меньше 10.\n\n\nЕсли хотите сделать это в одну строчку, то вам помогут логические операторы!\n\n\n\n[1] 5 8 9\n\n\n\nНайдите все значения вектора vec3, которые меньше 4 или больше 10.\n\n\n\n[1]  3  2  1  3 15  1 11\n\n\n\nВозведите в квадрат каждое значение вектора vec3.\n\n\n\n [1]   9  25   4   1  64  16  81 100   9 225   1 121\n\n\n\n*Возведите в квадрат каждое значение вектора на нечетной позиции и извлеките корень из каждого значения на четной позиции вектора vec3.\n\n\nИзвлечение корня - это то же самое, что и возведение в степень 0.5.\n\n\n\n [1]  9.000000  2.236068  4.000000  1.000000 64.000000  2.000000 81.000000\n [8]  3.162278  9.000000  3.872983  1.000000  3.316625\n\n\n\nСоздайте вектор 2, 4, 6, … , 18, 20 как минимум 2 новыми способами.\n\n\nЗнаю, это задание может показаться бессмысленным, но это очень базовая операция, с помощью которой можно, например, разделить данные на две части. Чем больше способов Вы знаете, тем лучше!\n\n\n\n [1]  2  4  6  8 10 12 14 16 18 20"
  },
  {
    "objectID": "910-tasks.html#task_na",
    "href": "910-tasks.html#task_na",
    "title": "24  Задания",
    "section": "24.6 Работа с пропущенными значениями",
    "text": "24.6 Работа с пропущенными значениями\n\nСоздайте вектор vec4 со значениями 300, 15, 8, 2, 0, 1, 110, скопировав следующий код:\n\n\nvec4 <- c(300, 15, 8, 20, 0, 1, 110)\nvec4\n\n[1] 300  15   8  20   0   1 110\n\n\n\nЗамените все значения vec4, которые больше 20 на NA.\n\n\n\n\n\nПроверьте полученный вектор vec4:\n\n\n\n[1] NA 15  8 20  0  1 NA\n\n\n\nПосчитайте сумму vec4 с помощью функции sum(). Ответ NA не считается!\n\n\n\n[1] 44"
  },
  {
    "objectID": "910-tasks.html#task_matrix",
    "href": "910-tasks.html#task_matrix",
    "title": "24  Задания",
    "section": "24.7 Матрицы",
    "text": "24.7 Матрицы\n\nСоздайте матрицу 4х4, состоящую из единиц. Назовите ее M1.\n\n\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    1    1    1\n[2,]    1    1    1    1\n[3,]    1    1    1    1\n[4,]    1    1    1    1\n\n\n\nПоменяйте все некрайние значения матрицы M1 (то есть значения на позициях [2,2], [2,3], [3,2] и [3,3]) на число 2.\n\n\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    1    1    1\n[2,]    1    2    2    1\n[3,]    1    2    2    1\n[4,]    1    1    1    1\n\n\n\nВыделите второй и третий столбик из матрицы M1.\n\n\n\n     [,1] [,2]\n[1,]    1    1\n[2,]    2    2\n[3,]    2    2\n[4,]    1    1\n\n\n\nСравните (==) вторую колонку и вторую строчку матрицы M1.\n\n\n\n[1] TRUE TRUE TRUE TRUE\n\n\n\n*Создайте таблицу умножения (9х9) в виде матрицы. Сохраните ее в переменную mult_tab.\n\n\n\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n [1,]    1    2    3    4    5    6    7    8    9\n [2,]    2    4    6    8   10   12   14   16   18\n [3,]    3    6    9   12   15   18   21   24   27\n [4,]    4    8   12   16   20   24   28   32   36\n [5,]    5   10   15   20   25   30   35   40   45\n [6,]    6   12   18   24   30   36   42   48   54\n [7,]    7   14   21   28   35   42   49   56   63\n [8,]    8   16   24   32   40   48   56   64   72\n [9,]    9   18   27   36   45   54   63   72   81\n\n\n\n*Из матрицы mult_tab выделите подматрицу, включающую в себя только строчки с 6 по 8 и столбцы с 3 по 7.\n\n\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   18   24   30   36   42\n[2,]   21   28   35   42   49\n[3,]   24   32   40   48   56\n\n\n\n*Создайте матрицу с логическими значениями, где TRUE, если в этом месте в таблице умножения (mult_tab) двузначное число и FALSE, если однозначное.\n\n\nМатрица - это почти вектор. К нему можно обращаться с единственным индексом.\n\n\n\n       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9]\n [1,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [2,] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n [3,] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [4,] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [5,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [6,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [7,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [8,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [9,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\n\n*Создайте матрицу mult_tab2, в которой все значения tab меньше 10 заменены на 0.\n\n\n\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n [1,]    0    0    0    0    0    0    0    0    0\n [2,]    0    0    0    0   10   12   14   16   18\n [3,]    0    0    0   12   15   18   21   24   27\n [4,]    0    0   12   16   20   24   28   32   36\n [5,]    0   10   15   20   25   30   35   40   45\n [6,]    0   12   18   24   30   36   42   48   54\n [7,]    0   14   21   28   35   42   49   56   63\n [8,]    0   16   24   32   40   48   56   64   72\n [9,]    0   18   27   36   45   54   63   72   81"
  },
  {
    "objectID": "910-tasks.html#task_list",
    "href": "910-tasks.html#task_list",
    "title": "24  Задания",
    "section": "24.8 Списки",
    "text": "24.8 Списки\nДан список list1:\n\nlist1 = list(numbers = 1:5, letters = letters, logic = TRUE)\nlist1\n\n$numbers\n[1] 1 2 3 4 5\n\n$letters\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$logic\n[1] TRUE\n\n\n\nНайдите первый элемент списка list1. Ответ должен быть списком длиной один.\n\n\n\n$numbers\n[1] 1 2 3 4 5\n\n\n\nТеперь найдите содержание первого элемента списка list1 двумя разными способами. Ответ должен быть вектором.\n\n\n\n[1] 1 2 3 4 5\n\n\n[1] 1 2 3 4 5\n\n\n\nТеперь возьмите первый элемент содержания первого элемента списка list1. Ответ должен быть вектором.\n\n\n\n[1] 1\n\n\n\nСоздайте список list2, содержащий в себе два списка list1. Один из них будет иметь имя pupa, а другой – lupa.\n\n\n\n$pupa\n$pupa$numbers\n[1] 1 2 3 4 5\n\n$pupa$letters\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$pupa$logic\n[1] TRUE\n\n\n$lupa\n$lupa$numbers\n[1] 1 2 3 4 5\n\n$lupa$letters\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$lupa$logic\n[1] TRUE\n\n\n\n*Извлеките первый элемент списка list2, из него – второй полэлемент, а из него – третье значение.\n\n\n\n[1] \"c\""
  },
  {
    "objectID": "910-tasks.html#task_df",
    "href": "910-tasks.html#task_df",
    "title": "24  Задания",
    "section": "24.9 Датафрейм",
    "text": "24.9 Датафрейм\n\nЗапустите команду data(mtcars) чтобы загрузить встроенный датафрейм с информацией про автомобили. Каждая строчка датафрейма - модель автомобиля, каждая колонка - отдельная характеристика. Подробнее см. ?mtcars.\n\n\ndata(mtcars)\nmtcars\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n\n\nИзучите структуру датафрейма mtcars с помощью функции str().\n\n\n\n'data.frame':   32 obs. of  11 variables:\n $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...\n $ disp: num  160 160 108 258 360 ...\n $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...\n $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\n $ qsec: num  16.5 17 18.6 19.4 17 ...\n $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...\n $ am  : num  1 1 1 0 0 0 0 0 0 0 ...\n $ gear: num  4 4 4 3 3 3 3 4 4 4 ...\n $ carb: num  4 4 1 1 2 1 4 2 2 4 ...\n\n\n\nНайдите значение третьей строчки четвертого столбца датафрейма mtcars.\n\n\n\n[1] 93\n\n\n\nИзвлеките первые шесть строчек и первые шесть столбцов датафрейма mtcars.\n\n\n\n                   mpg cyl disp  hp drat    wt\nMazda RX4         21.0   6  160 110 3.90 2.620\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875\nDatsun 710        22.8   4  108  93 3.85 2.320\nHornet 4 Drive    21.4   6  258 110 3.08 3.215\nHornet Sportabout 18.7   8  360 175 3.15 3.440\nValiant           18.1   6  225 105 2.76 3.460\n\n\n\nИзвлеките колонку wt датафрейма mtcars - массу автомобиля в тысячах фунтов.\n\n\n\n [1] 2.620 2.875 2.320 3.215 3.440 3.460 3.570 3.190 3.150 3.440 3.440 4.070\n[13] 3.730 3.780 5.250 5.424 5.345 2.200 1.615 1.835 2.465 3.520 3.435 3.840\n[25] 3.845 1.935 2.140 1.513 3.170 2.770 3.570 2.780\n\n\n\nИзвлеките колонки из mtcars в следующем порядке: hp, mpg, cyl.\n\n\n\n                     hp  mpg cyl\nMazda RX4           110 21.0   6\nMazda RX4 Wag       110 21.0   6\nDatsun 710           93 22.8   4\nHornet 4 Drive      110 21.4   6\nHornet Sportabout   175 18.7   8\nValiant             105 18.1   6\nDuster 360          245 14.3   8\nMerc 240D            62 24.4   4\nMerc 230             95 22.8   4\nMerc 280            123 19.2   6\nMerc 280C           123 17.8   6\nMerc 450SE          180 16.4   8\nMerc 450SL          180 17.3   8\nMerc 450SLC         180 15.2   8\nCadillac Fleetwood  205 10.4   8\nLincoln Continental 215 10.4   8\nChrysler Imperial   230 14.7   8\nFiat 128             66 32.4   4\nHonda Civic          52 30.4   4\nToyota Corolla       65 33.9   4\nToyota Corona        97 21.5   4\nDodge Challenger    150 15.5   8\nAMC Javelin         150 15.2   8\nCamaro Z28          245 13.3   8\nPontiac Firebird    175 19.2   8\nFiat X1-9            66 27.3   4\nPorsche 914-2        91 26.0   4\nLotus Europa        113 30.4   4\nFord Pantera L      264 15.8   8\nFerrari Dino        175 19.7   6\nMaserati Bora       335 15.0   8\nVolvo 142E          109 21.4   4\n\n\n\nПосчитайте количество автомобилей с 4 цилиндрами (cyl) в датафрейме mtcars.\n\n\n\n[1] 11\n\n\n\nПосчитайте долю автомобилей с 4 цилиндрами (cyl) в датафрейме mtcars.\n\n\n\n[1] 0.34375\n\n\n\nНайдите все автомобили мощностью не менее 100 лошадиных сил (hp) в датафрейме mtcars.\n\n\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n\n\nНайдите все автомобили мощностью не менее 100 лошадиных сил (hp) и 4 цилиндрами (cyl) в датафрейме mtcars.\n\n\n\n              mpg cyl  disp  hp drat    wt qsec vs am gear carb\nLotus Europa 30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\nVolvo 142E   21.4   4 121.0 109 4.11 2.780 18.6  1  1    4    2\n\n\n\nПосчитайте максимальную массу (wt) автомобиля в выборке, воспользовавшись функцией max():\n\n\n\n[1] 5.424\n\n\n\nПосчитайте минимальную массу (wt) автомобиля в выборке, воспользовавшись функцией min():\n\n\n\n[1] 1.513\n\n\n\nНайдите строчку датафрейма mtcars с самым легким автомобилем.\n\n\n\n              mpg cyl disp  hp drat    wt qsec vs am gear carb\nLotus Europa 30.4   4 95.1 113 3.77 1.513 16.9  1  1    5    2\n\n\n\nИзвлеките строчки датафрейма mtcars с автомобилями, масса которых ниже средней массы.\n\n\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L 15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino   19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n\n\nМасса автомобиля указана в тысячах фунтов. Создайте колонку wt_kg с массой автомобиля в килограммах. Результат округлите до целых значений с помощью функции round().\n\n\n1 фунт = 0.45359237 кг.\n\n\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb wt_kg\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4  1188\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4  1304\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1  1052\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1  1458\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2  1560\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1  1569\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4  1619\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2  1447\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2  1429\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4  1560\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4  1560\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3  1846\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3  1692\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3  1715\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4  2381\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4  2460\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4  2424\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1   998\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2   733\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1   832\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1  1118\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2  1597\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2  1558\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4  1742\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2  1744\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1   878\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2   971\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2   686\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4  1438\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6  1256\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8  1619\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2  1261"
  },
  {
    "objectID": "910-tasks.html#task_if",
    "href": "910-tasks.html#task_if",
    "title": "24  Задания",
    "section": "24.10 Условные конструкции",
    "text": "24.10 Условные конструкции\n\nСоздайте вектор vec5, скопировав следующий код:\n\n\nvec5 <- c(5, 20, 30, 0, 2, 9)\n\n\nСоздайте новый строковый вектор, где на месте чисел больше 10 в vec5 будет стоять “большое число”, а на месте остальных чисел – “маленькое число”.\n\n\n\n[1] \"маленькое число\" \"большое число\"   \"большое число\"   \"маленькое число\"\n[5] \"маленькое число\" \"маленькое число\"\n\n\n\nЗагрузите файл heroes_information.csv в переменную heroes.\n\n\nheroes <- read.csv(\"data/heroes_information.csv\", \n                   stringsAsFactors = FALSE,\n                   na.strings = c(\"-\", \"-99\"))\n\n\nСоздайте новою колонку hair в heroes, в которой будет значение \"Bold\" для тех супергероев, у которых в колонке Hair.color стоит \"No Hair\", и значение \"Hairy\" во всех остальных случаях.\n\n\n\n  X          name Gender Eye.color              Race Hair.color Height\n1 0        A-Bomb   Male    yellow             Human    No Hair    203\n2 1    Abe Sapien   Male      blue     Icthyo Sapien    No Hair    191\n3 2      Abin Sur   Male      blue           Ungaran    No Hair    185\n4 3   Abomination   Male     green Human / Radiation    No Hair    203\n5 4       Abraxas   Male      blue     Cosmic Entity      Black     NA\n6 5 Absorbing Man   Male      blue             Human    No Hair    193\n          Publisher Skin.color Alignment Weight  hair\n1     Marvel Comics       <NA>      good    441  Bold\n2 Dark Horse Comics       blue      good     65  Bold\n3         DC Comics        red      good     90  Bold\n4     Marvel Comics       <NA>       bad    441  Bold\n5     Marvel Comics       <NA>       bad     NA Hairy\n6     Marvel Comics       <NA>       bad    122  Bold\n\n\n\nСоздайте новою колонку tall в heroes, в которой будет значение \"tall\" для тех супергероев, у которых в колонке Height стоит число больше 190, значение \"short\" для тех супергероев, у которых в колонке Height стоит число меньше 170, и значение \"middle\" во всех остальных случаях."
  },
  {
    "objectID": "910-tasks.html#task_function",
    "href": "910-tasks.html#task_function",
    "title": "24  Задания",
    "section": "24.11 Создание функций",
    "text": "24.11 Создание функций\n\nСоздайте функцию plus_one(), которая принимает число и возвращает это же число + 1.\n\n\n\n\n\nПроверьте функцию plus_one() на числе 41.\n\n\nplus_one(41)\n\n[1] 42\n\n\n\nСоздайте функцию circle_area(), которая вычисляет площадь круга по радиусу согласно формуле \\(\\pi r^2\\).\n\n\n\n\n\nПосчитайте площадь круга с радиусом 5.\n\n\n\n[1] 78.53982\n\n\n\nСоздайте функцию cels2fahr(), которая будет превращать градусы по Цельсию в градусы по Фаренгейту.\n\n\n\n\n\nПроверьте на значениях -100, -40 и 0, что функция cels2fahr() работает корректно.\n\n\ncels2fahr(c(-100, -40, 0))\n\n[1] -148  -40   32\n\n\n\nНапишите функцию highlight(), которая принимает на входе строковый вектор, а возвращает тот же вектор, но дополненный значением \"***\" в начале и конце вектора. Лучше всего это рассмотреть на примере:\n\n\n\n\n\nhighlight(c(\"Я\", \"Бэтмен!\"))\n\n[1] \"***\"     \"Я\"       \"Бэтмен!\" \"***\"    \n\n\n\nТеперь сделайте функцию highlight более гибкой. Добавьте в нее параметр wrapper =, который по умолчанию равен \"***\". Значение параметра wrapper = и будет вставлено в начало и конец вектора.\n\n\n\n\n\nПроверьте написанную функцию на векторе c(\"Я\", \"Бэтмен!\").\n\n\nhighlight(c(\"Я\", \"Бэтмен!\")) \n\n[1] \"***\"     \"Я\"       \"Бэтмен!\" \"***\"    \n\nhighlight(c(\"Я\", \"Бэтмен!\"), wrapper = \"__\") \n\n[1] \"__\"      \"Я\"       \"Бэтмен!\" \"__\"     \n\n\n\nСоздайте функцию na_n(), которая будет возвращать количество NA в векторе.\n\n\n\n\n\nПроверьте функцию na_n() на векторе:\n\n\nna_n(c(NA, 3:5, NA, 2, NA))\n\n[1] 3\n\n\n\nНапишите функцию factors(), которая будет возвращать все делители числа в виде числового вектора.\n\n\nЗдесь может понадобиться оператор для получения остатка от деления: %%.\n\n\n\n\n\nПроверьте функцию factors() на простых и сложных числах:\n\n\nfactors(3)\n\n[1] 1 3\n\nfactors(161)\n\n[1]   1   7  23 161\n\nfactors(1984)\n\n [1]    1    2    4    8   16   31   32   62   64  124  248  496  992 1984\n\n\n\n*Напишите функцию is_prime(), которая проверяет, является ли число простым.\n\n\nЗдесь может пригодиться функция any() - она возвращает TRUE, если в векторе есть хотя бы один TRUE.\n\n\n\n\n\nПроверьте какие года были для нас простыми, а какие нет:\n\n\nis_prime(2017)\n\n[1] TRUE\n\nis_prime(2019)\n\n[1] FALSE\n\n2019/3 #2019 делится на 3 без остатка\n\n[1] 673\n\nis_prime(2020)\n\n[1] FALSE\n\nis_prime(2021)\n\n[1] FALSE\n\n\n\n*Создайте функцию monotonic(), которая возвращает TRUE, если значения в векторе не убывают (то есть каждое следующее - больше или равно предыдущему) или не возврастают.\n\n\nПолезная функция для этого – diff() – возвращает разницу соседних значений.\n\n\n\n\n\nmonotonic(1:7)\n\n[1] TRUE\n\nmonotonic(c(1:5,5:1))\n\n[1] FALSE\n\nmonotonic(6:-1)\n\n[1] TRUE\n\nmonotonic(c(1:5, rep(5, 10), 5:10))\n\n[1] TRUE\n\n\nБинарные операторы типа + или %in% тоже представляют собой функции. Более того, мы можем создавать свои бинарные операторы! В этом нет особой сложности – нужно все так же создавать функцию (для двух переменных), главное окружать их % и название обрамлять обратными штрихами `. Например, можно сделать свой бинарный оператор %notin%, который будет выдавать TRUE, если значения слева нет в векторе справа:\n\n`%notin%` <- function(x, y) ! (x %in% y)\n1:10 %notin% c(1, 4, 5)\n\n [1] FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\n\n*Создайте бинарный оператор %without%, который будет возвращать все значения вектора слева без значений вектора справа.\n\n\n\n\n\nc(\"а\", \"и\", \"б\", \"сидели\", \"на\", \"трубе\") %without% c(\"а\", \"б\")\n\n[1] \"и\"      \"сидели\" \"на\"     \"трубе\" \n\n\n\n*Создайте бинарный оператор %between%, который будет возвращать TRUE, если значение в векторе слева накходится в диапазоне значений вектора справа:\n\n\n\n\n\n1:10 %between% c(1, 4, 5)\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE"
  },
  {
    "objectID": "910-tasks.html#task_sanity",
    "href": "910-tasks.html#task_sanity",
    "title": "24  Задания",
    "section": "24.12 Проверка на адекватность",
    "text": "24.12 Проверка на адекватность\n\nСоздайте функцию trim(), которая будет возвращать вектор без первого и последнего значения (вне зависимости от типа данных).\n\n\n\n\n\nПроверьте, что функция trim() работает корректно:\n\n\ntrim(1:7)\n\n[1] 2 3 4 5 6\n\ntrim(letters)\n\n [1] \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\"\n[20] \"u\" \"v\" \"w\" \"x\" \"y\"\n\n\n\nТеперь добавьте в функцию trim() параметр n = со значением по умолчанию 1. Этот параметр будет обозначать сколько значений нужно отрезать слева и справа от вектора.\n\n\n\n\n\nПроверьте полученную функцию:\n\n\ntrim(letters)\n\n [1] \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\"\n[20] \"u\" \"v\" \"w\" \"x\" \"y\"\n\ntrim(letters, n = 2)\n\n [1] \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" \"u\"\n[20] \"v\" \"w\" \"x\"\n\n\n\nСделайте так, чтобы функция trim() работала корректно с n = 0, т.е. функция возвращала бы исходный вектор без изменений.\n\n\n\n\n\ntrim(letters, n = 0)\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\n\n*Теперь добавьте проверку на адекватность входных данных: функция trim() должна выдавать ошибку, если n = меньше нуля или если n = слишком большой и отрезает все значения вектора:\n\n\n\n\n\n*Проверьте полученную функцию trim():\n\n\ntrim(1:6, 3)\n\nError in trim(1:6, 3): n слишком большой!\n\ntrim(1:6, -1)\n\nError in trim(1:6, -1): n не может быть меньше нуля!"
  },
  {
    "objectID": "910-tasks.html#task_apply",
    "href": "910-tasks.html#task_apply",
    "title": "24  Задания",
    "section": "24.13 Семейство функций apply()",
    "text": "24.13 Семейство функций apply()\n\nСоздайте матрицу M2:\n\n\nM2 <- matrix(c(20:11, 11:20), nrow = 5)\nM2\n\n     [,1] [,2] [,3] [,4]\n[1,]   20   15   11   16\n[2,]   19   14   12   17\n[3,]   18   13   13   18\n[4,]   17   12   14   19\n[5,]   16   11   15   20\n\n\n\nПосчитайте максимальное значение матрицы M2 по каждой строчке.\n\n\n\n[1] 20 19 18 19 20\n\n\n\nПосчитайте максимальное значение матрицы M2 по каждому столбцу.\n\n\n\n[1] 20 15 15 20\n\n\n\nПосчитайте среднее значение матрицы M2 по каждой строке.\n\n\n\n[1] 15.5 15.5 15.5 15.5 15.5\n\n\n\nПосчитайте среднее значение матрицы M2 по каждому столбцу.\n\n\n\n[1] 18 13 13 18\n\n\n\nСоздайте список list3:\n\n\nlist3 <- list(\n  a = 1:5,\n  b = 0:20,\n  c = 4:24,\n  d = 6:3,\n  e = 6:25\n  )\n\n\nНайдите максимальное значение каждого вектора списка list3.\n\n\n\n a  b  c  d  e \n 5 20 24  6 25 \n\n\n\nПосчитайте сумму каждого вектора списка list3.\n\n\n\n  a   b   c   d   e \n 15 210 294  18 310 \n\n\n\nПосчитайте длину каждого вектора списка list3.\n\n\n\n a  b  c  d  e \n 5 21 21  4 20 \n\n\n\nНапишите функцию max_item(), которая будет принимать на входе список, а возвращать - (первый) самый длинный его элемент.\n\n\nДля этого вам может понадобиться функция which.max(), которая возвращает индекс максимального значения (первого, если их несколько).\n\n\n\n\n\nПроверьте функцию max_item() на списке list3.\n\n\nmax_item(list3)\n\n [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20\n\n\n\nТеперь мы сделаем сложный список list4:\n\n\nlist4 <- list(1:3, 3:40, list3)\n\n\nПосчитайте длину каждого вектора в списке, в т.ч. для списка внутри. Результат должен быть списком с такой же структорой, как и изначальный список list4.\n\n\nДля этого может понадобиться функция rapply(): recursive lapply\n\n\n\n[[1]]\n[1] 3\n\n[[2]]\n[1] 38\n\n[[3]]\n[[3]]$a\n[1] 5\n\n[[3]]$b\n[1] 21\n\n[[3]]$c\n[1] 21\n\n[[3]]$d\n[1] 4\n\n[[3]]$e\n[1] 20\n\n\n\n*Загрузите набор данных heroes и посчитайте, сколько NA в каждом из столбцов.\n\n\nДля этого удобно использовать ранее написанную функцию na_n().\n\n\n\n         X       name     Gender  Eye.color       Race Hair.color     Height \n         0          0         29        172        304        172        217 \n Publisher Skin.color  Alignment     Weight       hair       tall \n         0        662          7        239        172        217 \n\n\n\n*Используя ранее написанную функцию is_prime(), напишите функцию prime_numbers(), которая будет возвращать все простые числа до выбранного числа.\n\n\n\n\n\nprime_numbers(200)\n\n [1]   3   5   7  11  13  17  19  23  29  31  37  41  43  47  53  59  61  67  71\n[20]  73  79  83  89  97 101 103 107 109 113 127 131 137 139 149 151 157 163 167\n[39] 173 179 181 191 193 197 199"
  },
  {
    "objectID": "910-tasks.html#task_pipe",
    "href": "910-tasks.html#task_pipe",
    "title": "24  Задания",
    "section": "24.14 magrittr::%>%",
    "text": "24.14 magrittr::%>%\n\n\n\n\nПерепишите следующие выражения, используя %>%:\n\n\nsqrt(sum(1:10))\n\n[1] 7.416198\n\n\n\n\n[1] 7.416198\n\n\n\nabs(min(-5:5))\n\n[1] 5\n\n\n\n\n[1] 5\n\n\n\nc(\"Корень из\", 2, \"равен\", sqrt(2))\n\n[1] \"Корень из\"       \"2\"               \"равен\"           \"1.4142135623731\"\n\n\n\n\n[1] \"Корень из\"       \"2\"               \"равен\"           \"1.4142135623731\""
  },
  {
    "objectID": "910-tasks.html#task_select",
    "href": "910-tasks.html#task_select",
    "title": "24  Задания",
    "section": "24.15 Выбор столбцов: dplyr::select()",
    "text": "24.15 Выбор столбцов: dplyr::select()\nДля выполнения следующих заданий нам понадобятся датасеты heroes и powers, которые можно загрузить, используя следующие команды:\n\nlibrary(tidyverse)\nheroes <- read_csv(\"https://raw.githubusercontent.com/Pozdniakov/tidy_stats/master/data/heroes_information.csv\",\n                   na = c(\"-\", \"-99\"))\npowers <- read_csv(\"https://raw.githubusercontent.com/Pozdniakov/tidy_stats/master/data/super_hero_powers.csv\")\n\n\nВыберете первые 4 столбца в powers.\n\n\n\n# A tibble: 667 × 4\n   hero_names    Agility `Accelerated Healing` `Lantern Power Ring`\n   <chr>         <lgl>   <lgl>                 <lgl>               \n 1 3-D Man       TRUE    FALSE                 FALSE               \n 2 A-Bomb        FALSE   TRUE                  FALSE               \n 3 Abe Sapien    TRUE    TRUE                  FALSE               \n 4 Abin Sur      FALSE   FALSE                 TRUE                \n 5 Abomination   FALSE   TRUE                  FALSE               \n 6 Abraxas       FALSE   FALSE                 FALSE               \n 7 Absorbing Man FALSE   FALSE                 FALSE               \n 8 Adam Monroe   FALSE   TRUE                  FALSE               \n 9 Adam Strange  FALSE   FALSE                 FALSE               \n10 Agent Bob     FALSE   FALSE                 FALSE               \n# … with 657 more rows\n\n\n\nВыберите все столбцы от Reflexes до Empathy в тиббле powers:\n\n\n\n# A tibble: 667 × 7\n   Reflexes Invulnerability `Energy Constructs` `Force Fields` `Self-Sustenance`\n   <lgl>    <lgl>           <lgl>               <lgl>          <lgl>            \n 1 FALSE    FALSE           FALSE               FALSE          FALSE            \n 2 FALSE    FALSE           FALSE               FALSE          TRUE             \n 3 TRUE     FALSE           FALSE               FALSE          FALSE            \n 4 FALSE    FALSE           FALSE               FALSE          FALSE            \n 5 FALSE    TRUE            FALSE               FALSE          FALSE            \n 6 FALSE    TRUE            FALSE               FALSE          FALSE            \n 7 FALSE    TRUE            FALSE               FALSE          FALSE            \n 8 FALSE    FALSE           FALSE               FALSE          FALSE            \n 9 FALSE    FALSE           FALSE               FALSE          FALSE            \n10 FALSE    FALSE           FALSE               FALSE          FALSE            \n# … with 657 more rows, and 2 more variables: `Anti-Gravity` <lgl>,\n#   Empathy <lgl>\n\n\n\nВыберите все столбцы тиббла powers кроме первого (hero_names):\n\n\n\n# A tibble: 667 × 167\n   Agility `Accelerated Hea…` `Lantern Power…` `Dimensional A…` `Cold Resistan…`\n   <lgl>   <lgl>              <lgl>            <lgl>            <lgl>           \n 1 TRUE    FALSE              FALSE            FALSE            FALSE           \n 2 FALSE   TRUE               FALSE            FALSE            FALSE           \n 3 TRUE    TRUE               FALSE            FALSE            TRUE            \n 4 FALSE   FALSE              TRUE             FALSE            FALSE           \n 5 FALSE   TRUE               FALSE            FALSE            FALSE           \n 6 FALSE   FALSE              FALSE            TRUE             FALSE           \n 7 FALSE   FALSE              FALSE            FALSE            TRUE            \n 8 FALSE   TRUE               FALSE            FALSE            FALSE           \n 9 FALSE   FALSE              FALSE            FALSE            FALSE           \n10 FALSE   FALSE              FALSE            FALSE            FALSE           \n# … with 657 more rows, and 162 more variables: Durability <lgl>,\n#   Stealth <lgl>, `Energy Absorption` <lgl>, Flight <lgl>,\n#   `Danger Sense` <lgl>, `Underwater breathing` <lgl>, Marksmanship <lgl>,\n#   `Weapons Master` <lgl>, `Power Augmentation` <lgl>,\n#   `Animal Attributes` <lgl>, Longevity <lgl>, Intelligence <lgl>,\n#   `Super Strength` <lgl>, Cryokinesis <lgl>, Telepathy <lgl>,\n#   `Energy Armor` <lgl>, `Energy Blasts` <lgl>, Duplication <lgl>, …"
  },
  {
    "objectID": "910-tasks.html#task_filt",
    "href": "910-tasks.html#task_filt",
    "title": "24  Задания",
    "section": "24.16 Выбор строк: dplyr::slice() и dplyr::filter()",
    "text": "24.16 Выбор строк: dplyr::slice() и dplyr::filter()\n\nВыберите только те строчки, в которых содержится информация о супергероях тяжелее 500 кг.\n\n\n\n# A tibble: 6 × 11\n     X1 name       Gender `Eye color` Race         `Hair color` Height Publisher\n  <dbl> <chr>      <chr>  <chr>       <chr>        <chr>         <dbl> <chr>    \n1   203 Darkseid   Male   red         New God      No Hair       267   DC Comics\n2   283 Giganta    Female green       <NA>         Red            62.5 DC Comics\n3   331 Hulk       Male   green       Human / Rad… Green         244   Marvel C…\n4   373 Juggernaut Male   blue        Human        Red           287   Marvel C…\n5   549 Red Hulk   Male   yellow      Human / Rad… Black         213   Marvel C…\n6   575 Sasquatch  Male   red         <NA>         Orange        305   Marvel C…\n# … with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>\n\n\n\nВыберите только те строчки, в которых содержится информация о женщинах-супергероях тяжелее 500 кг.\n\n\n\n# A tibble: 1 × 11\n     X1 name    Gender `Eye color` Race  `Hair color` Height Publisher\n  <dbl> <chr>   <chr>  <chr>       <chr> <chr>         <dbl> <chr>    \n1   283 Giganta Female green       <NA>  Red            62.5 DC Comics\n# … with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>\n\n\n\nВыберите только те строчки, в которых содержится информация о супергероях человеческой расы (\"Human\") женского пола. Из этих супергероев возьмите первые 5.\n\n\n\n# A tibble: 5 × 11\n     X1 name         Gender `Eye color` Race  `Hair color` Height Publisher    \n  <dbl> <chr>        <chr>  <chr>       <chr> <chr>         <dbl> <chr>        \n1    38 Arachne      Female blue        Human Blond           175 Marvel Comics\n2    63 Batgirl      Female green       Human Red             170 DC Comics    \n3    65 Batgirl IV   Female green       Human Black           165 DC Comics    \n4    72 Batwoman V   Female green       Human Red             178 DC Comics    \n5    96 Black Canary Female blue        Human Blond           165 DC Comics    \n# … with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>"
  },
  {
    "objectID": "910-tasks.html#task_arr",
    "href": "910-tasks.html#task_arr",
    "title": "24  Задания",
    "section": "24.17 Сортировка строк: dplyr::arrange()",
    "text": "24.17 Сортировка строк: dplyr::arrange()\n\nВыберите из тиббла heroes колонки name, Gender, Height и отсортируйте строчки по возрастанию Height.\n\n\n\n# A tibble: 734 × 3\n   name            Gender Height\n   <chr>           <chr>   <dbl>\n 1 Utgard-Loki     Male     15.2\n 2 Bloodwraith     Male     30.5\n 3 King Kong       Male     30.5\n 4 Anti-Monitor    Male     61  \n 5 Giganta         Female   62.5\n 6 Krypto          Male     64  \n 7 Yoda            Male     66  \n 8 Jack-Jack       Male     71  \n 9 Howard the Duck Male     79  \n10 Godzilla        <NA>    108  \n# … with 724 more rows\n\n\n\nВыберите из тиббла heroes колонки name, Gender, Height и отсортируйте строчки по убыванию Height.\n\n\n\n# A tibble: 734 × 3\n   name          Gender Height\n   <chr>         <chr>   <dbl>\n 1 Fin Fang Foom Male     975 \n 2 Galactus      Male     876 \n 3 Groot         Male     701 \n 4 MODOK         Male     366 \n 5 Wolfsbane     Female   366 \n 6 Onslaught     Male     305 \n 7 Sasquatch     Male     305 \n 8 Ymir          Male     305.\n 9 Rey           Female   297 \n10 Juggernaut    Male     287 \n# … with 724 more rows\n\n\n\nВыберите из тиббла heroes колонки name, Gender, Height и отсортируйте строчки сначала по Gender, затем по убыванию Height.\n\n\n\n# A tibble: 734 × 3\n   name      Gender Height\n   <chr>     <chr>   <dbl>\n 1 Wolfsbane Female    366\n 2 Rey       Female    297\n 3 Bloodaxe  Female    218\n 4 Thundra   Female    218\n 5 Hela      Female    213\n 6 Frenzy    Female    211\n 7 She-Hulk  Female    201\n 8 Ardina    Female    193\n 9 Starfire  Female    193\n10 Valkyrie  Female    191\n# … with 724 more rows"
  },
  {
    "objectID": "910-tasks.html#task_dist",
    "href": "910-tasks.html#task_dist",
    "title": "24  Задания",
    "section": "24.18 Уникальные значения: dplyr::distinct()",
    "text": "24.18 Уникальные значения: dplyr::distinct()\n\nИзвлеките уникальные значения столбца Eye color из тиббла heroes.\n\n\n\n# A tibble: 23 × 1\n   `Eye color`\n   <chr>      \n 1 yellow     \n 2 blue       \n 3 green      \n 4 brown      \n 5 <NA>       \n 6 red        \n 7 violet     \n 8 white      \n 9 purple     \n10 black      \n# … with 13 more rows\n\n\n\nИзвлеките уникальные значения столбца Hair color из тиббла heroes.\n\n\n\n# A tibble: 30 × 1\n   `Hair color`\n   <chr>       \n 1 No Hair     \n 2 Black       \n 3 Blond       \n 4 Brown       \n 5 <NA>        \n 6 White       \n 7 Purple      \n 8 Orange      \n 9 Pink        \n10 Red         \n# … with 20 more rows"
  },
  {
    "objectID": "910-tasks.html#task_mutate",
    "href": "910-tasks.html#task_mutate",
    "title": "24  Задания",
    "section": "24.19 Создание колонок: dplyr::mutate() и dplyr::transmute()",
    "text": "24.19 Создание колонок: dplyr::mutate() и dplyr::transmute()\n\nСоздайте колонку height_m с ростом супергероев в метрах, затем выберите только колонки name и height_m.\n\n\n\n# A tibble: 734 × 2\n   name          height_m\n   <chr>            <dbl>\n 1 A-Bomb            2.03\n 2 Abe Sapien        1.91\n 3 Abin Sur          1.85\n 4 Abomination       2.03\n 5 Abraxas          NA   \n 6 Absorbing Man     1.93\n 7 Adam Monroe      NA   \n 8 Adam Strange      1.85\n 9 Agent 13          1.73\n10 Agent Bob         1.78\n# … with 724 more rows\n\n\n\nСоздайте новою колонку hair в heroes, в которой будет значение \"Bold\" для тех супергероев, у которых в колонке Hair.color стоит \"No Hair\", и значение \"Hairy\" во всех остальных случаях. Затем выберите только колонки name, Hair color, hair.\n\n\n\n# A tibble: 734 × 3\n   name          `Hair color` hair \n   <chr>         <chr>        <chr>\n 1 A-Bomb        No Hair      Bold \n 2 Abe Sapien    No Hair      Bold \n 3 Abin Sur      No Hair      Bold \n 4 Abomination   No Hair      Bold \n 5 Abraxas       Black        Hairy\n 6 Absorbing Man No Hair      Bold \n 7 Adam Monroe   Blond        Hairy\n 8 Adam Strange  Blond        Hairy\n 9 Agent 13      Blond        Hairy\n10 Agent Bob     Brown        Hairy\n# … with 724 more rows"
  },
  {
    "objectID": "910-tasks.html#task_group_by",
    "href": "910-tasks.html#task_group_by",
    "title": "24  Задания",
    "section": "24.20 Агрегация: dplyr::group_by() %>% summarise()",
    "text": "24.20 Агрегация: dplyr::group_by() %>% summarise()\n\nПосчитайте количество супергероев по расам и отсортируйте по убыванию. Извлеките первые 5 строк.\n\n\n\n# A tibble: 5 × 2\n  Race              n\n  <chr>         <int>\n1 <NA>            304\n2 Human           208\n3 Mutant           63\n4 God / Eternal    14\n5 Cyborg           11\n\n\n\nПосчитайте средний пост по полу.\n\n\n\n# A tibble: 3 × 2\n  Gender height_mean\n  <chr>        <dbl>\n1 Female        175.\n2 Male          192.\n3 <NA>          177."
  },
  {
    "objectID": "910-tasks.html#task_join",
    "href": "910-tasks.html#task_join",
    "title": "24  Задания",
    "section": "24.21 Соединение датафреймов: *_join",
    "text": "24.21 Соединение датафреймов: *_join\n\nСоздайте тиббл web_creators, в котором будут супергерои, которые могут плести паутину, т.е. у них стоит TRUE в колонке Web Creation в тиббле powers.\n\n\n\n# A tibble: 16 × 12\n      X1 name             Gender `Eye color` Race  `Hair color` Height Publisher\n   <dbl> <chr>            <chr>  <chr>       <chr> <chr>         <dbl> <chr>    \n 1    33 Anti-Venom       Male   blue        Symb… Blond           229 Marvel C…\n 2    38 Arachne          Female blue        Human Blond           175 Marvel C…\n 3   161 Carnage          Male   green       Symb… Red             185 Marvel C…\n 4   335 Hybrid           Male   brown       Symb… Black           175 Marvel C…\n 5   479 Mysterio         Male   brown       Human No Hair         180 Marvel C…\n 6   580 Scarlet Spider … Male   brown       Clone Brown           193 Marvel C…\n 7   597 Silk             Female brown       Human Black            NA Marvel C…\n 8   620 Spider-Girl      Female blue        Human Brown           170 Marvel C…\n 9   621 Spider-Gwen      Female blue        Human Blond           165 Marvel C…\n10   622 Spider-Man       Male   hazel       Human Brown           178 Marvel C…\n11   623 Spider-Man       <NA>   red         Human Brown           178 Marvel C…\n12   624 Spider-Man       Male   brown       Human Black           157 Marvel C…\n13   673 Toxin            Male   blue        Symb… Brown           188 Marvel C…\n14   674 Toxin            Male   black       Symb… Blond           191 Marvel C…\n15   689 Venom            Male   blue        Symb… Strawberry …    191 Marvel C…\n16   692 Venompool        Male   <NA>        Symb… <NA>            226 Marvel C…\n# … with 4 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>,\n#   `Web Creation` <lgl>\n\n\n\nНайдите всех супергероев, которые присутствуют в heroes, но отсутствуют в powers. Ответом должен быть строковый вектор с именами супергероев.\n\n\n\n [1] \"Agent 13\"          \"Alfred Pennyworth\" \"Arsenal\"          \n [4] \"Batgirl III\"       \"Batgirl V\"         \"Beetle\"           \n [7] \"Black Goliath\"     \"Black Widow II\"    \"Blaquesmith\"      \n[10] \"Bolt\"              \"Boomer\"            \"Box\"              \n[13] \"Box III\"           \"Captain Mar-vell\"  \"Cat II\"           \n[16] \"Cecilia Reyes\"     \"Clea\"              \"Clock King\"       \n[19] \"Colin Wagner\"      \"Colossal Boy\"      \"Corsair\"          \n[22] \"Cypher\"            \"Danny Cooper\"      \"Darkside\"         \n[25] \"ERG-1\"             \"Fixer\"             \"Franklin Storm\"   \n[28] \"Giant-Man\"         \"Giant-Man II\"      \"Goliath\"          \n[31] \"Goliath\"           \"Goliath\"           \"Guardian\"         \n[34] \"Hawkwoman\"         \"Hawkwoman II\"      \"Hawkwoman III\"    \n[37] \"Howard the Duck\"   \"Jack Bauer\"        \"Jesse Quick\"      \n[40] \"Jessica Sanders\"   \"Jigsaw\"            \"Jyn Erso\"         \n[43] \"Kid Flash II\"      \"Kingpin\"           \"Meteorite\"        \n[46] \"Mister Zsasz\"      \"Mogo\"              \"Moloch\"           \n[49] \"Morph\"             \"Nite Owl II\"       \"Omega Red\"        \n[52] \"Paul Blart\"        \"Penance\"           \"Penance I\"        \n[55] \"Plastic Lad\"       \"Power Man\"         \"Renata Soliz\"     \n[58] \"Ronin\"             \"Shrinking Violet\"  \"Snake-Eyes\"       \n[61] \"Spider-Carnage\"    \"Spider-Woman II\"   \"Stacy X\"          \n[64] \"Thunderbird II\"    \"Two-Face\"          \"Vagabond\"         \n[67] \"Vision II\"         \"Vulcan\"            \"Warbird\"          \n[70] \"White Queen\"       \"Wiz Kid\"           \"Wondra\"           \n[73] \"Wyatt Wingfoot\"    \"Yellow Claw\"      \n\n\n\nНайдите всех супергероев, которые присутствуют в powers, но отсутствуют в heroes. Ответом должен быть строковый вектор с именами супергероев.\n\n\n\n [1] \"3-D Man\"           \"Bananaman\"         \"Bizarro-Girl\"     \n [4] \"Black Vulcan\"      \"Blue Streak\"       \"Bradley\"          \n [7] \"Clayface\"          \"Concrete\"          \"Dementor\"         \n[10] \"Doctor Poison\"     \"Fire\"              \"Hellgramite\"      \n[13] \"Lara Croft\"        \"Little Epic\"       \"Lord Voldemort\"   \n[16] \"Orion\"             \"Peek-a-Boo\"        \"Queen Hippolyta\"  \n[19] \"Reactron\"          \"SHDB\"              \"Stretch Armstrong\"\n[22] \"TEST\"              \"Tommy Clarke\"      \"Tyrant\""
  },
  {
    "objectID": "910-tasks.html#task_pivot",
    "href": "910-tasks.html#task_pivot",
    "title": "24  Задания",
    "section": "24.22 Tidy data",
    "text": "24.22 Tidy data\n\nДля начала создайте тиббл heroes_weight, скопировав код:\n\n\nheroes_weight <- heroes %>%\n  filter(Publisher %in% c(\"DC Comics\", \"Marvel Comics\")) %>%\n  group_by(Gender, Publisher) %>%\n  summarise(weight_mean = mean(Weight, na.rm = TRUE)) %>%\n  drop_na()\nheroes_weight \n\n# A tibble: 4 × 3\n# Groups:   Gender [2]\n  Gender Publisher     weight_mean\n  <chr>  <chr>               <dbl>\n1 Female DC Comics            76.8\n2 Female Marvel Comics        80.1\n3 Male   DC Comics           113. \n4 Male   Marvel Comics       134. \n\n\n\nФункция drop_na() позволяет выбросить все строчки, в которых встречается NA.\n\n\nПревратите тиббл heroes_weight в широкий тиббл:\n\n\n\n# A tibble: 2 × 3\n# Groups:   Gender [2]\n  Gender `DC Comics` `Marvel Comics`\n  <chr>        <dbl>           <dbl>\n1 Female        76.8            80.1\n2 Male         113.            134. \n\n\n\nЗатем превратите его обратно в длинный тиббл:\n\n\n\n# A tibble: 4 × 3\n# Groups:   Gender [2]\n  Gender Publisher     weight_mean\n  <chr>  <chr>               <dbl>\n1 Female DC Comics            76.8\n2 Female Marvel Comics        80.1\n3 Male   DC Comics           113. \n4 Male   Marvel Comics       134. \n\n\n\nСделайте powers длинным тибблом с тремя колонками: hero_names, power (названгие суперсилы) и has (наличие суперсилы у данного супергероя).\n\n\n\n# A tibble: 111,389 × 3\n   hero_names power                 has  \n   <chr>      <chr>                 <lgl>\n 1 3-D Man    Agility               TRUE \n 2 3-D Man    Accelerated Healing   FALSE\n 3 3-D Man    Lantern Power Ring    FALSE\n 4 3-D Man    Dimensional Awareness FALSE\n 5 3-D Man    Cold Resistance       FALSE\n 6 3-D Man    Durability            FALSE\n 7 3-D Man    Stealth               FALSE\n 8 3-D Man    Energy Absorption     FALSE\n 9 3-D Man    Flight                FALSE\n10 3-D Man    Danger Sense          FALSE\n# … with 111,379 more rows\n\n\n\nСделайте тиббл powers обратно широким, но с новой структурой: каждая строчка означает суперсилу, а каждая колонка - супергероя (за исключением первой колонки - названия суперсилы).\n\n\n\n# A tibble: 167 × 668\n   power          `3-D Man` `A-Bomb` `Abe Sapien` `Abin Sur` Abomination Abraxas\n   <chr>          <lgl>     <lgl>    <lgl>        <lgl>      <lgl>       <lgl>  \n 1 Agility        TRUE      FALSE    TRUE         FALSE      FALSE       FALSE  \n 2 Accelerated H… FALSE     TRUE     TRUE         FALSE      TRUE        FALSE  \n 3 Lantern Power… FALSE     FALSE    FALSE        TRUE       FALSE       FALSE  \n 4 Dimensional A… FALSE     FALSE    FALSE        FALSE      FALSE       TRUE   \n 5 Cold Resistan… FALSE     FALSE    TRUE         FALSE      FALSE       FALSE  \n 6 Durability     FALSE     TRUE     TRUE         FALSE      FALSE       FALSE  \n 7 Stealth        FALSE     FALSE    FALSE        FALSE      FALSE       FALSE  \n 8 Energy Absorp… FALSE     FALSE    FALSE        FALSE      FALSE       FALSE  \n 9 Flight         FALSE     FALSE    FALSE        FALSE      FALSE       TRUE   \n10 Danger Sense   FALSE     FALSE    FALSE        FALSE      FALSE       FALSE  \n# … with 157 more rows, and 661 more variables: `Absorbing Man` <lgl>,\n#   `Adam Monroe` <lgl>, `Adam Strange` <lgl>, `Agent Bob` <lgl>,\n#   `Agent Zero` <lgl>, `Air-Walker` <lgl>, Ajax <lgl>, `Alan Scott` <lgl>,\n#   `Alex Mercer` <lgl>, `Alex Woolsly` <lgl>, Alien <lgl>,\n#   `Allan Quatermain` <lgl>, Amazo <lgl>, Ammo <lgl>, `Ando Masahashi` <lgl>,\n#   Angel <lgl>, `Angel Dust` <lgl>, `Angel Salvadore` <lgl>, Angela <lgl>,\n#   `Animal Man` <lgl>, Annihilus <lgl>, `Ant-Man` <lgl>, `Ant-Man II` <lgl>, …"
  },
  {
    "objectID": "910-tasks.html#task_across",
    "href": "910-tasks.html#task_across",
    "title": "24  Задания",
    "section": "24.23 Операции с несколькими колонками: across()",
    "text": "24.23 Операции с несколькими колонками: across()\n\nПосчитайте количество NA в каждой колонке, группируя по полу (Gender).\n\n\n\n# A tibble: 3 × 11\n  Gender    X1  name `Eye color`  Race `Hair color` Height Publisher\n  <chr>  <int> <int>       <int> <int>        <int>  <int>     <int>\n1 Female     0     0          41    98           38     56         0\n2 Male       0     0         121   184          123    147         0\n3 <NA>       0     0          10    22           11     14         0\n# … with 3 more variables: `Skin color` <int>, Alignment <int>, Weight <int>\n\n\n\nПосчитайте количество NA в каждой колонке, которая заканчивается на \"color\", группируя по полу (Gender).\n\n\n\n# A tibble: 3 × 4\n  Gender `Eye color` `Hair color` `Skin color`\n  <chr>        <int>        <int>        <int>\n1 Female          41           38          186\n2 Male           121          123          449\n3 <NA>            10           11           27\n\n\n\nНайдите (первую) самую длинную строчку для каждой колонки с character типом данных, группируя по полу (Gender).\n\n\nДля расчета количества значений в строке есть функция nchar(), для расчета индекса (первого) максимального значения есть функция which.max().\n\n\n\n# A tibble: 3 × 8\n  Gender name    `Eye color` Race  `Hair color` Publisher `Skin color` Alignment\n  <chr>  <chr>   <chr>       <chr> <chr>        <chr>     <chr>        <chr>    \n1 Female Negaso… yellow (wi… Huma… Strawberry … Dark Hor… orange       neutral  \n2 Male   Drax t… yellow / r… Dath… Strawberry … Dark Hor… orange / wh… neutral  \n3 <NA>   Captai… yellow (wi… God … Orange / Wh… Marvel C… grey         neutral  \n\n\n\nСоздайте из тиббла heroes новый тиббл, в котором числовые значения Height и Weight заменены на следующие строковые значения: если у супергероя рост или вес выше среднего по колонке, то \"выше среднего\", если его/ее рост или вес ниже или равен среднему, то \"ниже среднего\".\n\n\n\n# A tibble: 734 × 11\n      X1 name          Gender `Eye color` Race     `Hair color` Height Publisher\n   <dbl> <chr>         <chr>  <chr>       <chr>    <chr>        <chr>  <chr>    \n 1     0 A-Bomb        Male   yellow      Human    No Hair      выше … Marvel C…\n 2     1 Abe Sapien    Male   blue        Icthyo … No Hair      выше … Dark Hor…\n 3     2 Abin Sur      Male   blue        Ungaran  No Hair      ниже … DC Comics\n 4     3 Abomination   Male   green       Human /… No Hair      выше … Marvel C…\n 5     4 Abraxas       Male   blue        Cosmic … Black        <NA>   Marvel C…\n 6     5 Absorbing Man Male   blue        Human    No Hair      выше … Marvel C…\n 7     6 Adam Monroe   Male   blue        <NA>     Blond        <NA>   NBC - He…\n 8     7 Adam Strange  Male   blue        Human    Blond        ниже … DC Comics\n 9     8 Agent 13      Female blue        <NA>     Blond        ниже … Marvel C…\n10     9 Agent Bob     Male   brown       Human    Brown        ниже … Marvel C…\n# … with 724 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <chr>\n\n\n\nСоздайте из тиббла heroes новый тиббл, в котором числовые значения Height и Weight заменены на следующие строковые значения: если у супергероя внутри соответствующей группы по полу рост или вес выше среднего по колонке, то \"выше среднего по X\", если его/ее рост или вес ниже или равен среднему внутри соответствующей группы по полу, то \"ниже среднего по X\" , где X – соответствующий пол (Gender).\n\n\n\n# A tibble: 734 × 11\n      X1 name          Gender `Eye color` Race     `Hair color` Height Publisher\n   <dbl> <chr>         <chr>  <chr>       <chr>    <chr>        <chr>  <chr>    \n 1     0 A-Bomb        Male   yellow      Human    No Hair      выше … Marvel C…\n 2     1 Abe Sapien    Male   blue        Icthyo … No Hair      ниже … Dark Hor…\n 3     2 Abin Sur      Male   blue        Ungaran  No Hair      ниже … DC Comics\n 4     3 Abomination   Male   green       Human /… No Hair      выше … Marvel C…\n 5     4 Abraxas       Male   blue        Cosmic … Black        NA по… Marvel C…\n 6     5 Absorbing Man Male   blue        Human    No Hair      выше … Marvel C…\n 7     6 Adam Monroe   Male   blue        <NA>     Blond        NA по… NBC - He…\n 8     7 Adam Strange  Male   blue        Human    Blond        ниже … DC Comics\n 9     8 Agent 13      Female blue        <NA>     Blond        ниже … Marvel C…\n10     9 Agent Bob     Male   brown       Human    Brown        ниже … Marvel C…\n# … with 724 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <chr>"
  },
  {
    "objectID": "910-tasks.html#desc_tasks",
    "href": "910-tasks.html#desc_tasks",
    "title": "24  Задания",
    "section": "24.24 Описательная статистика",
    "text": "24.24 Описательная статистика\nДля выполнения задания создайте вектор height из колонки Height датасета heroes, удалив в нем NA.\n\n\n\n\nПосчитайте среднее в векторе height.\n\n\n\n[1] 186.7263\n\n\n\nПосчитайте усеченное среднее в векторе height с усечением 5% значений с обоих сторон.\n\n\n\n[1] 182.5846\n\n\n\nПосчитайте медиану в векторе height.\n\n\n\n[1] 183\n\n\n\nПосчитайте стандартное отклонение в векторе height.\n\n\n\n[1] 59.25189\n\n\n\nПосчитайте межквартильный размах в векторе height.\n\n\n\n[1] 18\n\n\n\nПосчитайте ассиметрию в векторе height.\n\n\n\n[1] 8.843432\n\n\nПосчитайте эксцесс в векторе height.\n\n\n[1] 105.0297\n\n\nПримените функции для получения множественных статистик на векторе height.\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   15.2   173.0   183.0   186.7   191.0   975.0 \n\n\n   vars   n   mean    sd median trimmed   mad  min max range skew kurtosis   se\nX1    1 517 186.73 59.25    183  182.02 11.86 15.2 975 959.8 8.84   105.03 2.61\n\n\n\nData summary\n\n\nName\nheight\n\n\nNumber of rows\n517\n\n\nNumber of columns\n1\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n1\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\ndata\n0\n1\n186.73\n59.25\n15.2\n173\n183\n191\n975\n▇▁▁▁▁"
  },
  {
    "objectID": "910-tasks.html#ggplot2_tasks",
    "href": "910-tasks.html#ggplot2_tasks",
    "title": "24  Задания",
    "section": "24.25 Построение графиков в ggplot2",
    "text": "24.25 Построение графиков в ggplot2\n\nНарисуйте столбиковую диаграмму (geom_bar()), которая будет отражать количество супергероев издателей \"Marvel Comics\", \"DC Comics\" и всех остальных (отдельным столбиком) из датасета heroes.\n\n\n\n\n\n\n\nДобавьте к этой диаграме заливку цветом (fill =) в зависимости от распределения Gender внутри каждой группы.\n\n\n\n\n\n\n\nСделайте так, чтобы каждый столбик был максимальной высоты (position = \"fill\").\n\n\n\n\n\n\n\nФинализируйте график, задав ему описания осей (например, функция labs()), использовав процентную шкалу (scale_y_continuous(labels = scales::percent)) и задав тему theme_minimal().\n\n\n\n\n\n\nСоздайте диаграмму рассеяния для датасета heroes, для которой координаты по оси x будут взяты из колонки Height, а координаты по оси y – из колонки Weight.\n\n\n\n\n\n\nУдалите с графика все экстремальные значения, для которых Weight больше или равен 700 или Height больше или равен 400. (Подсказка: это можно делать как средствами ggplot2, так и функцией filter() из dplyr).\n\n\n\n\n\n\n\nРаскрасьте точки в зависимости от Gender, сделайте их полупрозрачными ( параметр alpha =).\n\n\n\n\n\n\n\nСделайте так, чтобы координатная плоскость имела соотношение 1:1 шкал по оси x и y. Этого можно добиться с помощью функции coord_fixed().\n\n\n\n\n\n\nРазделите график (facet_wrap()) на три: для \"DC Comics\",\"Marvel Comics\" и всех остальных.\n\n\n\n\n\n\nИспользуйте для графика тему theme_linedraw().\n\n\n\n\n\n\n\n\nПостройте новый график (или возьмите старый) по датасетам heroes и/или powers и сделайте его некрасивым! Чем хуже у вас получится график, тем лучше. Желательно, чтобы этот график был по-прежнему графиком, а не произведением абстрактного искусства. Разница очень тонкая, но она есть.\n\n\nВот несколько подсказок для этого задания:\n\nДля вдохновения посмотрите на вот эти графики.\nДля реально плохих графиков вам придется покопаться с настройками темы. Посмотрите подсказку по темам ?theme, попытайтесь что-то поменять в теме.\nЭкспериментируйте с разными геомами и необычными их применениями.\nПо изучайте дополнения к gpplot2.\nПопробуйте подготовить интересные данные для этого графика."
  },
  {
    "objectID": "910-tasks.html#dist_tasks",
    "href": "910-tasks.html#dist_tasks",
    "title": "24  Задания",
    "section": "24.26 Распределения",
    "text": "24.26 Распределения\nВыберите любое непрерывное распределение из представленных в базовом пакете stats или же в любом другом пакете. Найти все распределения пакета stats можно с помощью ?Distributions. Подберите для него какие-нибудь параметры или используйте параметры по умолчанию.\n\nЯ возьму F-распределение с параметрами df1 = 4 и df = 10, но вы можете выбрать другое распределение.\n\n\nВизуализируйте функцию плотности вероятности для выбранного распределения.\n\n\n\n\n\n\n\nВизуализируйте функцию накопленной плотности распределения для выбранной функции.\n\n\n\n\n\n\n\nВизуализируйте квантильную функцию для выбранного распределения.\n\n\n\n\n\n\n\nСделайте выборку из 100 случайных значений из выбранного распределения и постройте гистограмму (функция hist()) для полученной выборки."
  },
  {
    "objectID": "910-tasks.html#one_ttest_tasks",
    "href": "910-tasks.html#one_ttest_tasks",
    "title": "24  Задания",
    "section": "24.27 Одновыборочный t-test",
    "text": "24.27 Одновыборочный t-test\n\nПредставьте, что наши супергерои из набора данных heroes – это выборка из генеральной совокупности всех написанных и ненаписанных супергероев. Проведите одновыборочный t-тест для веса супергероев и числа 100 – предположительного среднего веса в генеральной совокупности всех супергероев. Проинтерпретируйте результат.\nПроведите одновыборочный t-тест для роста супергероев и числа 185 – предположительного среднего роста в генеральной совокупности всех супергероев. Проинтерпретируйте результат."
  },
  {
    "objectID": "910-tasks.html#dep_ttest_tasks",
    "href": "910-tasks.html#dep_ttest_tasks",
    "title": "24  Задания",
    "section": "24.28 Двухвыборочный зависимый t-test",
    "text": "24.28 Двухвыборочный зависимый t-test\nДля дальнейших заданий понадобится набор данных о результативности трех диет, который мы использовали во время занятия.\n\ndiet <- readr::read_csv(\"https://raw.githubusercontent.com/Pozdniakov/tidy_stats/master/data/stcp-Rdataset-Diet.csv\")\n\n\nПосчитайте двухвыборочный зависимый т-тест для остальных диет: для диеты 2 и диеты 3. Проинтерпретируйте полученные результаты."
  },
  {
    "objectID": "910-tasks.html#ind_ttest_tasks",
    "href": "910-tasks.html#ind_ttest_tasks",
    "title": "24  Задания",
    "section": "24.29 Двухвыборочный независимый t-test",
    "text": "24.29 Двухвыборочный независимый t-test\n\nСделайте независимый t-тест для сравнения веса испытуемых двух групп после диеты, сравнив вторую и третью группу. Проинтерпретируйте результаты.\nСделайте независимый t-тест для сравнения веса испытуемых двух групп после диеты, сравнив первую и третью группу. Проинтерпретируйте результаты."
  },
  {
    "objectID": "910-tasks.html#nonparam_ttest_tasks",
    "href": "910-tasks.html#nonparam_ttest_tasks",
    "title": "24  Задания",
    "section": "24.30 Непараметрические аналоги t-теста",
    "text": "24.30 Непараметрические аналоги t-теста\n\nСравните вес первой и второй группы после диеты, используя тест Манна-Уитни. Сравните результаты теста Манна-Уитни с результатами t-теста? Проинтерпретируйте полученные результаты.\nПовторите задание для второй и третьей группы, а так же для первой и третьей группы.\nСравните вес до и после для диеты 1, используя тест Уилкоксона. Сравните с результатами применения t-теста. Проинтерпретируйте полученные результаты.\nСравните вес до и после для диеты 2 и диеты 3, используя тест Уилкоксона. Сравните с результатами применения t-теста. Проинтерпретируйте полученные результаты."
  },
  {
    "objectID": "910-tasks.html#chi_sq_tasks",
    "href": "910-tasks.html#chi_sq_tasks",
    "title": "24  Задания",
    "section": "24.31 Критерий хи-квадрат Пирсона",
    "text": "24.31 Критерий хи-квадрат Пирсона\n\nСоздайте в heroes новую колонку is_human логического типа, в которой будет TRUE, если супергерой принадлежит расе (Race) \"Human\", и FALSE в случае если супергерой принадлежит другой расе.\nПосчитайте долю женщин для \"Human\" и всех остальных (is_human равен TRUE и FALSE соответственно). Перед этим удалите все строчки с NA в переменных is_human и Gender.\n\n\n\n# A tibble: 2 × 2\n  is_human `mean(Gender == \"Female\")`\n  <lgl>                         <dbl>\n1 FALSE                         0.241\n2 TRUE                          0.242\n\n\n\nСравните распределения частот для переменных is_human и Gender используя хи-квадрат Пирсона. Проинтерпретируйте результаты.\nПостройте мозаичный график для переменных is_human и Gender."
  },
  {
    "objectID": "910-tasks.html#backpack_tasks",
    "href": "910-tasks.html#backpack_tasks",
    "title": "24  Задания",
    "section": "24.32 Исследование набора данных Backpack",
    "text": "24.32 Исследование набора данных Backpack\nДля следующих тем нам понадобится набор данных Backpack из пакета Stat2Data.\n\n#install.packages(\"Stat2Data\")\nlibrary(Stat2Data)\ndata(Backpack)\nback <- Backpack %>%\n  mutate(backpack_kg = 0.45359237 * BackpackWeight,\n         body_kg = 0.45359237 * BodyWeight)\n\n\nКак различается вес рюкзака в зависимости от пола? Кто весит больше?\n\n\n\n# A tibble: 2 × 2\n  Sex    `mean(backpack_kg)`\n  <fct>                <dbl>\n1 Female                5.01\n2 Male                  5.63\n\n\n\nЕсли допустить, что выборка репрезентативна, то можно ли сделать вывод о различии по среднему весу рюкзаков в генеральной совокупности?\nПовторите пунктs 2 и 3 для веса самих студентов.\nВизуализируйте распределение этих двух переменных в зависимости от пола (используя ggplot2)\n\n\n\n\n\n\n\nПостройте диаграмму рассеяния с помощью ggplot2. Цветом закодируйте пол респондента."
  },
  {
    "objectID": "910-tasks.html#cov_tasks",
    "href": "910-tasks.html#cov_tasks",
    "title": "24  Задания",
    "section": "24.33 Ковариация",
    "text": "24.33 Ковариация\n\nПосчитайте матрицу ковариаций для веса студентов и их рюкзаков в фунтах. Различаются ли результаты подсчета ковариации этих двух переменных от результатов подсчета ковариаций веса студентов и их рюкзаков в килограммах? Почему?"
  },
  {
    "objectID": "910-tasks.html#cor_tasks",
    "href": "910-tasks.html#cor_tasks",
    "title": "24  Задания",
    "section": "24.34 Коэффициент корреляции",
    "text": "24.34 Коэффициент корреляции\n\nПосчитайте коэффициент корреляции Пирсона для веса студентов и их рюкзаков в фунтах. Различаются ли результаты подсчета коэффициента корреляции Пирсона (сам коэффициент, p-value) этих двух переменных от результатов подсчета корреляции Пирсона веса студентов и их рюкзаков в килограммах? Почему?\nПосчитайте коэффициент корреляции Пирсона для веса и роста супергероев из датасета heroes. Проинтерпретируйте результат.\nТеперь посчитайте коэффициент корреляции Спирмена и коэффициент корреляции Кэнделла для веса и роста супергероев из датасета heroes. Различаются ли результаты по сравнению с коэффициентом корреляции Пирсона? Почему?"
  },
  {
    "objectID": "920-solutions.html",
    "href": "920-solutions.html",
    "title": "25  Решения заданий",
    "section": "",
    "text": "Задания, которые помечены звездочкой (*) можно пропускать: это задания повышенной сложности, в них требуется подумать над решением, а не просто применить выученные инструменты."
  },
  {
    "objectID": "920-solutions.html#solution_begin",
    "href": "920-solutions.html#solution_begin",
    "title": "25  Решения заданий",
    "section": "25.1 Начало работы в R",
    "text": "25.1 Начало работы в R\n\nРазделите 9801 на 9.\n\n\n9801/9\n\n[1] 1089\n\n\n\nПосчитайте логарифм от 2176782336 по основанию 6.\n\n\nlog(2176782336, 6)\n\n[1] 12\n\n\n\nТеперь натуральный логарифм 10 и умножьте его на 5.\n\n\nlog(10)*5\n\n[1] 11.51293\n\n\n\nС помощью функции sin() посчитайте \\(\\sin (\\pi), \\sin \\left(\\frac{\\pi}{2}\\right), \\sin \\left(\\frac{\\pi}{6}\\right)\\).\n\n\nЗначение \\(\\pi\\) - зашитая в R константа (pi).\n\n\nsin(pi)\n\n[1] 1.224647e-16\n\nsin(pi/2)\n\n[1] 1\n\nsin(pi/6)\n\n[1] 0.5"
  },
  {
    "objectID": "920-solutions.html#solution_new_vecs",
    "href": "920-solutions.html#solution_new_vecs",
    "title": "25  Решения заданий",
    "section": "25.2 Создание векторов",
    "text": "25.2 Создание векторов\n\nСоздайте вектор из значений 2, 30 и 4000.\n\n\nc(2, 30, 4000)\n\n[1]    2   30 4000\n\n\n\nСоздайте вектор от 1 до 20.\n\n\n1:20\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20\n\n\n\nСоздайте вектор от 20 до 1.\n\n\n20:1\n\n [1] 20 19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1\n\n\nФункция sum() возвращает сумму элементов вектора на входе. Посчитайте сумму первых 100 натуральных чисел (т.е. всех целых чисел от 1 до 100).\n\nsum(1:100)\n\n[1] 5050\n\n\n\nСоздайте вектор от 1 до 20 и снова до 1. Число 20 должно присутствовать только один раз!\n\n\nc(1:20, 19:1)\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 19 18 17 16 15\n[26] 14 13 12 11 10  9  8  7  6  5  4  3  2  1\n\n\n\nСоздайте вектор значений 5, 4, 3, 2, 2, 3, 4, 5:\n\n\nc(5:2, 2:5)\n\n[1] 5 4 3 2 2 3 4 5\n\n\n\nСоздайте вектор 2, 4, 6, … , 18, 20.\n\n\nseq(2, 20, 2)\n\n [1]  2  4  6  8 10 12 14 16 18 20\n\n\n\nСоздайте вектор 0.1, 0.2, 0.3, …, 0.9, 1.\n\n\nseq(0.1, 1, 0.1)\n\n [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0\n\n\n\n2020 год — високосный. Следующий високосный год через 4 года — это будет 2024 год. Составьте календарь всех високосных годов XXI века, начиная с 2020 года.\n\n\n2100 год относится к XXI веку, а не к XXII.\n\n\nseq(2020, 2100, 4)\n\n [1] 2020 2024 2028 2032 2036 2040 2044 2048 2052 2056 2060 2064 2068 2072 2076\n[16] 2080 2084 2088 2092 2096 2100\n\n\n\nСоздайте вектор, состоящий из 20 повторений “Хэй!”.\n\n\nrep(\"Хэй!\", 20)\n\n [1] \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\"\n[11] \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\" \"Хэй!\"\n\n\n\nКак я и говорил, многие функции, работающие с одним значением на входе, так же прекрасно работают и с целыми векторами. Попробуйте посчитать квадратный корень чисел от 1 до 10 с помощью функции sqrt() и сохраните результат в векторе roots. Выведите содержание вектора roots в консоль.\n\n\nroots <- sqrt(1:10)\nroots\n\n [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427\n [9] 3.000000 3.162278\n\n\n\n*Создайте вектор из одной единицы, двух двоек, трех троек, …. , девяти девяток.\n\n\nrep(1:9, 1:9)\n\n [1] 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 6 6 6 6 6 6 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 9 9\n[39] 9 9 9 9 9 9 9"
  },
  {
    "objectID": "920-solutions.html#solution_coer",
    "href": "920-solutions.html#solution_coer",
    "title": "25  Решения заданий",
    "section": "25.3 Приведение типов",
    "text": "25.3 Приведение типов\n\nСделайте вектор vec1, в котором соедините 3, а также значения \"Мой\" и \"вектор\".\n\n\nvec1 <- c(3, \"Мой\", \"вектор\")\nvec1\n\n[1] \"3\"      \"Мой\"    \"вектор\"\n\n\n\nПопробуйте вычесть TRUE из 10.\n\n\n10 - TRUE\n\n[1] 9\n\n\n\nСоедините значение 10 и TRUE в вектор vec2.\n\n\nvec2 <- c(10, TRUE)\nvec2\n\n[1] 10  1\n\n\n\nСоедините вектор vec2 и значение \"r\":\n\n\nc(vec2, \"r\")\n\n[1] \"10\" \"1\"  \"r\" \n\n\n\nСоедините значения 10, TRUE, \"r\" в вектор.\n\n\nc(10, TRUE, \"r\")\n\n[1] \"10\"   \"TRUE\" \"r\""
  },
  {
    "objectID": "920-solutions.html#solution_vec_ion",
    "href": "920-solutions.html#solution_vec_ion",
    "title": "25  Решения заданий",
    "section": "25.4 Векторизация",
    "text": "25.4 Векторизация\n\nСоздайте вектор p, состоящий из значений 4, 5, 6, 7, и вектор q, состоящий из 0, 1, 2, 3.\n\n\np <- 4:7\np\n\n[1] 4 5 6 7\n\nq <- 0:3\nq\n\n[1] 0 1 2 3\n\n\n\nПосчитайте поэлементную сумму векторов p и q:\n\n\np + q\n\n[1]  4  6  8 10\n\n\n\nПосчитайте поэлементную разницу p и q:\n\n\np - q\n\n[1] 4 4 4 4\n\n\n\nПоделите каждый элемент вектора p на соответствующий ему элемент вектора q:\n\n\nО, да, Вам нужно делить на 0!\n\n\np / q\n\n[1]      Inf 5.000000 3.000000 2.333333\n\n\n\nВозведите каждый элемент вектора p в степень соответствующего ему элемента вектора q:\n\n\np ^ q\n\n[1]   1   5  36 343\n\n\n\nУмножьте каждое значение вектора p на 10.\n\n\np * 10\n\n[1] 40 50 60 70\n\n\n\nСоздайте вектор квадратов чисел от 1 до 10:\n\n\n(1:10)^2\n\n [1]   1   4   9  16  25  36  49  64  81 100\n\n\n\nСоздайте вектор 0, 2, 0, 4, … , 18, 0, 20.\n\n\n1:20 * 0:1\n\n [1]  0  2  0  4  0  6  0  8  0 10  0 12  0 14  0 16  0 18  0 20\n\n\n\nСоздайте вектор 1, 0, 3, 0, 5, …, 17, 0, 19, 0.\n\n\n1:20 * 1:0\n\n [1]  1  0  3  0  5  0  7  0  9  0 11  0 13  0 15  0 17  0 19  0\n\n\n\n*Создайте вектор, в котором будут содержаться первые 20 степеней двойки.\n\n\n2 ^ (1:20)\n\n [1]       2       4       8      16      32      64     128     256     512\n[10]    1024    2048    4096    8192   16384   32768   65536  131072  262144\n[19]  524288 1048576\n\n\n\n*Создайте вектор из чисел 1, 10, 100, 1000, 10000:\n\n\n10 ^ (0:4)\n\n[1]     1    10   100  1000 10000\n\n\n\n*Посчитать сумму последовательности \\(\\frac{1}{1 \\cdot 2}+\\frac{1}{2 \\cdot 3}+\\frac{1}{3 \\cdot 4}+\\ldots+\\frac{1}{50 \\cdot 51}\\).\n\n\nsum(1 / (1:50 * 2:51))\n\n[1] 0.9803922\n\n\n\n*Посчитать сумму последовательности \\(\\frac{1}{2^{0}}+\\frac{1}{2^{1}}+\\frac{1}{2^{2}}+\\frac{1}{2^{3}}+\\ldots \\frac{1}{2^{20}}\\).\n\n\nsum(1 / 2 ^ (0:20))\n\n[1] 1.999999\n\n\n\n*Посчитать сумму последовательности \\(1+\\frac{4}{3}+\\frac{7}{9}+\\frac{10}{27}+\\frac{13}{81}+\\ldots+\\frac{28}{19683}\\).\n\n\nsum((3 * (1:10) - 2) / 3 ^ (0:9))\n\n[1] 3.749174\n\n\n\n*Сколько чисел из последовательности \\(1+\\frac{4}{3}+\\frac{7}{9}+\\frac{10}{27}+\\frac{13}{81}+\\ldots+\\frac{28}{19683}\\) больше чем 0.5?\n\n\nsum((3 * (1:10) - 2) / 3 ^ (0:9) > 0.5)\n\n[1] 3"
  },
  {
    "objectID": "920-solutions.html#solution_vec_ind",
    "href": "920-solutions.html#solution_vec_ind",
    "title": "25  Решения заданий",
    "section": "25.5 Индексирование векторов",
    "text": "25.5 Индексирование векторов\n\nСоздайте вектор troiki со значениями 3, 6, 9, …, 24, 27.\n\n\ntroiki <- seq(3, 27, 3)\ntroiki\n\n[1]  3  6  9 12 15 18 21 24 27\n\n\n\nИзвлеките 2, 5 и 7 значения вектора troiki.\n\n\ntroiki[c(2, 5, 7)]\n\n[1]  6 15 21\n\n\n\nИзвлеките предпоследнее значение вектора troiki.\n\n\ntroiki[length(troiki) - 1]\n\n[1] 24\n\n\n\nИзвлеките все значения вектора troiki кроме предпоследнего:\n\n\ntroiki[-(length(troiki) - 1)]\n\n[1]  3  6  9 12 15 18 21 27\n\n\nСоздайте вектор vec3, скопировав следующий код:\n\nvec3 <- c(3, 5, 2, 1, 8, 4, 9, 10, 3, 15, 1, 11)\n\n\nНайдите второй элемент вектора vec3.\n\n\nvec3[2]\n\n[1] 5\n\n\n\nВерните второй и пятый элемент вектора vec3.\n\n\nvec3[c(2, 5)]\n\n[1] 5 8\n\n\n\nПопробуйте извлечь сотое значение вектора vec3:\n\n\nvec3[100]\n\n[1] NA\n\n\n\nВерните все элементы вектора vec3 кроме второго элемента.\n\n\nvec3[-2]\n\n [1]  3  2  1  8  4  9 10  3 15  1 11\n\n\n\nВерните все элементы вектора vec3 кроме второго и пятого элемента.\n\n\nvec3[c(-2, -5)]\n\n [1]  3  2  1  4  9 10  3 15  1 11\n\n\n\nНайдите последний элемент вектора vec3.\n\n\nvec3[length(vec3)]\n\n[1] 11\n\n\n\nВерните все значения вектора vec3 кроме первого и последнего.\n\n\nvec3[c(-1, -length(vec3))]\n\n [1]  5  2  1  8  4  9 10  3 15  1\n\n\n\nНайдите все значения вектора vec3, которые больше 4.\n\n\nvec3[vec3 > 4]\n\n[1]  5  8  9 10 15 11\n\n\n\nНайдите все значения вектора vec3, которые больше 4, но меньше 10.\n\n\nЕсли хотите сделать это в одну строчку, то вам помогут логические операторы!\n\n\nvec3[vec3 > 4 & vec3 < 10]\n\n[1] 5 8 9\n\n\n\nНайдите все значения вектора vec3, которые меньше 4 или больше 10.\n\n\nvec3[vec3 < 4 | vec3 > 10]\n\n[1]  3  2  1  3 15  1 11\n\n\n\nВозведите в квадрат каждое значение вектора vec3.\n\n\nvec3 ^ 2\n\n [1]   9  25   4   1  64  16  81 100   9 225   1 121\n\n\n\n*Возведите в квадрат каждое значение вектора на нечетной позиции и извлеките корень из каждого значения на четной позиции вектора vec3.\n\n\nИзвлечение корня - это то же самое, что и возведение в степень 0.5.\n\n\nvec3 ^ c(2, 0.5)\n\n [1]  9.000000  2.236068  4.000000  1.000000 64.000000  2.000000 81.000000\n [8]  3.162278  9.000000  3.872983  1.000000  3.316625\n\n\n\nСоздайте вектор 2, 4, 6, … , 18, 20 как минимум 2 новыми способами.\n\n\nЗнаю, это задание может показаться бессмысленным, но это очень базовая операция, с помощью которой можно, например, разделить данные на две части. Чем больше способов Вы знаете, тем лучше!\n\n\n(1:20)[c(FALSE,TRUE)]\n\n [1]  2  4  6  8 10 12 14 16 18 20\n\n#(1:10)*2"
  },
  {
    "objectID": "920-solutions.html#solution_na",
    "href": "920-solutions.html#solution_na",
    "title": "25  Решения заданий",
    "section": "25.6 Работа с пропущенными значениями",
    "text": "25.6 Работа с пропущенными значениями\n\nСоздайте вектор vec4 со значениями 300, 15, 8, 2, 0, 1, 110, скопировав следующий код:\n\n\nvec4 <- c(300, 15, 8, 20, 0, 1, 110)\nvec4\n\n[1] 300  15   8  20   0   1 110\n\n\n\nЗамените все значения vec4, которые больше 20 на NA.\n\n\nvec4[vec4 > 20] <- NA\n\n\nПроверьте полученный вектор vec4:\n\n\nvec4\n\n[1] NA 15  8 20  0  1 NA\n\n\n\nПосчитайте сумму vec4 с помощью функции sum(). Ответ NA не считается!\n\n\nsum(vec4, na.rm = TRUE)\n\n[1] 44"
  },
  {
    "objectID": "920-solutions.html#solution_matrix",
    "href": "920-solutions.html#solution_matrix",
    "title": "25  Решения заданий",
    "section": "25.7 Матрицы",
    "text": "25.7 Матрицы\n\nСоздайте матрицу 4х4, состоящую из единиц. Назовите ее M1.\n\n\nM1 <- matrix(rep(1, 16), ncol = 4)\nM1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    1    1    1\n[2,]    1    1    1    1\n[3,]    1    1    1    1\n[4,]    1    1    1    1\n\n\n\nПоменяйте все некрайние значения матрицы M1 (то есть значения на позициях [2,2], [2,3], [3,2] и [3,3]) на число 2.\n\n\nM1[2:3, 2:3] <- 2\nM1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    1    1    1\n[2,]    1    2    2    1\n[3,]    1    2    2    1\n[4,]    1    1    1    1\n\n\n\nВыделите второй и третий столбик из матрицы M1.\n\n\nM1[,2:3]\n\n     [,1] [,2]\n[1,]    1    1\n[2,]    2    2\n[3,]    2    2\n[4,]    1    1\n\n\n\nСравните (==) вторую колонку и вторую строчку матрицы M1.\n\n\nM1[,2] == M1[2,]\n\n[1] TRUE TRUE TRUE TRUE\n\n\n\n*Создайте таблицу умножения (9х9) в виде матрицы. Сохраните ее в переменную mult_tab.\n\n\nmult_tab <- matrix(rep(1:9, rep(9,9))*(1:9), nrow = 9)\nmult_tab\n\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n [1,]    1    2    3    4    5    6    7    8    9\n [2,]    2    4    6    8   10   12   14   16   18\n [3,]    3    6    9   12   15   18   21   24   27\n [4,]    4    8   12   16   20   24   28   32   36\n [5,]    5   10   15   20   25   30   35   40   45\n [6,]    6   12   18   24   30   36   42   48   54\n [7,]    7   14   21   28   35   42   49   56   63\n [8,]    8   16   24   32   40   48   56   64   72\n [9,]    9   18   27   36   45   54   63   72   81\n\n#Еще\n#outer(1:9, 1:9, \"*\")\n#1:9 %o% 1:9\n\n\n*Из матрицы mult_tab выделите подматрицу, включающую в себя только строчки с 6 по 8 и столбцы с 3 по 7.\n\n\nmult_tab[6:8, 3:7]\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]   18   24   30   36   42\n[2,]   21   28   35   42   49\n[3,]   24   32   40   48   56\n\n\n\n*Создайте матрицу с логическими значениями, где TRUE, если в этом месте в таблице умножения (mult_tab) двузначное число и FALSE, если однозначное.\n\n\nМатрица - это почти вектор. К нему можно обращаться с единственным индексом.\n\n\nmult_tab >= 10\n\n       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]  [,9]\n [1,] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [2,] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n [3,] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [4,] FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [5,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [6,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [7,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [8,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [9,] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\n\n*Создайте матрицу mult_tab2, в которой все значения tab меньше 10 заменены на 0.\n\n\nmult_tab2 <- mult_tab\nmult_tab2[mult_tab < 10] <- 0\nmult_tab2\n\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n [1,]    0    0    0    0    0    0    0    0    0\n [2,]    0    0    0    0   10   12   14   16   18\n [3,]    0    0    0   12   15   18   21   24   27\n [4,]    0    0   12   16   20   24   28   32   36\n [5,]    0   10   15   20   25   30   35   40   45\n [6,]    0   12   18   24   30   36   42   48   54\n [7,]    0   14   21   28   35   42   49   56   63\n [8,]    0   16   24   32   40   48   56   64   72\n [9,]    0   18   27   36   45   54   63   72   81"
  },
  {
    "objectID": "920-solutions.html#solution_list",
    "href": "920-solutions.html#solution_list",
    "title": "25  Решения заданий",
    "section": "25.8 Списки",
    "text": "25.8 Списки\nДан список list1:\n\nlist1 = list(numbers = 1:5, letters = letters, logic = TRUE)\nlist1\n\n$numbers\n[1] 1 2 3 4 5\n\n$letters\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$logic\n[1] TRUE\n\n\n\nНайдите первый элемент списка list1. Ответ должен быть списком длиной один.\n\n\nlist1[1]\n\n$numbers\n[1] 1 2 3 4 5\n\n\n\nТеперь найдите содержание первого элемента списка list1 двумя разными способами. Ответ должен быть вектором.\n\n\nlist1[[1]]\n\n[1] 1 2 3 4 5\n\nlist1$numbers\n\n[1] 1 2 3 4 5\n\n\n\nТеперь возьмите первый элемент содержания первого элемента списка list1. Ответ должен быть вектором.\n\n\nlist1[[1]][1]\n\n[1] 1\n\n\n\nСоздайте список list2, содержащий в себе два списка list1. Один из них будет иметь имя pupa, а другой — lupa.\n\n\nlist2 = list(pupa = list1, lupa = list1)\nlist2\n\n$pupa\n$pupa$numbers\n[1] 1 2 3 4 5\n\n$pupa$letters\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$pupa$logic\n[1] TRUE\n\n\n$lupa\n$lupa$numbers\n[1] 1 2 3 4 5\n\n$lupa$letters\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n$lupa$logic\n[1] TRUE\n\n\n\n*Извлеките первый элемент списка list2, из него — второй полэлемент, а из него — третье значение.\n\n\nlist2[[1]][[2]][3]\n\n[1] \"c\""
  },
  {
    "objectID": "920-solutions.html#solution_df",
    "href": "920-solutions.html#solution_df",
    "title": "25  Решения заданий",
    "section": "25.9 Датафрейм",
    "text": "25.9 Датафрейм\n\nЗапустите команду data(mtcars) чтобы загрузить встроенный датафрейм с информацией про автомобили. Каждая строчка датафрейма - модель автомобиля, каждая колонка - отдельная характеристика. Подробнее см. ?mtcars.\n\n\ndata(mtcars)\nmtcars\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n\n\nИзучите структуру датафрейма mtcars с помощью функции str().\n\n\nstr(mtcars)\n\n'data.frame':   32 obs. of  11 variables:\n $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...\n $ disp: num  160 160 108 258 360 ...\n $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...\n $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\n $ qsec: num  16.5 17 18.6 19.4 17 ...\n $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...\n $ am  : num  1 1 1 0 0 0 0 0 0 0 ...\n $ gear: num  4 4 4 3 3 3 3 4 4 4 ...\n $ carb: num  4 4 1 1 2 1 4 2 2 4 ...\n\n\n\nНайдите значение третьей строчки четвертого столбца датафрейма mtcars.\n\n\nmtcars[3, 4]\n\n[1] 93\n\n\n\nИзвлеките первые шесть строчек и первые шесть столбцов датафрейма mtcars.\n\n\nmtcars[1:6, 1:6]\n\n                   mpg cyl disp  hp drat    wt\nMazda RX4         21.0   6  160 110 3.90 2.620\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875\nDatsun 710        22.8   4  108  93 3.85 2.320\nHornet 4 Drive    21.4   6  258 110 3.08 3.215\nHornet Sportabout 18.7   8  360 175 3.15 3.440\nValiant           18.1   6  225 105 2.76 3.460\n\n\n\nИзвлеките колонку wt датафрейма mtcars - массу автомобиля в тысячах фунтов.\n\n\nmtcars$wt\n\n [1] 2.620 2.875 2.320 3.215 3.440 3.460 3.570 3.190 3.150 3.440 3.440 4.070\n[13] 3.730 3.780 5.250 5.424 5.345 2.200 1.615 1.835 2.465 3.520 3.435 3.840\n[25] 3.845 1.935 2.140 1.513 3.170 2.770 3.570 2.780\n\n\n\nИзвлеките колонки из mtcars в следующем порядке: hp, mpg, cyl.\n\n\nmtcars[, c(\"hp\", \"mpg\", \"cyl\")]\n\n                     hp  mpg cyl\nMazda RX4           110 21.0   6\nMazda RX4 Wag       110 21.0   6\nDatsun 710           93 22.8   4\nHornet 4 Drive      110 21.4   6\nHornet Sportabout   175 18.7   8\nValiant             105 18.1   6\nDuster 360          245 14.3   8\nMerc 240D            62 24.4   4\nMerc 230             95 22.8   4\nMerc 280            123 19.2   6\nMerc 280C           123 17.8   6\nMerc 450SE          180 16.4   8\nMerc 450SL          180 17.3   8\nMerc 450SLC         180 15.2   8\nCadillac Fleetwood  205 10.4   8\nLincoln Continental 215 10.4   8\nChrysler Imperial   230 14.7   8\nFiat 128             66 32.4   4\nHonda Civic          52 30.4   4\nToyota Corolla       65 33.9   4\nToyota Corona        97 21.5   4\nDodge Challenger    150 15.5   8\nAMC Javelin         150 15.2   8\nCamaro Z28          245 13.3   8\nPontiac Firebird    175 19.2   8\nFiat X1-9            66 27.3   4\nPorsche 914-2        91 26.0   4\nLotus Europa        113 30.4   4\nFord Pantera L      264 15.8   8\nFerrari Dino        175 19.7   6\nMaserati Bora       335 15.0   8\nVolvo 142E          109 21.4   4\n\n\n\nПосчитайте количество автомобилей с 4 цилиндрами (cyl) в датафрейме mtcars.\n\n\nsum(mtcars$cyl == 4)\n\n[1] 11\n\n\n\nПосчитайте долю автомобилей с 4 цилиндрами (cyl) в датафрейме mtcars.\n\n\nmean(mtcars$cyl == 4)\n\n[1] 0.34375\n\n\n\nНайдите все автомобили мощностью не менее 100 лошадиных сил (hp) в датафрейме mtcars.\n\n\nmtcars[mtcars$hp >= 100, ]\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n\n\nНайдите все автомобили мощностью не менее 100 лошадиных сил (hp) и 4 цилиндрами (cyl) в датафрейме mtcars.\n\n\nmtcars[mtcars$hp >= 100 & mtcars$cyl == 4, ]\n\n              mpg cyl  disp  hp drat    wt qsec vs am gear carb\nLotus Europa 30.4   4  95.1 113 3.77 1.513 16.9  1  1    5    2\nVolvo 142E   21.4   4 121.0 109 4.11 2.780 18.6  1  1    4    2\n\n\n\nПосчитайте максимальную массу (wt) автомобиля в выборке, воспользовавшись функцией max():\n\n\nmax(mtcars$wt)\n\n[1] 5.424\n\n\n\nПосчитайте минимальную массу (wt) автомобиля в выборке, воспользовавшись функцией min():\n\n\nmin(mtcars$wt)\n\n[1] 1.513\n\n\n\nНайдите строчку датафрейма mtcars с самым легким автомобилем.\n\n\nmtcars[mtcars$wt == min(mtcars$wt), ]\n\n              mpg cyl disp  hp drat    wt qsec vs am gear carb\nLotus Europa 30.4   4 95.1 113 3.77 1.513 16.9  1  1    5    2\n\n\n\nИзвлеките строчки датафрейма mtcars с автомобилями, масса которых ниже средней массы.\n\n\nmtcars[mtcars$wt < mean(mtcars$wt), ]\n\n                mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nMerc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nFiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nFiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L 15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino   19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nVolvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n\n\nМасса автомобиля указана в тысячах фунтов. Создайте колонку wt_kg с массой автомобиля в килограммах. Результат округлите до целых значений с помощью функции round().\n\n\n1 фунт = 0.45359237 кг.\n\n\nmtcars$wt_kg <- round(mtcars$wt * 1000 * 0.45359237)\nmtcars\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb wt_kg\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4  1188\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4  1304\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1  1052\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1  1458\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2  1560\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1  1569\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4  1619\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2  1447\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2  1429\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4  1560\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4  1560\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3  1846\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3  1692\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3  1715\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4  2381\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4  2460\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4  2424\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1   998\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2   733\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1   832\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1  1118\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2  1597\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2  1558\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4  1742\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2  1744\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1   878\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2   971\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2   686\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4  1438\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6  1256\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8  1619\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2  1261"
  },
  {
    "objectID": "920-solutions.html#solution_if",
    "href": "920-solutions.html#solution_if",
    "title": "25  Решения заданий",
    "section": "25.10 Условные конструкции",
    "text": "25.10 Условные конструкции\n\nСоздайте вектор vec5, скопировав следующий код:\n\n\nvec5 <- c(5, 20, 30, 0, 2, 9)\n\n\nСоздайте новый строковый вектор, где на месте чисел больше 10 в vec5 будет стоять “большое число”, а на месте остальных чисел – “маленькое число”.\n\n\nifelse(vec5 > 10, \"большое число\", \"маленькое число\")\n\n[1] \"маленькое число\" \"большое число\"   \"большое число\"   \"маленькое число\"\n[5] \"маленькое число\" \"маленькое число\"\n\n\n\nЗагрузите файл heroes_information.csv в переменную heroes.\n\n\nheroes <- read.csv(\"data/heroes_information.csv\", \n                   stringsAsFactors = FALSE,\n                   na.strings = c(\"-\", \"-99\"))\n\n\nСоздайте новою колонку hair в heroes, в которой будет значение \"Bold\" для тех супергероев, у которых в колонке Hair.color стоит \"No Hair\", и значение \"Hairy\" во всех остальных случаях.\n\n\nheroes$hair <- ifelse(heroes$Hair.color == \"No Hair\", \"Bold\", \"Hairy\")\nhead(heroes)\n\n  X          name Gender Eye.color              Race Hair.color Height\n1 0        A-Bomb   Male    yellow             Human    No Hair    203\n2 1    Abe Sapien   Male      blue     Icthyo Sapien    No Hair    191\n3 2      Abin Sur   Male      blue           Ungaran    No Hair    185\n4 3   Abomination   Male     green Human / Radiation    No Hair    203\n5 4       Abraxas   Male      blue     Cosmic Entity      Black     NA\n6 5 Absorbing Man   Male      blue             Human    No Hair    193\n          Publisher Skin.color Alignment Weight  hair\n1     Marvel Comics       <NA>      good    441  Bold\n2 Dark Horse Comics       blue      good     65  Bold\n3         DC Comics        red      good     90  Bold\n4     Marvel Comics       <NA>       bad    441  Bold\n5     Marvel Comics       <NA>       bad     NA Hairy\n6     Marvel Comics       <NA>       bad    122  Bold\n\n\n\nСоздайте новою колонку tall в heroes, в которой будет значение \"tall\" для тех супергероев, у которых в колонке Height стоит число больше 190, значение \"short\" для тех супергероев, у которых в колонке Height стоит число меньше 170, и значение \"middle\" во всех остальных случаях.\n\n\n# heroes$tall <- dplyr::case_when(\n#   heroes$Height > 190 ~ \"tall\",\n#   heroes$Height < 170 ~ \"short\",\n#   TRUE ~ \"middle\"\n# )\nheroes$tall <- ifelse(heroes$Height > 190, \n                      \"tall\",\n                      ifelse(heroes$Height < 170,\n                             \"short\",\n                             \"middle\"))"
  },
  {
    "objectID": "920-solutions.html#solution_function",
    "href": "920-solutions.html#solution_function",
    "title": "25  Решения заданий",
    "section": "25.11 Создание функций",
    "text": "25.11 Создание функций\n\nСоздайте функцию plus_one(), которая принимает число и возвращает это же число + 1.\n\n\nplus_one <- function(x) x + 1\n\n\nПроверьте функцию plus_one() на числе 41.\n\n\nplus_one(41)\n\n[1] 42\n\n\n\nСоздайте функцию circle_area(), которая вычисляет площадь круга по радиусу согласно формуле \\(\\pi r^2\\).\n\n\ncircle_area <- function(r) pi * r ^ 2\n\n\nПосчитайте площадь круга с радиусом 5.\n\n\ncircle_area(5)\n\n[1] 78.53982\n\n\n\nСоздайте функцию cels2fahr(), которая будет превращать градусы по Цельсию в градусы по Фаренгейту.\n\n\ncels2fahr <- function(x) x * 9 / 5 + 32\n\n\nПроверьте на значениях -100, -40 и 0, что функция cels2fahr() работает корректно.\n\n\ncels2fahr(c(-100, -40, 0))\n\n[1] -148  -40   32\n\n\n\nНапишите функцию highlight(), которая принимает на входе строковый вектор, а возвращает тот же вектор, но дополненный значением \"***\" в начале и конце вектора. Лучше всего это рассмотреть на примере:\n\n\nhighlight <- function(x) c(\"***\", x, \"***\")\n\n\nhighlight(c(\"Я\", \"Бэтмен!\"))\n\n[1] \"***\"     \"Я\"       \"Бэтмен!\" \"***\"    \n\n\n\nТеперь сделайте функцию highlight более гибкой. Добавьте в нее параметр wrapper =, который по умолчанию равен \"***\". Значение параметра wrapper = и будет вставлено в начало и конец вектора.\n\n\nhighlight <- function(x, wrapper = \"***\") c(wrapper, x, wrapper)\n\n\nПроверьте написанную функцию на векторе c(\"Я\", \"Бэтмен!\").\n\n\nhighlight(c(\"Я\", \"Бэтмен!\")) \n\n[1] \"***\"     \"Я\"       \"Бэтмен!\" \"***\"    \n\nhighlight(c(\"Я\", \"Бэтмен!\"), wrapper = \"__\") \n\n[1] \"__\"      \"Я\"       \"Бэтмен!\" \"__\"     \n\n\n\nСоздайте функцию na_n(), которая будет возвращать количество NA в векторе.\n\n\nna_n <- function(x) sum(is.na(x))\n\n\nПроверьте функцию na_n() на векторе:\n\n\nna_n(c(NA, 3:5, NA, 2, NA))\n\n[1] 3\n\n\n\nНапишите функцию factors(), которая будет возвращать все делители числа в виде числового вектора.\n\n\nЗдесь может понадобиться оператор для получения остатка от деления: %%.\n\n\nfactors <- function(x) (1:x)[x %% (1:x) == 0]\n\n\nПроверьте функцию factors() на простых и сложных числах:\n\n\nfactors(3)\n\n[1] 1 3\n\nfactors(161)\n\n[1]   1   7  23 161\n\nfactors(1984)\n\n [1]    1    2    4    8   16   31   32   62   64  124  248  496  992 1984\n\n\n\n*Напишите функцию is_prime(), которая проверяет, является ли число простым.\n\n\nЗдесь может пригодиться функция any() - она возвращает TRUE, если в векторе есть хотя бы один TRUE.\n\n\nis_prime <- function(x) !any(x%%(2:(x-1)) == 0)\n#is_prime <- function(x) length(factors(x)) == 2 #Используя уже написанную функцию factors()\n\n\nПроверьте какие года были для нас простыми, а какие нет:\n\n\nis_prime(2017)\n\n[1] TRUE\n\nis_prime(2019)\n\n[1] FALSE\n\n2019/3 #2019 делится на 3 без остатка\n\n[1] 673\n\nis_prime(2020)\n\n[1] FALSE\n\nis_prime(2021)\n\n[1] FALSE\n\n\n\n*Создайте функцию monotonic(), которая возвращает TRUE, если значения в векторе не убывают (то есть каждое следующее - больше или равно предыдущему) или не возврастают.\n\n\nПолезная функция для этого — diff() — возвращает разницу соседних значений.\n\n\nmonotonic <- function(x) all(diff(x)>=0) | all(diff(x)<=0)\n\n\nmonotonic(1:7)\n\n[1] TRUE\n\nmonotonic(c(1:5,5:1))\n\n[1] FALSE\n\nmonotonic(6:-1)\n\n[1] TRUE\n\nmonotonic(c(1:5, rep(5, 10), 5:10))\n\n[1] TRUE\n\n\nБинарные операторы типа + или %in% тоже представляют собой функции. Более того, мы можем создавать свои бинарные операторы! В этом нет особой сложности — нужно все так же создавать функцию (для двух переменных), главное окружать их % и название обрамлять обратными штрихами `. Например, можно сделать свой бинарный оператор %notin%, который будет выдавать TRUE, если значения слева нет в векторе справа:\n\n`%notin%` <- function(x, y) ! (x %in% y)\n1:10 %notin% c(1, 4, 5)\n\n [1] FALSE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\n\n*Создайте бинарный оператор %without%, который будет возвращать все значения вектора слева без значений вектора справа.\n\n\n`%without%` <- function(x, y) x[!x %in% y]\n\n\nc(\"а\", \"и\", \"б\", \"сидели\", \"на\", \"трубе\") %without% c(\"а\", \"б\")\n\n[1] \"и\"      \"сидели\" \"на\"     \"трубе\" \n\n\n\n*Создайте бинарный оператор %between%, который будет возвращать TRUE, если значение в векторе слева накходится в диапазоне значений вектора справа:\n\n\n`%between%` <- function(x, y) x >= min(y) & x <= max(y)\n\n\n1:10 %between% c(1, 4, 5)\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE"
  },
  {
    "objectID": "920-solutions.html#solution_sanity",
    "href": "920-solutions.html#solution_sanity",
    "title": "25  Решения заданий",
    "section": "25.12 Проверка на адекватность",
    "text": "25.12 Проверка на адекватность\n\nСоздайте функцию trim(), которая будет возвращать вектор без первого и последнего значения (вне зависимости от типа данных).\n\n\ntrim <- function(x) x[c(-1, -length(x))]\n\n\nПроверьте, что функция trim() работает корректно:\n\n\ntrim(1:7)\n\n[1] 2 3 4 5 6\n\ntrim(letters)\n\n [1] \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\"\n[20] \"u\" \"v\" \"w\" \"x\" \"y\"\n\n\n\nТеперь добавьте в функцию trim() параметр n = со значением по умолчанию 1. Этот параметр будет обозначать сколько значений нужно отрезать слева и справа от вектора.\n\n\ntrim <- function(x, n = 1) x[c(-1:-n, (-length(x)+n-1):-length(x))]\n\n\nПроверьте полученную функцию:\n\n\ntrim(letters)\n\n [1] \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\"\n[20] \"u\" \"v\" \"w\" \"x\" \"y\"\n\ntrim(letters, n = 2)\n\n [1] \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" \"u\"\n[20] \"v\" \"w\" \"x\"\n\n\n\nСделайте так, чтобы функция trim() работала корректно с n = 0, т.е. функция возвращала бы исходный вектор без изменений.\n\n\ntrim <- function(x, n = 1) {\n  if (n == 0) return(x)\n  x[c(-1:-n, (-length(x)+n-1):-length(x))]\n}\n\n\ntrim(letters, n = 0)\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\n\n*Теперь добавьте проверку на адекватность входных данных: функция trim() должна выдавать ошибку, если n = меньше нуля или если n = слишком большой и отрезает все значения вектора:\n\n\ntrim <- function(x, n = 1) {\n  if (n < 0) stop(\"n не может быть меньше нуля!\")\n  l <- length(x)\n  if (n > ceiling(l/2) - 1) stop(\"n слишком большой!\")\n  if (n == 0) return(x)\n  x[c(-1:-n, (-l+n-1):-l)]\n}\n\n\n*Проверьте полученную функцию trim():\n\n\ntrim(1:6, 3)\n\nError in trim(1:6, 3): n слишком большой!\n\ntrim(1:6, -1)\n\nError in trim(1:6, -1): n не может быть меньше нуля!"
  },
  {
    "objectID": "920-solutions.html#solution_apply",
    "href": "920-solutions.html#solution_apply",
    "title": "25  Решения заданий",
    "section": "25.13 Семейство функций apply()",
    "text": "25.13 Семейство функций apply()\n\nСоздайте матрицу M2:\n\n\nM2 <- matrix(c(20:11, 11:20), nrow = 5)\nM2\n\n     [,1] [,2] [,3] [,4]\n[1,]   20   15   11   16\n[2,]   19   14   12   17\n[3,]   18   13   13   18\n[4,]   17   12   14   19\n[5,]   16   11   15   20\n\n\n\nПосчитайте максимальное значение матрицы M2 по каждой строчке.\n\n\napply(M2, 1, max)\n\n[1] 20 19 18 19 20\n\n\n\nПосчитайте максимальное значение матрицы M2 по каждому столбцу.\n\n\napply(M2, 2, max)\n\n[1] 20 15 15 20\n\n\n\nПосчитайте среднее значение матрицы M2 по каждой строке.\n\n\napply(M2, 1, mean)\n\n[1] 15.5 15.5 15.5 15.5 15.5\n\n\n\nПосчитайте среднее значение матрицы M2 по каждому столбцу.\n\n\napply(M2, 2, mean)\n\n[1] 18 13 13 18\n\n\n\nСоздайте список list3:\n\n\nlist3 <- list(\n  a = 1:5,\n  b = 0:20,\n  c = 4:24,\n  d = 6:3,\n  e = 6:25\n  )\n\n\nНайдите максимальное значение каждого вектора списка list3.\n\n\nsapply(list3, max)\n\n a  b  c  d  e \n 5 20 24  6 25 \n\n\n\nПосчитайте сумму каждого вектора списка list3.\n\n\nsapply(list3, sum)\n\n  a   b   c   d   e \n 15 210 294  18 310 \n\n\n\nПосчитайте длину каждого вектора списка list3.\n\n\nsapply(list3, length)\n\n a  b  c  d  e \n 5 21 21  4 20 \n\n\n\nНапишите функцию max_item(), которая будет принимать на входе список, а возвращать - (первый) самый длинный его элемент.\n\n\nДля этого вам может понадобиться функция which.max(), которая возвращает индекс максимального значения (первого, если их несколько).\n\n\nmax_item <- function (x) x[[which.max(sapply(x, length))]]\n\n\nПроверьте функцию max_item() на списке list3.\n\n\nmax_item(list3)\n\n [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20\n\n\n\nТеперь мы сделаем сложный список list4:\n\n\nlist4 <- list(1:3, 3:40, list3)\n\n\nПосчитайте длину каждого вектора в списке, в т.ч. для списка внутри. Результат должен быть списком с такой же структорой, как и изначальный список list4.\n\n\nДля этого может понадобиться функция rapply(): recursive lapply\n\n\nrapply(list4, length, how = \"list\")\n\n[[1]]\n[1] 3\n\n[[2]]\n[1] 38\n\n[[3]]\n[[3]]$a\n[1] 5\n\n[[3]]$b\n[1] 21\n\n[[3]]$c\n[1] 21\n\n[[3]]$d\n[1] 4\n\n[[3]]$e\n[1] 20\n\n\n\n*Загрузите набор данных heroes и посчитайте, сколько NA в каждом из столбцов.\n\n\nДля этого удобно использовать ранее написанную функцию na_n().\n\n\nsapply(heroes, na_n)\n\n         X       name     Gender  Eye.color       Race Hair.color     Height \n         0          0         29        172        304        172        217 \n Publisher Skin.color  Alignment     Weight       hair       tall \n         0        662          7        239        172        217 \n\n\n\n*Используя ранее написанную функцию is_prime(), напишите функцию prime_numbers(), которая будет возвращать все простые числа до выбранного числа.\n\n\nis_prime <- function(x) !any(x %% (2:(x - 1)) == 0)\nprime_numbers <- function(x) (2:x)[sapply(2:x, is_prime)]\n\n\nprime_numbers(200)\n\n [1]   3   5   7  11  13  17  19  23  29  31  37  41  43  47  53  59  61  67  71\n[20]  73  79  83  89  97 101 103 107 109 113 127 131 137 139 149 151 157 163 167\n[39] 173 179 181 191 193 197 199"
  },
  {
    "objectID": "920-solutions.html#solution_pipe",
    "href": "920-solutions.html#solution_pipe",
    "title": "25  Решения заданий",
    "section": "25.14 magrittr::%>%",
    "text": "25.14 magrittr::%>%\n\nlibrary(tidyverse)\n\n\nПерепишите следующие выражения, используя %>%:\n\n\nsqrt(sum(1:10))\n\n[1] 7.416198\n\n\n\n1:10 %>%\n  sum() %>%\n  sqrt()\n\n[1] 7.416198\n\n\n\nabs(min(-5:5))\n\n[1] 5\n\n\n\n-5:5 %>%\n  min() %>%\n  abs()\n\n[1] 5\n\n\n\nc(\"Корень из\", 2, \"равен\", sqrt(2))\n\n[1] \"Корень из\"       \"2\"               \"равен\"           \"1.4142135623731\"\n\n\n\n2 %>% c(\"Корень из\", ., \"равен\", sqrt(.))\n\n[1] \"Корень из\"       \"2\"               \"равен\"           \"1.4142135623731\""
  },
  {
    "objectID": "920-solutions.html#solution_select",
    "href": "920-solutions.html#solution_select",
    "title": "25  Решения заданий",
    "section": "25.15 Выбор столбцов: dplyr::select()",
    "text": "25.15 Выбор столбцов: dplyr::select()\nДля выполнения следующих заданий нам понадобятся датасеты heroes и powers, которые можно загрузить, используя следующие команды:\n\nlibrary(tidyverse)\nheroes <- read_csv(\"https://raw.githubusercontent.com/Pozdniakov/tidy_stats/master/data/heroes_information.csv\",\n                   na = c(\"-\", \"-99\"))\npowers <- read_csv(\"https://raw.githubusercontent.com/Pozdniakov/tidy_stats/master/data/super_hero_powers.csv\")\n\n\nВыберете первые 4 столбца в powers.\n\n\npowers %>%\n  select(1:4)\n\n# A tibble: 667 × 4\n   hero_names    Agility `Accelerated Healing` `Lantern Power Ring`\n   <chr>         <lgl>   <lgl>                 <lgl>               \n 1 3-D Man       TRUE    FALSE                 FALSE               \n 2 A-Bomb        FALSE   TRUE                  FALSE               \n 3 Abe Sapien    TRUE    TRUE                  FALSE               \n 4 Abin Sur      FALSE   FALSE                 TRUE                \n 5 Abomination   FALSE   TRUE                  FALSE               \n 6 Abraxas       FALSE   FALSE                 FALSE               \n 7 Absorbing Man FALSE   FALSE                 FALSE               \n 8 Adam Monroe   FALSE   TRUE                  FALSE               \n 9 Adam Strange  FALSE   FALSE                 FALSE               \n10 Agent Bob     FALSE   FALSE                 FALSE               \n# … with 657 more rows\n\n\n\nВыберите все столбцы от Reflexes до Empathy в тиббле powers:\n\n\npowers %>%\n  select(Reflexes:Empathy)\n\n# A tibble: 667 × 7\n   Reflexes Invulnerability `Energy Constructs` `Force Fields` `Self-Sustenance`\n   <lgl>    <lgl>           <lgl>               <lgl>          <lgl>            \n 1 FALSE    FALSE           FALSE               FALSE          FALSE            \n 2 FALSE    FALSE           FALSE               FALSE          TRUE             \n 3 TRUE     FALSE           FALSE               FALSE          FALSE            \n 4 FALSE    FALSE           FALSE               FALSE          FALSE            \n 5 FALSE    TRUE            FALSE               FALSE          FALSE            \n 6 FALSE    TRUE            FALSE               FALSE          FALSE            \n 7 FALSE    TRUE            FALSE               FALSE          FALSE            \n 8 FALSE    FALSE           FALSE               FALSE          FALSE            \n 9 FALSE    FALSE           FALSE               FALSE          FALSE            \n10 FALSE    FALSE           FALSE               FALSE          FALSE            \n# … with 657 more rows, and 2 more variables: `Anti-Gravity` <lgl>,\n#   Empathy <lgl>\n\n\n\nВыберите все столбцы тиббла powers кроме первого (hero_names):\n\n\npowers %>%\nselect(!hero_names)\n\n# A tibble: 667 × 167\n   Agility `Accelerated Hea…` `Lantern Power…` `Dimensional A…` `Cold Resistan…`\n   <lgl>   <lgl>              <lgl>            <lgl>            <lgl>           \n 1 TRUE    FALSE              FALSE            FALSE            FALSE           \n 2 FALSE   TRUE               FALSE            FALSE            FALSE           \n 3 TRUE    TRUE               FALSE            FALSE            TRUE            \n 4 FALSE   FALSE              TRUE             FALSE            FALSE           \n 5 FALSE   TRUE               FALSE            FALSE            FALSE           \n 6 FALSE   FALSE              FALSE            TRUE             FALSE           \n 7 FALSE   FALSE              FALSE            FALSE            TRUE            \n 8 FALSE   TRUE               FALSE            FALSE            FALSE           \n 9 FALSE   FALSE              FALSE            FALSE            FALSE           \n10 FALSE   FALSE              FALSE            FALSE            FALSE           \n# … with 657 more rows, and 162 more variables: Durability <lgl>,\n#   Stealth <lgl>, `Energy Absorption` <lgl>, Flight <lgl>,\n#   `Danger Sense` <lgl>, `Underwater breathing` <lgl>, Marksmanship <lgl>,\n#   `Weapons Master` <lgl>, `Power Augmentation` <lgl>,\n#   `Animal Attributes` <lgl>, Longevity <lgl>, Intelligence <lgl>,\n#   `Super Strength` <lgl>, Cryokinesis <lgl>, Telepathy <lgl>,\n#   `Energy Armor` <lgl>, `Energy Blasts` <lgl>, Duplication <lgl>, …"
  },
  {
    "objectID": "920-solutions.html#solution_filt",
    "href": "920-solutions.html#solution_filt",
    "title": "25  Решения заданий",
    "section": "25.16 Выбор строк: dplyr::slice() и dplyr::filter()",
    "text": "25.16 Выбор строк: dplyr::slice() и dplyr::filter()\n\nВыберите только те строчки, в которых содержится информация о супергероях тяжелее 500 кг.\n\n\nheroes %>% \n  filter(Weight > 500)\n\n# A tibble: 6 × 11\n     X1 name       Gender `Eye color` Race         `Hair color` Height Publisher\n  <dbl> <chr>      <chr>  <chr>       <chr>        <chr>         <dbl> <chr>    \n1   203 Darkseid   Male   red         New God      No Hair       267   DC Comics\n2   283 Giganta    Female green       <NA>         Red            62.5 DC Comics\n3   331 Hulk       Male   green       Human / Rad… Green         244   Marvel C…\n4   373 Juggernaut Male   blue        Human        Red           287   Marvel C…\n5   549 Red Hulk   Male   yellow      Human / Rad… Black         213   Marvel C…\n6   575 Sasquatch  Male   red         <NA>         Orange        305   Marvel C…\n# … with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>\n\n\n\nВыберите только те строчки, в которых содержится информация о женщинах-супергероях тяжелее 500 кг.\n\n\nheroes %>% \n  filter(Weight > 500 & Gender == \"Female\")\n\n# A tibble: 1 × 11\n     X1 name    Gender `Eye color` Race  `Hair color` Height Publisher\n  <dbl> <chr>   <chr>  <chr>       <chr> <chr>         <dbl> <chr>    \n1   283 Giganta Female green       <NA>  Red            62.5 DC Comics\n# … with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>\n\n\n\nВыберите только те строчки, в которых содержится информация о супергероях человеческой расы (\"Human\") женского пола. Из этих супергероев возьмите первые 5.\n\n\nheroes %>% \n  filter(Race == \"Human\" & Gender == \"Female\") %>%\n  slice(1:5)\n\n# A tibble: 5 × 11\n     X1 name         Gender `Eye color` Race  `Hair color` Height Publisher    \n  <dbl> <chr>        <chr>  <chr>       <chr> <chr>         <dbl> <chr>        \n1    38 Arachne      Female blue        Human Blond           175 Marvel Comics\n2    63 Batgirl      Female green       Human Red             170 DC Comics    \n3    65 Batgirl IV   Female green       Human Black           165 DC Comics    \n4    72 Batwoman V   Female green       Human Red             178 DC Comics    \n5    96 Black Canary Female blue        Human Blond           165 DC Comics    \n# … with 3 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>"
  },
  {
    "objectID": "920-solutions.html#solution_arr",
    "href": "920-solutions.html#solution_arr",
    "title": "25  Решения заданий",
    "section": "25.17 Сортировка строк: dplyr::arrange()",
    "text": "25.17 Сортировка строк: dplyr::arrange()\n\nВыберите из тиббла heroes колонки name, Gender, Height и отсортируйте строчки по возрастанию Height.\n\n\nheroes %>%\n  select(name, Gender, Height) %>%\n  arrange(Height)\n\n# A tibble: 734 × 3\n   name            Gender Height\n   <chr>           <chr>   <dbl>\n 1 Utgard-Loki     Male     15.2\n 2 Bloodwraith     Male     30.5\n 3 King Kong       Male     30.5\n 4 Anti-Monitor    Male     61  \n 5 Giganta         Female   62.5\n 6 Krypto          Male     64  \n 7 Yoda            Male     66  \n 8 Jack-Jack       Male     71  \n 9 Howard the Duck Male     79  \n10 Godzilla        <NA>    108  \n# … with 724 more rows\n\n\n\nВыберите из тиббла heroes колонки name, Gender, Height и отсортируйте строчки по убыванию Height.\n\n\nheroes %>%\n  select(name, Gender, Height) %>%\n  arrange(desc(Height))\n\n# A tibble: 734 × 3\n   name          Gender Height\n   <chr>         <chr>   <dbl>\n 1 Fin Fang Foom Male     975 \n 2 Galactus      Male     876 \n 3 Groot         Male     701 \n 4 MODOK         Male     366 \n 5 Wolfsbane     Female   366 \n 6 Onslaught     Male     305 \n 7 Sasquatch     Male     305 \n 8 Ymir          Male     305.\n 9 Rey           Female   297 \n10 Juggernaut    Male     287 \n# … with 724 more rows\n\n\n\nВыберите из тиббла heroes колонки name, Gender, Height и отсортируйте строчки сначала по Gender, затем по убыванию Height.\n\n\nheroes %>%\n  select(name, Gender, Height) %>%\n  arrange(Gender, desc(Height))\n\n# A tibble: 734 × 3\n   name      Gender Height\n   <chr>     <chr>   <dbl>\n 1 Wolfsbane Female    366\n 2 Rey       Female    297\n 3 Bloodaxe  Female    218\n 4 Thundra   Female    218\n 5 Hela      Female    213\n 6 Frenzy    Female    211\n 7 She-Hulk  Female    201\n 8 Ardina    Female    193\n 9 Starfire  Female    193\n10 Valkyrie  Female    191\n# … with 724 more rows"
  },
  {
    "objectID": "920-solutions.html#solution_dist",
    "href": "920-solutions.html#solution_dist",
    "title": "25  Решения заданий",
    "section": "25.18 Уникальные значения: dplyr::distinct()",
    "text": "25.18 Уникальные значения: dplyr::distinct()\n\nИзвлеките уникальные значения столбца Eye color из тиббла heroes.\n\n\nheroes %>%\n  distinct(`Eye color`)\n\n# A tibble: 23 × 1\n   `Eye color`\n   <chr>      \n 1 yellow     \n 2 blue       \n 3 green      \n 4 brown      \n 5 <NA>       \n 6 red        \n 7 violet     \n 8 white      \n 9 purple     \n10 black      \n# … with 13 more rows\n\n\n\nИзвлеките уникальные значения столбца Hair color из тиббла heroes.\n\n\nheroes %>%\n  distinct(`Hair color`)\n\n# A tibble: 30 × 1\n   `Hair color`\n   <chr>       \n 1 No Hair     \n 2 Black       \n 3 Blond       \n 4 Brown       \n 5 <NA>        \n 6 White       \n 7 Purple      \n 8 Orange      \n 9 Pink        \n10 Red         \n# … with 20 more rows"
  },
  {
    "objectID": "920-solutions.html#solution_mutate",
    "href": "920-solutions.html#solution_mutate",
    "title": "25  Решения заданий",
    "section": "25.19 Создание колонок: dplyr::mutate() и dplyr::transmute()",
    "text": "25.19 Создание колонок: dplyr::mutate() и dplyr::transmute()\n\nСоздайте колонку height_m с ростом супергероев в метрах, затем выберите только колонки name и height_m.\n\n\nheroes %>%\n  mutate(height_m = Height/100) %>%\n  select(name, height_m)\n\n# A tibble: 734 × 2\n   name          height_m\n   <chr>            <dbl>\n 1 A-Bomb            2.03\n 2 Abe Sapien        1.91\n 3 Abin Sur          1.85\n 4 Abomination       2.03\n 5 Abraxas          NA   \n 6 Absorbing Man     1.93\n 7 Adam Monroe      NA   \n 8 Adam Strange      1.85\n 9 Agent 13          1.73\n10 Agent Bob         1.78\n# … with 724 more rows\n\n\n\nСоздайте новою колонку hair в heroes, в которой будет значение “Bold” для тех супергероев, у которых в колонке Hair.color стоит “No Hair”, и значение “Hairy” во всех остальных случаях. Затем выберите только колонки name, Hair color, hair.\n\n\nheroes %>%\n  mutate(hair = ifelse(`Hair color` == \"No Hair\", \"Bold\", \"Hairy\")) %>%\n  select(name, `Hair color`, hair)\n\n# A tibble: 734 × 3\n   name          `Hair color` hair \n   <chr>         <chr>        <chr>\n 1 A-Bomb        No Hair      Bold \n 2 Abe Sapien    No Hair      Bold \n 3 Abin Sur      No Hair      Bold \n 4 Abomination   No Hair      Bold \n 5 Abraxas       Black        Hairy\n 6 Absorbing Man No Hair      Bold \n 7 Adam Monroe   Blond        Hairy\n 8 Adam Strange  Blond        Hairy\n 9 Agent 13      Blond        Hairy\n10 Agent Bob     Brown        Hairy\n# … with 724 more rows"
  },
  {
    "objectID": "920-solutions.html#solution_group_by",
    "href": "920-solutions.html#solution_group_by",
    "title": "25  Решения заданий",
    "section": "25.20 Агрегация: dplyr::group_by() %>% summarise()",
    "text": "25.20 Агрегация: dplyr::group_by() %>% summarise()\n\nПосчитайте количество супергероев по расам и отсортируйте по убыванию. Извлеките первые 5 строк.\n\n\nheroes %>%\n  count(Race, sort = TRUE) %>%\n  slice(1:5)\n\n# A tibble: 5 × 2\n  Race              n\n  <chr>         <int>\n1 <NA>            304\n2 Human           208\n3 Mutant           63\n4 God / Eternal    14\n5 Cyborg           11\n\n\n\nПосчитайте средний пост по полу.\n\n\nheroes %>%\n  group_by(Gender) %>%\n  summarise(height_mean = mean(Height, na.rm = TRUE))\n\n# A tibble: 3 × 2\n  Gender height_mean\n  <chr>        <dbl>\n1 Female        175.\n2 Male          192.\n3 <NA>          177."
  },
  {
    "objectID": "920-solutions.html#solution_join",
    "href": "920-solutions.html#solution_join",
    "title": "25  Решения заданий",
    "section": "25.21 Соединение датафреймов: *_join",
    "text": "25.21 Соединение датафреймов: *_join\nСоздайте тиббл web_creators, в котором будут супергерои, которые могут плести паутину, т.е. у них стоит TRUE в колонке Web Creation в тиббле powers.\n\npowers_web <- powers %>%\n  select(hero_names, `Web Creation`)\nweb_creators <- left_join(heroes, powers_web, by = c(\"name\" = \"hero_names\")) %>%\n  filter(`Web Creation`)\nweb_creators\n\n# A tibble: 16 × 12\n      X1 name             Gender `Eye color` Race  `Hair color` Height Publisher\n   <dbl> <chr>            <chr>  <chr>       <chr> <chr>         <dbl> <chr>    \n 1    33 Anti-Venom       Male   blue        Symb… Blond           229 Marvel C…\n 2    38 Arachne          Female blue        Human Blond           175 Marvel C…\n 3   161 Carnage          Male   green       Symb… Red             185 Marvel C…\n 4   335 Hybrid           Male   brown       Symb… Black           175 Marvel C…\n 5   479 Mysterio         Male   brown       Human No Hair         180 Marvel C…\n 6   580 Scarlet Spider … Male   brown       Clone Brown           193 Marvel C…\n 7   597 Silk             Female brown       Human Black            NA Marvel C…\n 8   620 Spider-Girl      Female blue        Human Brown           170 Marvel C…\n 9   621 Spider-Gwen      Female blue        Human Blond           165 Marvel C…\n10   622 Spider-Man       Male   hazel       Human Brown           178 Marvel C…\n11   623 Spider-Man       <NA>   red         Human Brown           178 Marvel C…\n12   624 Spider-Man       Male   brown       Human Black           157 Marvel C…\n13   673 Toxin            Male   blue        Symb… Brown           188 Marvel C…\n14   674 Toxin            Male   black       Symb… Blond           191 Marvel C…\n15   689 Venom            Male   blue        Symb… Strawberry …    191 Marvel C…\n16   692 Venompool        Male   <NA>        Symb… <NA>            226 Marvel C…\n# … with 4 more variables: `Skin color` <chr>, Alignment <chr>, Weight <dbl>,\n#   `Web Creation` <lgl>\n\n\n\nНайдите всех супергероев, которые присутствуют в heroes, но отсутствуют в powers. Ответом должен быть строковый вектор с именами супергероев.\n\n\nanti_join(heroes, powers, by = c(\"name\" = \"hero_names\")) %>%\n  pull(name)\n\n [1] \"Agent 13\"          \"Alfred Pennyworth\" \"Arsenal\"          \n [4] \"Batgirl III\"       \"Batgirl V\"         \"Beetle\"           \n [7] \"Black Goliath\"     \"Black Widow II\"    \"Blaquesmith\"      \n[10] \"Bolt\"              \"Boomer\"            \"Box\"              \n[13] \"Box III\"           \"Captain Mar-vell\"  \"Cat II\"           \n[16] \"Cecilia Reyes\"     \"Clea\"              \"Clock King\"       \n[19] \"Colin Wagner\"      \"Colossal Boy\"      \"Corsair\"          \n[22] \"Cypher\"            \"Danny Cooper\"      \"Darkside\"         \n[25] \"ERG-1\"             \"Fixer\"             \"Franklin Storm\"   \n[28] \"Giant-Man\"         \"Giant-Man II\"      \"Goliath\"          \n[31] \"Goliath\"           \"Goliath\"           \"Guardian\"         \n[34] \"Hawkwoman\"         \"Hawkwoman II\"      \"Hawkwoman III\"    \n[37] \"Howard the Duck\"   \"Jack Bauer\"        \"Jesse Quick\"      \n[40] \"Jessica Sanders\"   \"Jigsaw\"            \"Jyn Erso\"         \n[43] \"Kid Flash II\"      \"Kingpin\"           \"Meteorite\"        \n[46] \"Mister Zsasz\"      \"Mogo\"              \"Moloch\"           \n[49] \"Morph\"             \"Nite Owl II\"       \"Omega Red\"        \n[52] \"Paul Blart\"        \"Penance\"           \"Penance I\"        \n[55] \"Plastic Lad\"       \"Power Man\"         \"Renata Soliz\"     \n[58] \"Ronin\"             \"Shrinking Violet\"  \"Snake-Eyes\"       \n[61] \"Spider-Carnage\"    \"Spider-Woman II\"   \"Stacy X\"          \n[64] \"Thunderbird II\"    \"Two-Face\"          \"Vagabond\"         \n[67] \"Vision II\"         \"Vulcan\"            \"Warbird\"          \n[70] \"White Queen\"       \"Wiz Kid\"           \"Wondra\"           \n[73] \"Wyatt Wingfoot\"    \"Yellow Claw\"      \n\n\n\nНайдите всех супергероев, которые присутствуют в powers, но отсутствуют в heroes. Ответом должен быть строковый вектор с именами супергероев.\n\n\nanti_join(powers, heroes, by = c(\"hero_names\" = \"name\")) %>%\n  pull(hero_names)\n\n [1] \"3-D Man\"           \"Bananaman\"         \"Bizarro-Girl\"     \n [4] \"Black Vulcan\"      \"Blue Streak\"       \"Bradley\"          \n [7] \"Clayface\"          \"Concrete\"          \"Dementor\"         \n[10] \"Doctor Poison\"     \"Fire\"              \"Hellgramite\"      \n[13] \"Lara Croft\"        \"Little Epic\"       \"Lord Voldemort\"   \n[16] \"Orion\"             \"Peek-a-Boo\"        \"Queen Hippolyta\"  \n[19] \"Reactron\"          \"SHDB\"              \"Stretch Armstrong\"\n[22] \"TEST\"              \"Tommy Clarke\"      \"Tyrant\""
  },
  {
    "objectID": "920-solutions.html#solution_pivot",
    "href": "920-solutions.html#solution_pivot",
    "title": "25  Решения заданий",
    "section": "25.22 Tidy data",
    "text": "25.22 Tidy data\n\nДля начала создайте тиббл heroes_weight, скопировав код:\n\n\nheroes_weight <- heroes %>%\n  filter(Publisher %in% c(\"DC Comics\", \"Marvel Comics\")) %>%\n  group_by(Gender, Publisher) %>%\n  summarise(weight_mean = mean(Weight, na.rm = TRUE)) %>%\n  drop_na()\nheroes_weight \n\n# A tibble: 4 × 3\n# Groups:   Gender [2]\n  Gender Publisher     weight_mean\n  <chr>  <chr>               <dbl>\n1 Female DC Comics            76.8\n2 Female Marvel Comics        80.1\n3 Male   DC Comics           113. \n4 Male   Marvel Comics       134. \n\n\n\nФункция drop_na() позволяет выбросить все строчки, в которых встречается NA.\n\n\nПревратите тиббл heroes_weight в широкий тиббл:\n\n\nheroes_weight %>%\n  pivot_wider(names_from = \"Publisher\", values_from = \"weight_mean\")\n\n# A tibble: 2 × 3\n# Groups:   Gender [2]\n  Gender `DC Comics` `Marvel Comics`\n  <chr>        <dbl>           <dbl>\n1 Female        76.8            80.1\n2 Male         113.            134. \n\n\n\nЗатем превратите его обратно в длинный тиббл:\n\n\nheroes_weight %>%\n  pivot_wider(names_from = \"Publisher\", values_from = \"weight_mean\") %>%\n  pivot_longer(cols = !Gender,\n               names_to = \"Publisher\",\n               values_to = \"weight_mean\")\n\n# A tibble: 4 × 3\n# Groups:   Gender [2]\n  Gender Publisher     weight_mean\n  <chr>  <chr>               <dbl>\n1 Female DC Comics            76.8\n2 Female Marvel Comics        80.1\n3 Male   DC Comics           113. \n4 Male   Marvel Comics       134. \n\n\n\nСделайте powers длинным тибблом с тремя колонками: hero_names, power (названгие суперсилы) и has (наличие суперсилы у данного супергероя).\n\n\npowers %>%\n  pivot_longer(cols = !hero_names,\n               names_to = \"power\",\n               values_to = \"has\")\n\n# A tibble: 111,389 × 3\n   hero_names power                 has  \n   <chr>      <chr>                 <lgl>\n 1 3-D Man    Agility               TRUE \n 2 3-D Man    Accelerated Healing   FALSE\n 3 3-D Man    Lantern Power Ring    FALSE\n 4 3-D Man    Dimensional Awareness FALSE\n 5 3-D Man    Cold Resistance       FALSE\n 6 3-D Man    Durability            FALSE\n 7 3-D Man    Stealth               FALSE\n 8 3-D Man    Energy Absorption     FALSE\n 9 3-D Man    Flight                FALSE\n10 3-D Man    Danger Sense          FALSE\n# … with 111,379 more rows\n\n\n\nСделайте тиббл powers обратно широким, но с новой структурой: каждая строчка означает суперсилу, а каждая колонка - супергероя (за исключением первой колонки - названия суперсилы).\n\n\npowers %>%\n  pivot_longer(cols = !hero_names,\n               names_to = \"power\",\n               values_to = \"has\") %>%\n  pivot_wider(names_from = hero_names,\n              values_from = has)\n\n# A tibble: 167 × 668\n   power          `3-D Man` `A-Bomb` `Abe Sapien` `Abin Sur` Abomination Abraxas\n   <chr>          <lgl>     <lgl>    <lgl>        <lgl>      <lgl>       <lgl>  \n 1 Agility        TRUE      FALSE    TRUE         FALSE      FALSE       FALSE  \n 2 Accelerated H… FALSE     TRUE     TRUE         FALSE      TRUE        FALSE  \n 3 Lantern Power… FALSE     FALSE    FALSE        TRUE       FALSE       FALSE  \n 4 Dimensional A… FALSE     FALSE    FALSE        FALSE      FALSE       TRUE   \n 5 Cold Resistan… FALSE     FALSE    TRUE         FALSE      FALSE       FALSE  \n 6 Durability     FALSE     TRUE     TRUE         FALSE      FALSE       FALSE  \n 7 Stealth        FALSE     FALSE    FALSE        FALSE      FALSE       FALSE  \n 8 Energy Absorp… FALSE     FALSE    FALSE        FALSE      FALSE       FALSE  \n 9 Flight         FALSE     FALSE    FALSE        FALSE      FALSE       TRUE   \n10 Danger Sense   FALSE     FALSE    FALSE        FALSE      FALSE       FALSE  \n# … with 157 more rows, and 661 more variables: `Absorbing Man` <lgl>,\n#   `Adam Monroe` <lgl>, `Adam Strange` <lgl>, `Agent Bob` <lgl>,\n#   `Agent Zero` <lgl>, `Air-Walker` <lgl>, Ajax <lgl>, `Alan Scott` <lgl>,\n#   `Alex Mercer` <lgl>, `Alex Woolsly` <lgl>, Alien <lgl>,\n#   `Allan Quatermain` <lgl>, Amazo <lgl>, Ammo <lgl>, `Ando Masahashi` <lgl>,\n#   Angel <lgl>, `Angel Dust` <lgl>, `Angel Salvadore` <lgl>, Angela <lgl>,\n#   `Animal Man` <lgl>, Annihilus <lgl>, `Ant-Man` <lgl>, `Ant-Man II` <lgl>, …"
  },
  {
    "objectID": "920-solutions.html#solution_across",
    "href": "920-solutions.html#solution_across",
    "title": "25  Решения заданий",
    "section": "25.23 Операции с несколькими колонками: across()",
    "text": "25.23 Операции с несколькими колонками: across()\n\nПосчитайте количество NA в каждой колонке, группируя по полу (Gender).\n\n\nna_n <- function(x) sum(is.na(x))\nheroes %>%\n  group_by(Gender) %>%\n  summarise(across(everything(), na_n))\n\n# A tibble: 3 × 11\n  Gender    X1  name `Eye color`  Race `Hair color` Height Publisher\n  <chr>  <int> <int>       <int> <int>        <int>  <int>     <int>\n1 Female     0     0          41    98           38     56         0\n2 Male       0     0         121   184          123    147         0\n3 <NA>       0     0          10    22           11     14         0\n# … with 3 more variables: `Skin color` <int>, Alignment <int>, Weight <int>\n\n\n\nПосчитайте количество NA в каждой колонке, которая заканчивается на \"color\", группируя по полу (Gender).\n\n\nna_n <- function(x) sum(is.na(x))\nheroes %>%\n  group_by(Gender) %>%\n  summarise(across(ends_with(\"color\"), na_n))\n\n# A tibble: 3 × 4\n  Gender `Eye color` `Hair color` `Skin color`\n  <chr>        <int>        <int>        <int>\n1 Female          41           38          186\n2 Male           121          123          449\n3 <NA>            10           11           27\n\n\n\nНайдите (первую) самую длинную строчку для каждой колонки с character типом данных, группируя по полу (Gender).\n\n\nДля расчета количества значений в строке есть функция nchar(), для расчета индекса (первого) максимального значения есть функция which.max().\n\n\nlongest_char <- function(x) x[which.max(nchar(x))]\nheroes %>%\n  group_by(Gender) %>%\n  summarise(across(where(is.character), longest_char))\n\n# A tibble: 3 × 8\n  Gender name    `Eye color` Race  `Hair color` Publisher `Skin color` Alignment\n  <chr>  <chr>   <chr>       <chr> <chr>        <chr>     <chr>        <chr>    \n1 Female Negaso… yellow (wi… Huma… Strawberry … Dark Hor… orange       neutral  \n2 Male   Drax t… yellow / r… Dath… Strawberry … Dark Hor… orange / wh… neutral  \n3 <NA>   Captai… yellow (wi… God … Orange / Wh… Marvel C… grey         neutral  \n\n\n\nСоздайте из тиббла heroes новый тиббл, в котором числовые значения Height и Weight заменены на следующие строковые значения: если у супергероя рост или вес выше среднего по колонке, то \"выше среднего\", если его/ее рост или вес ниже или равен среднему, то \"ниже среднего\".\n\n\nhigher_than_average <- function(x) ifelse(x > mean(x, na.rm = TRUE),\n                                          \"выше среднего\",\n                                          \"ниже среднего\")\nheroes %>%\n  mutate(across(c(Height, Weight), \n                   higher_than_average))\n\n# A tibble: 734 × 11\n      X1 name          Gender `Eye color` Race     `Hair color` Height Publisher\n   <dbl> <chr>         <chr>  <chr>       <chr>    <chr>        <chr>  <chr>    \n 1     0 A-Bomb        Male   yellow      Human    No Hair      выше … Marvel C…\n 2     1 Abe Sapien    Male   blue        Icthyo … No Hair      выше … Dark Hor…\n 3     2 Abin Sur      Male   blue        Ungaran  No Hair      ниже … DC Comics\n 4     3 Abomination   Male   green       Human /… No Hair      выше … Marvel C…\n 5     4 Abraxas       Male   blue        Cosmic … Black        <NA>   Marvel C…\n 6     5 Absorbing Man Male   blue        Human    No Hair      выше … Marvel C…\n 7     6 Adam Monroe   Male   blue        <NA>     Blond        <NA>   NBC - He…\n 8     7 Adam Strange  Male   blue        Human    Blond        ниже … DC Comics\n 9     8 Agent 13      Female blue        <NA>     Blond        ниже … Marvel C…\n10     9 Agent Bob     Male   brown       Human    Brown        ниже … Marvel C…\n# … with 724 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <chr>\n\n\n\nСоздайте из тиббла heroes новый тиббл, в котором числовые значения Height и Weight заменены на следующие строковые значения: если у супергероя внутри соответствующей группы по полу рост или вес выше среднего по колонке, то \"выше среднего по X\", если его/ее рост или вес ниже или равен среднему внутри соответствующей группы по полу, то \"ниже среднего по X\" , где X — соответствующий пол (Gender).\n\n\nheroes %>%\n  group_by(Gender) %>%\n  mutate(across(c(Height, Weight), \n                   higher_than_average)) %>%\n  ungroup() %>%\n  mutate(across(c(Height, Weight), \n                   ~paste(., \"по\", Gender)))\n\n# A tibble: 734 × 11\n      X1 name          Gender `Eye color` Race     `Hair color` Height Publisher\n   <dbl> <chr>         <chr>  <chr>       <chr>    <chr>        <chr>  <chr>    \n 1     0 A-Bomb        Male   yellow      Human    No Hair      выше … Marvel C…\n 2     1 Abe Sapien    Male   blue        Icthyo … No Hair      ниже … Dark Hor…\n 3     2 Abin Sur      Male   blue        Ungaran  No Hair      ниже … DC Comics\n 4     3 Abomination   Male   green       Human /… No Hair      выше … Marvel C…\n 5     4 Abraxas       Male   blue        Cosmic … Black        NA по… Marvel C…\n 6     5 Absorbing Man Male   blue        Human    No Hair      выше … Marvel C…\n 7     6 Adam Monroe   Male   blue        <NA>     Blond        NA по… NBC - He…\n 8     7 Adam Strange  Male   blue        Human    Blond        ниже … DC Comics\n 9     8 Agent 13      Female blue        <NA>     Blond        ниже … Marvel C…\n10     9 Agent Bob     Male   brown       Human    Brown        ниже … Marvel C…\n# … with 724 more rows, and 3 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <chr>"
  },
  {
    "objectID": "920-solutions.html#desc_solutions",
    "href": "920-solutions.html#desc_solutions",
    "title": "25  Решения заданий",
    "section": "25.24 Описательная статистика",
    "text": "25.24 Описательная статистика\nДля выполнения задания создайте вектор height из колонки Height датасета heroes, удалив в нем NA.\n\nheight <- heroes %>%\n  drop_na(Height) %>%\n  pull(Height)\n\n\nПосчитайте среднее в векторе height.\n\n\nmean(height)\n\n[1] 186.7263\n\n\n\nПосчитайте усеченное среднее в векторе height с усечением 5% значений с обоих сторон.\n\n\nmean(height, trim = 0.05)\n\n[1] 182.5846\n\n\n\nПосчитайте медиану в векторе height.\n\n\nmedian(height)\n\n[1] 183\n\n\n\nПосчитайте стандартное отклонение в векторе height.\n\n\nsd(height)\n\n[1] 59.25189\n\n\n\nПосчитайте межквартильный размах в векторе height.\n\n\nIQR(height)\n\n[1] 18\n\n\n\nПосчитайте ассиметрию в векторе height.\n\n\npsych::skew(height)\n\n[1] 8.843432\n\n\nПосчитайте эксцесс в векторе height.\n\npsych::kurtosi(height)\n\n[1] 105.0297\n\n\nПримените функции для получения множественных статистик на векторе height.\n\nsummary(height)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   15.2   173.0   183.0   186.7   191.0   975.0 \n\npsych::describe(height)\n\n   vars   n   mean    sd median trimmed   mad  min max range skew kurtosis   se\nX1    1 517 186.73 59.25    183  182.02 11.86 15.2 975 959.8 8.84   105.03 2.61\n\nskimr::skim(height)\n\n\nData summary\n\n\nName\nheight\n\n\nNumber of rows\n517\n\n\nNumber of columns\n1\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n1\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\ndata\n0\n1\n186.73\n59.25\n15.2\n173\n183\n191\n975\n▇▁▁▁▁"
  },
  {
    "objectID": "920-solutions.html#ggplot2_solutions",
    "href": "920-solutions.html#ggplot2_solutions",
    "title": "25  Решения заданий",
    "section": "25.25 Построение графиков в ggplot2",
    "text": "25.25 Построение графиков в ggplot2\n\nНарисуйте столбиковую диаграмму (geom_bar()), которая будет отражать количество супергероев издателей \"Marvel Comics\", \"DC Comics\" и всех остальных (отдельным столбиком) из датасета heroes.\n\n\nheroes %>%\n  mutate(Publisher = ifelse(Publisher %in% c(\"Marvel Comics\", \"DC Comics\"), \n                            Publisher,\n                            \"Other publishers\")) %>%\n  #mutate(Publisher = fct_lump(Publisher, 2)) %>% #Еще один способ сделать то же самое, но через forcats\n  ggplot(aes(x = Publisher)) +\n  geom_bar()\n\n\n\n\n\nДобавьте к этой диаграме заливку цветом (fill =) в зависимости от распределения Gender внутри каждой группы.\n\n\nheroes %>%\n  mutate(Publisher = ifelse(Publisher %in% c(\"Marvel Comics\", \"DC Comics\"), \n                            Publisher,\n                            \"Other publishers\")) %>%\n  #mutate(Publisher = fct_lump(Publisher, 2)) %>% #Еще один способ сделать то же самое, но через forcats\n  ggplot(aes(x = Publisher, fill = Gender)) +\n  geom_bar()\n\n\n\n\n\nСделайте так, чтобы каждый столбик был максимальной высоты (position = \"fill\").\n\n\nheroes %>%\n  mutate(Publisher = ifelse(Publisher %in% c(\"Marvel Comics\", \"DC Comics\"), \n                            Publisher,\n                            \"Other publishers\")) %>%\n  #mutate(Publisher = fct_lump(Publisher, 2)) %>% #Еще один способ сделать то же самое, но через forcats\n  ggplot(aes(x = Publisher, fill = Gender)) +\n  geom_bar(position = \"fill\")\n\n\n\n\n\nФинализируйте график, задав ему описания осей (например, функция labs()), использовав процентную шкалу (scale_y_continuous(labels = scales::percent)) и задав тему theme_minimal().\n\n\nheroes %>%\n  mutate(Publisher = ifelse(Publisher %in% c(\"Marvel Comics\", \"DC Comics\"), \n                            Publisher,\n                            \"Other publishers\")) %>%\n  #mutate(Publisher = fct_lump(Publisher, 2)) %>% #Еще один способ сделать то же самое, но через forcats\n  ggplot(aes(x = Publisher, fill = Gender)) +\n  geom_bar(position = \"fill\") +\n  labs(title = \"Распределение супергероев по полу у разных издателей коммиксов\",\n       x = \"Издатель\",\n       y = \"Количество супергероев\")+\n  scale_y_continuous(labels = scales::percent) +\n  theme_minimal()\n\n\n\n\nСоздайте диаграмму рассеяния для датасета heroes, для которой координаты по оси x будут взяты из колонки Height, а координаты по оси y — из колонки Weight.\n\nheroes %>%\n  ggplot(aes(x = Height, y = Weight)) +\n  geom_point()\n\n\n\n\n\nУдалите с графика все экстремальные значения, для которых Weight больше или равен 700 или Height больше или равен 400. (Подсказка: это можно делать как средствами ggplot2, так и функцией filter() из dplyr).\n\n\nheroes %>%\n  filter(Weight < 700 & Height < 400) %>%\n  ggplot(aes(x = Height, y = Weight)) +\n  geom_point()\n\n\n\n\n\nРаскрасьте точки в зависимости от Gender, сделайте их полупрозрачными ( параметр alpha =).\n\n\nheroes %>%\n  filter(Weight < 700 & Height < 400) %>%\n  ggplot(aes(x = Height, y = Weight)) +\n  geom_point(aes(colour = Gender), alpha = 0.5)\n\n\n\n\n\nСделайте так, чтобы координатная плоскость имела соотношение 1:1 шкал по оси x и y. Этого можно добиться с помощью функции coord_fixed().\n\n\nheroes %>%\n  filter(Weight < 700 & Height < 400) %>%\n  ggplot(aes(x = Height, y = Weight)) +\n  geom_point(aes(colour = Gender), alpha = 0.5) +\n  coord_fixed()\n\n\n\n\nРазделите график (facet_wrap()) на три: для \"DC Comics\",\"Marvel Comics\" и всех остальных.\n\nheroes %>%\n  mutate(Publisher = ifelse(Publisher %in% c(\"Marvel Comics\", \"DC Comics\"), \n                            Publisher,\n                            \"Other publishers\")) %>%\n  filter(Weight < 700 & Height < 400) %>%\n  ggplot(aes(x = Height, y = Weight)) +\n  geom_point(aes(colour = Gender), alpha = 0.5) +\n  coord_fixed() +\n  facet_wrap(~Publisher)\n\n\n\n\n\nИспользуйте для графика тему theme_linedraw().\n\n\nheroes %>%\n  mutate(Publisher = ifelse(Publisher %in% c(\"Marvel Comics\", \"DC Comics\"), \n                            Publisher,\n                            \"Other publishers\")) %>%\n  filter(Weight < 700 & Height < 400) %>%\n  ggplot(aes(x = Height, y = Weight)) +\n  geom_point(aes(colour = Gender), alpha = 0.5) +\n  coord_fixed() +\n  facet_wrap(~Publisher)+\n  theme_linedraw()\n\n\n\n\n\n\nПостройте новый график (или возьмите старый) по датасетам heroes и/или powers и сделайте его некрасивым! Чем хуже у вас получится график, тем лучше. Желательно, чтобы этот график был по-прежнему графиком, а не произведением абстрактного искусства. Разница очень тонкая, но она есть.\n\n\nВот несколько подсказок для этого задания:\n\nДля вдохновения посмотрите на вот эти графики.\nДля реально плохих графиков вам придется покопаться с настройками темы. Посмотрите подсказку по темам ?theme, попытайтесь что-то поменять в теме.\nЭкспериментируйте с разными геомами и необычными их применениями.\nПо изучайте дополнения к gpplot2.\nПопробуйте подготовить интересные данные для этого графика.\n\n\nНЕТ ПРАВИЛЬНОГО РЕШЕНИЯ, ПРОЯВИТЕ СВОЮ ФАНТАЗИЮ!"
  },
  {
    "objectID": "920-solutions.html#dist_solutions",
    "href": "920-solutions.html#dist_solutions",
    "title": "25  Решения заданий",
    "section": "25.26 Распределения",
    "text": "25.26 Распределения\nВыберите любое непрерывное распределение из представленных в базовом пакете stats или же в любом другом пакете. Найти все распределения пакета stats можно с помощью ?Distributions. Подберите для него какие-нибудь параметры или используйте параметры по умолчанию.\n\nЯ возьму F-распределение с параметрами df1 = 4 и df = 10, но вы можете выбрать другое распределение.\n\n\nВизуализируйте функцию плотности вероятности для выбранного распределения.\n\n\nv <- seq(0, 5, 0.01)\nplot(v, df(v, df1 = 4, df2 = 10))\n\n\n\n\n\nВизуализируйте функцию накопленной плотности распределения для выбранной функции.\n\n\nplot(v, pf(v, df1 = 4, df2 = 10))\n\n\n\n\n\nВизуализируйте квантильную функцию для выбранного распределения.\n\n\np <- seq(0, 1, .01)\nplot(p, qf(p, df1 = 4, df2 = 10))\n\n\n\n\n\nСделайте выборку из 100 случайных значений из выбранного распределения и постройте гистограмму (функция hist()) для полученной выборки.\n\n\nhist(rf(100, df1 = 4, df2 = 10))"
  },
  {
    "objectID": "920-solutions.html#one_ttest_solutions",
    "href": "920-solutions.html#one_ttest_solutions",
    "title": "25  Решения заданий",
    "section": "25.27 Одновыборочный t-test",
    "text": "25.27 Одновыборочный t-test\n\nПредставьте, что наши супергерои из набора данных heroes — это выборка из генеральной совокупности всех написанных и ненаписанных супергероев. Проведите одновыборочный t-тест для веса супергероев и числа 100 — предположительного среднего веса в генеральной совокупности всех супергероев. Проинтерпретируйте результат.\n\n\nt.test(heroes$Weight, mu = 100)\n\n\n    One Sample t-test\n\ndata:  heroes$Weight\nt = 2.6174, df = 494, p-value = 0.009133\nalternative hypothesis: true mean is not equal to 100\n95 percent confidence interval:\n 103.0549 121.4501\nsample estimates:\nmean of x \n 112.2525 \n\n\np-value меньше .05, поэтому мы можем отклонить нулевую гипотезу о том, что среднее для веса в генеральной совкупности, из которой вы взяли выборку супергероев, равно 100. Мы принимаем ненулевую гипотезу о том, что в генеральной совокупности средний вес не равен 100.\n\nПроведите одновыборочный t-тест для роста супергероев и числа 185 — предположительного среднего роста в генеральной совокупности всех супергероев. Проинтерпретируйте результат.\n\n\nt.test(heroes$Height, mu = 185)\n\n\n    One Sample t-test\n\ndata:  heroes$Height\nt = 0.66246, df = 516, p-value = 0.508\nalternative hypothesis: true mean is not equal to 185\n95 percent confidence interval:\n 181.6068 191.8458\nsample estimates:\nmean of x \n 186.7263 \n\n\np-value больше .05, поэтому мы не можем отклонить нулевую гипотезу о том, что среднее для роста в генеральной совкупности, из которой вы взяли выборку супергероев, равно 185."
  },
  {
    "objectID": "920-solutions.html#dep_ttest_solutions",
    "href": "920-solutions.html#dep_ttest_solutions",
    "title": "25  Решения заданий",
    "section": "25.28 Двухвыборочный зависимый t-test",
    "text": "25.28 Двухвыборочный зависимый t-test\n\ndiet <- readr::read_csv(\"https://raw.githubusercontent.com/Pozdniakov/tidy_stats/master/data/stcp-Rdataset-Diet.csv\")\n\n\nПосчитайте двухвыборочный зависимый т-тест для остальных диет: для диеты 2 и диеты 3. Проинтерпретируйте полученные результаты.\n\n\ndiet2 <- diet %>%\n  filter(Diet == 2)\nt.test(diet2$pre.weight, diet2$weight6weeks, paired = TRUE)\n\n\n    Paired t-test\n\ndata:  diet2$pre.weight and diet2$weight6weeks\nt = 6.231, df = 26, p-value = 1.36e-06\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n 2.027715 4.024137\nsample estimates:\nmean of the differences \n               3.025926 \n\n\np-value меньше .05, поэтому мы можем отклонить нулевую гипотезу о том, что масса до и после диеты одинаковая. Мы принимаем альтернативную гипотезу о различии средних в генеральной совокупности.\n\ndiet3 <- diet %>%\n  filter(Diet == 3)\nt.test(diet3$pre.weight, diet3$weight6weeks, paired = TRUE)\n\n\n    Paired t-test\n\ndata:  diet3$pre.weight and diet3$weight6weeks\nt = 11.167, df = 26, p-value = 2.03e-11\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n 4.200493 6.095803\nsample estimates:\nmean of the differences \n               5.148148 \n\n\np-value меньше .05, поэтому мы можем отклонить нулевую гипотезу о том, что масса до и после диеты одинаковая. Мы принимаем альтернативную гипотезу о различии средних в генеральной совокупности."
  },
  {
    "objectID": "920-solutions.html#ind_ttest_solutions",
    "href": "920-solutions.html#ind_ttest_solutions",
    "title": "25  Решения заданий",
    "section": "25.29 Двухвыборочный независимый t-test",
    "text": "25.29 Двухвыборочный независимый t-test\n\nСделайте независимый t-тест для сравнения веса испытуемых двух групп после диеты, сравнив вторую и третью группу. Проинтерпретируйте результаты.\n\n\ndiet23 <- diet %>%\n  filter(Diet %in% 2:3)\nt.test(weight6weeks ~ Diet, data = diet23, paired = FALSE)\n\n\n    Welch Two Sample t-test\n\ndata:  weight6weeks by Diet\nt = -0.15686, df = 49.774, p-value = 0.876\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -5.471327  4.678734\nsample estimates:\nmean in group 2 mean in group 3 \n       68.08519        68.48148 \n\n\np-value больше .05, поэтому мы не можем отклонить нулевую гипотезу о том, что масса до и после диеты одинаковая.\n\nСделайте независимый t-тест для сравнения веса испытуемых двух групп после диеты, сравнив первую и третью группу. Проинтерпретируйте результаты.\n\n\ndiet13 <- diet %>%\n  filter(Diet %in% c(1,3))\nt.test(weight6weeks ~ Diet, data = diet13, paired = FALSE)\n\n\n    Welch Two Sample t-test\n\ndata:  weight6weeks by Diet\nt = 0.46818, df = 48.072, p-value = 0.6418\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -3.602450  5.789487\nsample estimates:\nmean in group 1 mean in group 3 \n       69.57500        68.48148 \n\n\np-value больше .05, поэтому мы не можем отклонить нулевую гипотезу о том, что масса до и после диеты одинаковая."
  },
  {
    "objectID": "920-solutions.html#nonparam_ttest_solutions",
    "href": "920-solutions.html#nonparam_ttest_solutions",
    "title": "25  Решения заданий",
    "section": "25.30 Непараметрические аналоги t-теста",
    "text": "25.30 Непараметрические аналоги t-теста\n\nСравните вес первой и второй группы после диеты, используя тест Манна-Уитни. Сравните результаты теста Манна-Уитни с результатами t-теста? Проинтерпретируйте полученные результаты.\n\n\ndiet12 <- diet %>%\n  filter(Diet %in% c(1,2))\nwilcox.test(weight6weeks ~ Diet, data = diet12, paired = FALSE)\n\n\n    Wilcoxon rank sum test with continuity correction\n\ndata:  weight6weeks by Diet\nW = 368, p-value = 0.4117\nalternative hypothesis: true location shift is not equal to 0\n\n\nВ обоих случаях p-value больше 0.05, мы не можем отклонить нулевую гипотезу об отсутствии различий.\n\nПовторите задание для второй и третьей группы, а так же для первой и третьей группы.\n\n\nwilcox.test(weight6weeks ~ Diet, data = diet23, paired = FALSE)\n\n\n    Wilcoxon rank sum test with continuity correction\n\ndata:  weight6weeks by Diet\nW = 340.5, p-value = 0.6843\nalternative hypothesis: true location shift is not equal to 0\n\nwilcox.test(weight6weeks ~ Diet, data = diet13, paired = FALSE)\n\n\n    Wilcoxon rank sum test with continuity correction\n\ndata:  weight6weeks by Diet\nW = 346, p-value = 0.6849\nalternative hypothesis: true location shift is not equal to 0\n\n\nВ обоих случаях p-value больше 0.05, как и для соответствующих t-тестов. Мы не можем отклонить нулевую гипотезу об отстутствии различий между второй и третьей диетой, между первой и третьей диетой.\n\nСравните вес до и после для диеты 1, используя тест Уилкоксона. Сравните с результатами применения t-теста. Проинтерпретируйте полученные результаты.\n\n\ndiet1 <- diet %>%\n  filter(Diet == 1)\nwilcox.test(diet1$pre.weight, diet1$weight6weeks, paired = TRUE)\n\n\n    Wilcoxon signed rank test with continuity correction\n\ndata:  diet1$pre.weight and diet1$weight6weeks\nV = 299, p-value = 2.203e-05\nalternative hypothesis: true location shift is not equal to 0\n\n\nИ t-тест, и тест Уилкоксона дают p-value ниже 0.05. Мы можем отклонить нулевую гипотезу об отсутствии различий.\n\nСравните вес до и после для диеты 2 и диеты 3, используя тест Уилкоксона. Сравните с результатами применения t-теста. Проинтерпретируйте полученные результаты.\n\n\nwilcox.test(diet2$pre.weight, diet2$weight6weeks, paired = TRUE)\n\n\n    Wilcoxon signed rank test with continuity correction\n\ndata:  diet2$pre.weight and diet2$weight6weeks\nV = 313, p-value = 5.419e-05\nalternative hypothesis: true location shift is not equal to 0\n\nwilcox.test(diet3$pre.weight, diet3$weight6weeks, paired = TRUE)\n\n\n    Wilcoxon signed rank test with continuity correction\n\ndata:  diet3$pre.weight and diet3$weight6weeks\nV = 378, p-value = 5.912e-06\nalternative hypothesis: true location shift is not equal to 0\n\n\nВ обоих случаях и t-тест, и тест Уилкоксона дают p-value ниже 0.05. Мы можем отклонить нулевую гипотезу об отсутствии различий."
  },
  {
    "objectID": "920-solutions.html#chi_sq_solutions",
    "href": "920-solutions.html#chi_sq_solutions",
    "title": "25  Решения заданий",
    "section": "25.31 Критерий хи-квадрат Пирсона",
    "text": "25.31 Критерий хи-квадрат Пирсона\n\nСоздайте в heroes новую колонку is_human логического типа, в которой будет TRUE, если супергерой принадлежит расе (Race) \"Human\", и FALSE в случае если супергерой принадлежит другой расе.\n\n\nheroes %>%\n  mutate(is_human = Race == \"Human\")\n\n# A tibble: 734 × 12\n      X1 name          Gender `Eye color` Race     `Hair color` Height Publisher\n   <dbl> <chr>         <chr>  <chr>       <chr>    <chr>         <dbl> <chr>    \n 1     0 A-Bomb        Male   yellow      Human    No Hair         203 Marvel C…\n 2     1 Abe Sapien    Male   blue        Icthyo … No Hair         191 Dark Hor…\n 3     2 Abin Sur      Male   blue        Ungaran  No Hair         185 DC Comics\n 4     3 Abomination   Male   green       Human /… No Hair         203 Marvel C…\n 5     4 Abraxas       Male   blue        Cosmic … Black            NA Marvel C…\n 6     5 Absorbing Man Male   blue        Human    No Hair         193 Marvel C…\n 7     6 Adam Monroe   Male   blue        <NA>     Blond            NA NBC - He…\n 8     7 Adam Strange  Male   blue        Human    Blond           185 DC Comics\n 9     8 Agent 13      Female blue        <NA>     Blond           173 Marvel C…\n10     9 Agent Bob     Male   brown       Human    Brown           178 Marvel C…\n# … with 724 more rows, and 4 more variables: `Skin color` <chr>,\n#   Alignment <chr>, Weight <dbl>, is_human <lgl>\n\n\n\nПосчитайте долю женщин для \"Human\" и всех остальных (is_human равен TRUE и FALSE соответственно). Перед этим удалите все строчки с NA в переменных is_human и Gender.\n\n\nheroes %>%\n  mutate(is_human = Race == \"Human\") %>%\n  drop_na(is_human, Gender) %>%\n  group_by(is_human) %>%\n  summarise(mean(Gender == \"Female\"))\n\n# A tibble: 2 × 2\n  is_human `mean(Gender == \"Female\")`\n  <lgl>                         <dbl>\n1 FALSE                         0.241\n2 TRUE                          0.242\n\n\n\nСравните распределения частот для переменных is_human и Gender используя хи-квадрат Пирсона. Проинтерпретируйте результаты.\n\n\nheroes %>%\n  mutate(is_human = Race == \"Human\") %>%\n  drop_na(is_human, Gender) %>%\n  select(is_human, Gender) %>%\n  table() %>%\n  chisq.test(correct = FALSE)\n\n\n    Pearson's Chi-squared test\n\ndata:  .\nX-squared = 0.00037447, df = 1, p-value = 0.9846\n\n\nМы не можем отвергнуть нулевую гипотезу о независимости расы (Человек/не-человек) и пола.\n\nПостройте мозаичный график для переменных is_human и Gender.\n\n\nheroes %>%\n  mutate(is_human = Race == \"Human\") %>%\n  drop_na(is_human, Gender) %>%\n  select(is_human, Gender) %>%\n  table() %>%\n  mosaicplot(shade = TRUE)"
  },
  {
    "objectID": "920-solutions.html#backpack_solutions",
    "href": "920-solutions.html#backpack_solutions",
    "title": "25  Решения заданий",
    "section": "25.32 Исследование набора данных Backpack",
    "text": "25.32 Исследование набора данных Backpack\nДля следующих тем нам понадобится набор данных Backpack из пакета Stat2Data.\n\n#install.packages(\"Stat2Data\")\nlibrary(Stat2Data)\ndata(Backpack)\nback <- Backpack %>%\n  mutate(backpack_kg = 0.45359237 * BackpackWeight,\n         body_kg = 0.45359237 * BodyWeight)\n\n\nКак различается вес рюкзака в зависимости от пола? Кто весит больше?\n\n\nback %>%\n  group_by(Sex) %>%\n  summarise(mean(backpack_kg))\n\n# A tibble: 2 × 2\n  Sex    `mean(backpack_kg)`\n  <fct>                <dbl>\n1 Female                5.01\n2 Male                  5.63\n\n\n\nЕсли допустить, что выборка репрезентативна, то можно ли сделать вывод о различии по среднему весу рюкзаков в генеральной совокупности?\n\n\nt.test(backpack_kg ~ Sex, data = back)\n\n\n    Welch Two Sample t-test\n\ndata:  backpack_kg by Sex\nt = -1.1782, df = 86.25, p-value = 0.242\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -1.6892365  0.4320067\nsample estimates:\nmean in group Female   mean in group Male \n            5.006010             5.634625 \n\n\np-value больше .05, поэтому мы не можем отклонить нулевую гипотезу о том, что масса до и после диеты одинаковая.\n\nПовторите пунктs 2 и 3 для веса самих студентов.\n\n\nback %>%\n  group_by(Sex) %>%\n  summarise(mean(body_kg))\n\n# A tibble: 2 × 2\n  Sex    `mean(body_kg)`\n  <fct>            <dbl>\n1 Female            62.3\n2 Male              78.1\n\nt.test(body_kg ~ Sex, data = back)\n\n\n    Welch Two Sample t-test\n\ndata:  body_kg by Sex\nt = -7.0863, df = 77.002, p-value = 5.704e-10\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -20.32511 -11.40803\nsample estimates:\nmean in group Female   mean in group Male \n            62.28236             78.14893 \n\n\np-value меньше .05, поэтому мы можем отклонить нулевую гипотезу о том, что масса студентов-мужчин и студентов-женщин одинаковая. Мы принимаем альтернативную гипотезу о различии средних в генеральной совокупности.\n\nВизуализируйте распределение этих двух переменных в зависимости от пола (используя ggplot2)\n\n\nlibrary(ggplot2)\nggplot(back)+\n  geom_histogram(aes(x = body_kg, fill = Sex), bins = 15, position = \"identity\", alpha = 0.7)\n\n\n\n\n\nПостройте диаграмму рассеяния с помощью ggplot2. Цветом закодируйте пол респондента.\n\n\nggplot(back, aes(x = body_kg, y = backpack_kg))+\n  geom_point(aes(colour = Sex), alpha = 0.5, size = 2)"
  },
  {
    "objectID": "920-solutions.html#cov_solutions",
    "href": "920-solutions.html#cov_solutions",
    "title": "25  Решения заданий",
    "section": "25.33 Ковариация",
    "text": "25.33 Ковариация\n\nПосчитайте матрицу ковариаций для веса студентов и их рюкзаков в фунтах. Различаются ли результаты подсчета ковариации этих двух переменных от результатов подсчета ковариаций веса студентов и их рюкзаков в килограммах? Почему?\n\n\nback %>%\n  select(BodyWeight, BackpackWeight) %>%\n  cov()\n\n               BodyWeight BackpackWeight\nBodyWeight      864.20960       32.08788\nBackpackWeight   32.08788       33.23677\n\n\nРезультаты различаются, потому что значение ковариации зависит от размерности исходных шкал."
  },
  {
    "objectID": "920-solutions.html#cor_solutions",
    "href": "920-solutions.html#cor_solutions",
    "title": "25  Решения заданий",
    "section": "25.34 Коэффициент корреляции",
    "text": "25.34 Коэффициент корреляции\n\nПосчитайте коэффициент корреляции Пирсона для веса студентов и их рюкзаков в фунтах. Различаются ли результаты подсчета коэффициента корреляции Пирсона (сам коэффициент, p-value) этих двух переменных от результатов подсчета корреляции Пирсона веса студентов и их рюкзаков в килограммах? Почему?\n\n\ncor.test(back$BackpackWeight, back$BodyWeight)\n\n\n    Pearson's product-moment correlation\n\ndata:  back$BackpackWeight and back$BodyWeight\nt = 1.9088, df = 98, p-value = 0.05921\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n -0.007360697  0.371918344\nsample estimates:\n      cor \n0.1893312 \n\n\nРезультаты не различаются, потому что значение ковариации не зависит от размерности исходных шкал.\n\nПосчитайте коэффициент корреляции Пирсона для веса и роста супергероев из датасета heroes. Проинтерпретируйте результат.\n\n\ncor.test(heroes$Weight, heroes$Height)\n\n\n    Pearson's product-moment correlation\n\ndata:  heroes$Weight and heroes$Height\nt = 4.3555, df = 488, p-value = 1.619e-05\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.1066877 0.2772717\nsample estimates:\n      cor \n0.1934412 \n\n\np-value меньше 0.05, поэтому мы можем отклонить нулевую гипотезу об отсутствии линейной связи между ростом и весом и принять альтернативную гипотезу о том, что такая связь есть. Судя по знаку и размеру корреляции, чем выше рост, тем выше вес супергероя, но эта связь достаточно слабая.\n\nТеперь посчитайте коэффициент корреляции Спирмена и коэффициент корреляции Кэнделла для веса и роста супергероев из датасета heroes. Различаются ли результаты по сравнению с коэффициентом корреляции Пирсона? Почему?\n\n\ncor.test(heroes$Weight, heroes$Height, method = \"spearman\")\n\n\n    Spearman's rank correlation rho\n\ndata:  heroes$Weight and heroes$Height\nS = 3915061, p-value < 2.2e-16\nalternative hypothesis: true rho is not equal to 0\nsample estimates:\n      rho \n0.8003344 \n\n\n\ncor.test(heroes$Weight, heroes$Height, method = \"kendall\")\n\n\n    Kendall's rank correlation tau\n\ndata:  heroes$Weight and heroes$Height\nz = 21.548, p-value < 2.2e-16\nalternative hypothesis: true tau is not equal to 0\nsample estimates:\n      tau \n0.6751664 \n\n\nВ обоих случаях p-value меньше 0.05, поэтому мы можем отклонить нулевую гипотезу об отсутствии связи между ростом и весом и принять альтернативную гипотезу о том, что такая связь есть. Сильное различие между коэффициентами корреляции указывает на нелинейность этой связи, либо же на наличие значительных выбросов в данных."
  },
  {
    "objectID": "950-references.html",
    "href": "950-references.html",
    "title": "Анализ данных и статистика в R",
    "section": "",
    "text": "# Ссылки на литературу {-}"
  }
]