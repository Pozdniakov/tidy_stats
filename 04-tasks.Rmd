

# Задания {#tasks}

```{r include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

##Начало работы в R {#task_begin}

- Разделите 9801 на 9.

```{r}
9801/9
```

- Посчитайте логарифм от 8912162342 по основанию 6.

```{r}
log(2176782336, 6)
```

- Теперь натуральный логарифм 10 и умножьте его на 5.

```{r}
log(10)*5
```

- С помощью функции `sin()` посчитайте $\sin (\pi), \sin \left(\frac{\pi}{2}\right), \sin \left(\frac{\pi}{6}\right)$.

> Значение $\pi$ - зашитая в R константа (`pi`).

```{r}
sin(pi)
sin(pi/2)
sin(pi/6)
```

##Создание векторов {#task_new_vecs}

- Создайте вектор из значений 2, 30 и 4000.

```{r}
c(2, 30, 4000)
```

- Создайте вектор от 1 до 20.

```{r}
1:20
```

- Создайте вектор от 20 до 1.

```{r}
20:1
```

Функция `sum()` возвращает сумму элементов вектора на входе. Посчитайте сумму первых 100 натуральных чисел (т.е. всех целых чисел от 1 до 100).

```{r}
sum(1:100)
```

- Создайте вектор от 1 до 20 и снова до 1. Число 20 должно присутствовать только один раз!

```{r}
c(1:20, 19:1)
```

- Создайте вектор значений 5, 4, 3, 2, 2, 3, 4, 5:

```{r}
c(5:2, 2:5)
```

- Создайте вектор 2, 4, 6,  ... , 18, 20.

```{r}
seq(2, 20, 2)
```

- Создайте вектор 0.1, 0.2, 0.3, ..., 0.9, 1.

```{r}
seq(0, 1, 0.1)
```

- 2020 год --- високосный. Следующий високосный год через 4 года --- это будет 2024 год. Составьте календарь всех високосных годов XXI века, начиная с 2020 года.

> 2100 год относится к XXI веку, а не к XXII.

```{r}
seq(2020, 2100, 4)
```

- Создайте вектор, состоящий из 20 повторений "Хэй!".

```{r}
rep("Хэй!", 20)
```

- Как я и говорил, многие функции, работающие с одним значением на входе, так же прекрасно работают и с целыми векторами. Попробуйте посчитать квадратный корень чисел от 1 до 10 с помощью функции `sqrt()` и сохраните результат в векторе `roots`.

```{r}
roots <- sqrt(1:10)
roots
```

- Давайте убедимся, что это действительно квадратные корни. Для этого возведите все значения вектора `roots` в квадрат!

```{r}
roots ^ 2
```

- Если все верно, то того же самого можно добиться поэлементным умножением вектора `roots` на себя.

```{r}
roots * roots
```

- *Создайте вектор из одной единицы, двух двоек, трех троек, .... , девяти девяток.

```{r}
rep(1:9, 1:9)
```

## Приведение типов {#task_coer}

- Сделайте вектор `vec1`, в котором соедините `3`, а также значения `"Мой"` и `"вектор"`.

```{r}
vec1 <- c(3, "Мой", "вектор")
vec1
```

- Попробуйте вычесть `TRUE` из 10.

```{r}
10 - TRUE
```

- Соедините значение `10` и `TRUE` в вектор `vec2`.

```{r}
vec2 <- c(10, TRUE)
vec2
```

- Соедините вектор `vec2` и значение `"r"`:

```{r}
c(vec2, "r")
```

- Соедините значения `10`, `TRUE`, `"r"`  в вектор.

```{r}
c(10, TRUE, "r")
```

## Векторизация {#task_vec_ion}

- Создайте вектор `p`, состоящий из значений 4, 5, 6, 7, и вектор `q`, состоящий из 0, 1, 2, 3. 

```{r}
p <- 4:7
p
q <- 0:3
q
```

- Посчитайте поэлементную сумму векторов `p` и `q`:

```{r}
p + q
```

- Посчитайте поэлементную разницу `p` и `q`:

```{r}
p - q
```

- Поделите каждый элемент вектора `p` на соответствующий ему элемент вектора `q`:

> О, да, Вам нужно делить на 0!

```{r}
p / q
```

- Возведите каждый элемент вектора `p` в степень соответствующего ему элемента вектора `q`:

```{r}
p ^ q
```

- Умножьте каждое значение вектора `p` на 10.

```{r}
p * 10
```

- Создайте вектор квадратов чисел от 1 до 10:

```{r}
(1:10)^2
```

- Создайте вектор 0, 2, 0, 4, ... , 18, 0, 20.

```{r}
1:20 * 0:1
```

- Создайте вектор 1, 0, 3, 0, 5, ..., 17, 0, 19, 0.

```{r}
1:20 * 1:0
```

- *Создайте вектор, в котором будут содержаться первые 20 степеней двойки.

```{r}
2 ^ (1:20)
```

- *Создайте вектор из чисел 1, 10, 100, 1000, 10000:

```{r}
10 ^ (0:4)
```

- *Посчитать сумму последовательности $\frac{1}{1 \cdot 2}+\frac{1}{2 \cdot 3}+\frac{1}{3 \cdot 4}+\ldots+\frac{1}{50 \cdot 51}$.

```{r}
sum(1 / (1:50 * 2:51))
```

- *Посчитать сумму последовательности $\frac{1}{2^{0}}+\frac{1}{2^{1}}+\frac{1}{2^{2}}+\frac{1}{2^{3}}+\ldots \frac{1}{2^{20}}$.

```{r}
sum(1 / 2 ^ (0:20))
```

- *Посчитать сумму последовательности $1+\frac{4}{3}+\frac{7}{9}+\frac{10}{27}+\frac{13}{81}+\ldots+\frac{28}{19683}$.

```{r}
sum((3 * (1:10) - 2) / 3 ^ (0:9))
```

- *Сколько чисел из последовательности $1+\frac{4}{3}+\frac{7}{9}+\frac{10}{27}+\frac{13}{81}+\ldots+\frac{28}{19683}$ больше чем 0.5?

```{r}
sum((3 * (1:10) - 2) / 3 ^ (0:9) > 0.5)
```

## Индексирование векторов {#task_vec_ind}

- Создайте вектор `troiki` со значениями 3, 6, 9, ..., 24, 27.

```{r}
troiki <- seq(3, 27, 3)
troiki
```

- Извлеките 2, 5 и 7 значения вектора `troiki`.

```{r}
troiki[c(2, 5, 7)]
```

- Извлеките предпоследнее значение вектора `troiki`.

```{r}
troiki[length(troiki) - 1]
```

- Извлеките все значения вектора `troiki` *кроме* предпоследнего:

```{r}
troiki[-(length(troiki) - 1)]
```

Создайте вектор `vec3`:

```{r, echo = TRUE}
vec3 <- c(3, 5, 2, 1, 8, 4, 9, 10, 3, 15, 1, 11)
```

- Найдите второй элемент вектора `vec3`.

```{r}
vec3[2]
```

- Верните второй и пятый элемент вектора `vec3`.

```{r}
vec3[c(2, 5)]
```

- Попробуйте извлечь сотое значение вектора `vec3`:

```{r}
vec3[100]
```

- Верните все элементы вектора `vec3` *кроме* второго элемента.

```{r}
vec3[-2]
```

- Верните все элементы вектора `vec3` *кроме* второго и пятого элемента.

```{r}
vec3[c(-2, -5)]
```

- Найдите последний элемент вектора `vec3`.

```{r}
vec3[length(vec3)]
```

- Верните все значения вектора `vec3` кроме первого и последнего.

```{r}
vec3[c(-1, -length(vec3))]
```

- Найдите все значения вектора `vec3`, которые больше 4.

```{r}
vec3[vec3 > 4]
```

- Найдите все значения вектора `vec3`, которые больше 4, но меньше 10.

> Если хотите сделать это в одну строчку, то вам помогут логические операторы!

```{r}
vec3[vec3 > 4 & vec3 < 10]
```

- Найдите все значения вектора `vec3`, которые меньше 4 или больше 10.

```{r}
vec3[vec3 < 4 | vec3 > 10]
```

- Возведите в квадрат каждое значение вектора `vec3`.

```{r}
vec3 ^ 2
```

- *Возведите в квадрат каждое значение вектора на нечетной позиции и извлеките корень из каждого значения на четной позиции вектора `vec3`.

> Извлечение корня - это то же самое, что и возведение в степень 0.5.

```{r}
vec3 ^ c(2, 0.5)
```

- Создайте вектор 2, 4, 6,  ... , 18, 20 как минимум 2 новыми способами.

> Знаю, это задание может показаться бессмысленным, но это очень базовая операция, с помощью которой можно, например, разделить данные на две части. Чем больше способов Вы знаете, тем лучше!

```{r}
(1:20)[c(FALSE,TRUE)]
#(1:10)*2
```

##Работа с пропущенными значениями {#task_na}

- Создайте вектор `vec4` со значениями 300, 15, 8, 2, 0, 1, 110:

```{r, echo = TRUE}
vec4 <- c(300, 15, 8, 20, 0, 1, 110)
vec4
```

- Замените все значения `vec4`, которые больше 20 на `NA`.

```{r}
vec4[vec4 > 20] <- NA
```

- Проверьте полученный вектор `vec4`:

```{r}
vec4
```

- Посчитайте сумму `vec4` с помощью функции `sum()`. Ответ `NA` не считается!

```{r}
sum(vec4, na.rm = TRUE)
```

## Матрицы {#task_matrix}

- Создайте матрицу 4х4, состоящую из единиц. Назовите ее `M1`.

```{r}
M1 <- matrix(rep(1, 16), ncol = 4)
M1
```

- Поменяйте все некрайние значения матрицы `M1` (то есть значения на позициях [2,2], [2,3], [3,2] и [3,3]) на число 2.

```{r}
M1[2:3, 2:3] <- 2
M1
```

- Выделите второй и третий столбик из матрицы `M1`.

```{r}
M1[,2:3]
```

- Сравните (`==`) вторую колонку и вторую строчку матрицы `M1`.

```{r}
M1[,2] == M1[2,]
```

- *Создайте таблицу умножения (9х9) в виде матрицы. Сохраните ее в переменную `mult_tab`.

```{r}
mult_tab <- matrix(rep(1:9, rep(9,9))*(1:9), nrow = 9)
mult_tab

#Еще
#outer(1:9, 1:9, "*")
#1:9 %o% 1:9
```

- *Из матрицы `mult_tab` выделите подматрицу, включающую в себя только строчки с 6 по 8 и столбцы с 3 по 7.

```{r}
mult_tab[6:8, 3:7]
```

- *Создайте матрицу с логическими значениями, где `TRUE`, если в этом месте в таблице умножения (`mult_tab`) двузначное число и `FALSE`, если однозначное.

> Матрица - это почти вектор. К нему можно обращаться с единственным индексом.

```{r}
mult_tab >= 10
```

- *Создайте матрицу `mult_tab2`, в которой все значения `tab` меньше 10 заменены на 0.

```{r}
mult_tab2 <- mult_tab
mult_tab2[mult_tab < 10] <- 0
mult_tab2
```

## Списки {#task_list}

Дан список `list1`:

```{r, echo = TRUE}
list1 = list(numbers = 1:5, letters = letters, logic = TRUE)
list1
```

- Найдите первый элемент списка `list1`. Ответ должен быть списком длиной один.

```{r}
list1[1]
```

- Теперь найдите содержание первого элемента списка `list1` двумя разными способами. Ответ должен быть вектором.

```{r}
list1[[1]]
list1$numbers
```

- Теперь возьмите первый элемент содержания первого элемента списка `list1`. Ответ должен быть вектором.

```{r}
list1[[1]][1]
```

- Создайте список `list2`, содержащий в себе два списка `list1`. Один из них будет иметь имя `pupa`, а другой --- `lupa`.

```{r}
list2 = list(pupa = list1, lupa = list1)
list2
```

- *Извлеките первый элемент списка `list2`, из него --- второй полэлемент, а из него --- третье значение.

```{r}
list2[[1]][[2]][3]
```

## Датафрейм {#task_df}

- Запустите команду `data(mtcars)` чтобы загрузить встроенный датафрейм с информацией про автомобили. Каждая строчка датафрейма - модель автомобиля, каждая колонка - отдельная характеристика. Подробнее см. `?mtcars`.

```{r, echo = TRUE}
data(mtcars)
mtcars
```

- Изучите структуру датафрейма `mtcars` с помощью функции `str()`.

```{r}
str(mtcars)
```

- Найдите значение третьей строчки четвертого столбца датафрейма `mtcars`.

```{r}
mtcars[3, 4]
```

- Извлеките первые шесть строчек и первые шесть столбцов датафрейма `mtcars`.

```{r}
mtcars[1:6, 1:6]
```

- Извлеките колонку `wt` датафрейма `mtcars` - массу автомобиля в тысячах фунтов.

```{r}
mtcars$wt
```

- Извлеките колонки из `mtcars` в следующем порядке: `hp`, `mpg`, `cyl`.

```{r}
mtcars[, c("hp", "mpg", "cyl")]
```

- Посчитайте *количество* автомобилей с 4 цилиндрами (`cyl`) в датафрейме `mtcars`.

```{r}
sum(mtcars$cyl == 4)
```

- Посчитайте *долю* автомобилей с 4 цилиндрами (`cyl`) в датафрейме `mtcars`.

```{r}
mean(mtcars$cyl == 4)
```

- Найдите все автомобили мощностью не менее 100 лошадиных сил (`hp`) в датафрейме `mtcars`.

```{r}
mtcars[mtcars$hp >= 100, ]
```

- Найдите все автомобили мощностью не менее 100 лошадиных сил (`hp`) и 4 цилиндрами (`cyl`) в датафрейме `mtcars`.

```{r}
mtcars[mtcars$hp >= 100 & mtcars$cyl == 4, ]
```

- Посчитайте максимальную массу (`wt`) автомобиля в выборке, воспользовавшись функцией `max()`:

```{r}
max(mtcars$wt)
```

- Посчитайте максимальную массу (`wt`) автомобиля в выборке, воспользовавшись функцией `min()`:

```{r}
min(mtcars$wt)
```

- Найдите строчку датафрейма `mtcars` с самым легким автомобилем.

```{r}
mtcars[mtcars$wt == min(mtcars$wt), ]
```

- Извлеките строчки датафрейма `mtcars` с автомобилями, масса которых ниже средней массы.

```{r}
mtcars[mtcars$wt < mean(mtcars$wt), ]
```

- Масса автомобиля указана в тысячах фунтов. Создайте колонку `wt_kg` с массой автомобиля в килограммах. Результат округлите до целых значений с помощью функции `round()`.

> 1 фунт = 0.45359237 кг.

```{r}
mtcars$wt_kg <- round(mtcars$wt * 1000 * 0.45359237)
mtcars
```


## Условные конструкции {#task_if}

- Создайте вектор `vec5`:

```{r, echo = TRUE}
vec5 <- c(5, 20, 30, 0, 2, 9)
```

- Создайте новый строковый вектор, где на месте чисел больше 10 в `vec5` будет стоять "большое число", а на месте остальных чисел --- "маленькое число".

```{r}
ifelse(vec5 > 10, "большое число", "маленькое число")
```

- Загрузите файл heroes_information.csv в переменную `heroes`.

```{r, echo = TRUE}
heroes <- read.csv("data/heroes_information.csv", 
                   stringsAsFactors = FALSE,
                   na.strings = c("-", "-99"))
```

- Создайте новою колонку `hair` в `heroes`, в которой будет значение `"Bold"` для тех супергероев, у которых в колонке `Hair.color` стоит `"No Hair"`, и значение `"Hairy"` во всех остальных случаях.

```{r}
heroes$hair <- ifelse(heroes$Hair.color == "No Hair", "Bold", "Hairy")
head(heroes)
```

- Создайте новою колонку `tall` в `heroes`, в которой будет значение `"tall"` для тех супергероев, у которых в колонке `Height` стоит число больше 190, значение `"short"` для тех супергероев, у которых в колонке `Height` стоит число меньше 170, и значение `"middle"` во всех остальных случаях.

```{r}
# heroes$tall <- dplyr::case_when(
#   heroes$Height > 190 ~ "tall",
#   heroes$Height < 170 ~ "short",
#   TRUE ~ "middle"
# )
heroes$tall <- ifelse(heroes$Height > 190, 
                      "tall",
                      ifelse(heroes$Height < 170,
                             "short",
                             "middle"))
```

## Создание функций {#task_function}

- Создайте функцию `plus_one()`, которая принимает число и возвращает это же число + 1.

```{r}
plus_one <- function(x) x + 1
```

- Проверьте функцию `plus_one()` на числе 41.

```{r, echo = TRUE}
plus_one(41)
```

- Создайте функцию `circle_area`, которая вычисляет площадь круга по радиусу согласно формуле $\pi r^2$.

```{r}
circle_area <- function(r) pi * r ^ 2
```

- Посчитайте площадь круга с радиусом 5.

```{r}
circle_area(5)
```

- Создайте функцию `cels2fahr()`, которая будет превращать градусы по Цельсию в градусы по Фаренгейту.

```{r}
cels2fahr <- function(x) x * 9 / 5 + 32
```

- Проверьте на значениях -100, -40 и 0, что функция `cels2fahr()` работает корректно.

```{r, echo = TRUE}
cels2fahr(c(-100, -40, 0))
```

- Напишите функцию `highlight()`, которая принимает на входе строковый вектор, а возвращает тот же вектор, но дополненный значением `"***"` в начале и конце вектора. Лучше всего это рассмотреть на примере:

```{r}
highlight <- function(x) c("***", x, "***")
```

```{r, echo = TRUE}
highlight(c("Я", "Бэтмен!"))
```

- Теперь сделайте функцию `highlight` более гибкой. Добавьте в нее параметр `wrapper =`, который по умолчанию равен `"***"`. Значение параметра `wrapper =` и будет вставлено в начало и конец вектора.

```{r}
highlight <- function(x, wrapper = "***") c(wrapper, x, wrapper)
```

- Проверьте написанную функцию на векторе `c("Я", "Бэтмен!")`.

```{r, echo = TRUE}
highlight(c("Я", "Бэтмен!")) 
highlight(c("Я", "Бэтмен!"), wrapper = "__") 
```

- Создайте функцию `trim()`, которая будет возвращать вектор без первого и последнего значения (вне зависимости от типа данных).

```{r}
trim <- function(x) x[c(-1, -length(x))]
```

- Проверьте, что функция `trim()` работает корректно:

```{r, echo = TRUE}
trim(1:7)
trim(letters)
```

- Теперь добавьте в функцию `trim()` параметр `n =` со значением по умолчанию 1. Этот параметр будет обозначать сколько значений нужно отрезать слева и справа от вектора.

```{r}
trim <- function(x, n = 1) x[c(-1:-n, (-length(x)+n-1):-length(x))]
```

- Проверьте полученную функцию:

```{r, echo = TRUE}
trim(letters)
trim(letters, n = 2)
```

- Сделайте так, чтобы функция `trim()` работала корректно с `n = 0`, т.е. функция возвращала бы исходный вектор без изменений.

```{r}
trim <- function(x, n = 1) {
  if (n == 0) return(x)
  x[c(-1:-n, (-length(x)+n-1):-length(x))]
}
```

```{r, echo = TRUE}
trim(letters, n = 0)
```

- *Теперь добавьте проверку на адекватность входных данных: функция `trim()` должна выдавать ошибку, если `n =` меньше нуля или если `n =` слишком большой и отрезает все значения вектора:

```{r}
trim <- function(x, n = 1) {
  if (n < 0) stop("n не может быть меньше нуля!")
  l <- length(x)
  if (n > ceiling(l/2) - 1) stop("n слишком большой!")
  if (n == 0) return(x)
  x[c(-1:-n, (-l+n-1):-l)]
}
```

- *Проверьте полученную функцию `trim()`:

```{r, error = TRUE, echo = TRUE}
trim(1:6, 3)
trim(1:6, -1)
```

- Создайте функцию `na_n()`, которая будет возвращать количество `NA` в векторе.

```{r}
na_n <- function(x) sum(is.na(x))
```

- Проверьте функцию `na_n()` на векторе:

```{r, echo = TRUE}
na_n(c(NA, 3:5, NA, 2, NA))
```

- Напишите функцию `factors()`, которая будет возвращать все делители числа в виде числового вектора.

> Здесь может понадобиться оператор для получения остатка от деления: `%%`.

```{r}
factors <- function(x) (1:x)[x %% (1:x) == 0]
```

- Проверьте функцию `factors()` на простых и сложных числах:

```{r, echo = TRUE}
factors(3)
factors(161)
factors(1984)
```

- *Напишите функцию `is_prime()`, которая проверяет, является ли число простым.

> Здесь может пригодиться функция `any()` - она возвращает `TRUE`, если в векторе есть хотя бы один `TRUE`.

```{r}
is_prime <- function(x) !any(x%%(2:(x-1)) == 0)
#is_prime <- function(x) length(factors(x)) == 2 #Используя уже написанную функцию factors()
``` 

- Проверьте какие года были для нас простыми, а какие нет:

```{r, echo = TRUE}
is_prime(2017)
is_prime(2019)
2019/3 #2019 делится на 3 без остатка
is_prime(2020)
is_prime(2021)
```

- *Создайте функцию `monotonic()`, которая возвращает `TRUE`, если значения в векторе не убывают (то есть каждое следующее - больше или равно предыдущему) или не возврастают.

> Полезная функция для этого --- `diff()` --- возвращает разницу соседних значений.

```{r}
monotonic <- function(x) all(diff(x)>=0) | all(diff(x)<=0)
```

```{r, echo = TRUE}
monotonic(1:7)
monotonic(c(1:5,5:1))
monotonic(6:-1)
monotonic(c(1:5, rep(5, 10), 5:10))
```

Бинарные операторы типа `+` или `%in%` тоже представляют собой функции. Более того, мы можем создавать свои бинарные операторы! В этом нет особой сложности --- нужно все так же создавать функцию (для двух переменных), главное окружать их `%` и название обрамлять обратными штрихами \`. Например, можно сделать свой бинарный оператор `%notin%`, который будет выдавать `TRUE`, если значения слева *нет* в векторе справа:

```{r, echo = TRUE}
`%notin%` <- function(x, y) ! (x %in% y)
1:10 %notin% c(1, 4, 5)
```

- *Создайте бинарный оператор `%without%`, который будет возвращать все значения вектора слева без значений вектора справа. 

```{r}
`%without%` <- function(x, y) x[!x %in% y]
```

```{r, echo = TRUE}
c("а", "и", "б", "сидели", "на", "трубе") %without% c("а", "б")
```

- *Создайте бинарный оператор `%between%`, который будет возвращать `TRUE`, если значение в векторе слева накходится в _диапазоне_ значений вектора справа:

```{r}
`%between%` <- function(x, y) x >= min(y) & x <= max(y)
```

```{r, echo = TRUE}
1:10 %between% c(1, 4, 5)
```

## Семейство функций apply() {#task_apply}

- Создайте матрицу `M2`:

```{r, echo = TRUE}
M2 <- matrix(c(20:11, 11:20), nrow = 5)
M2
```

- Посчитайте максимальное значение матрицы `M2` по каждой строчке.

```{r}
apply(M2, 1, max)
```

- Посчитайте максимальное значение матрицы `M2` по каждому столбцу.

```{r}
apply(M2, 2, max)
```

- Посчитайте среднее значение матрицы `M2` по каждой строке.

```{r}
apply(M2, 1, mean)
```

- Посчитайте среднее значение матрицы `M2` по каждому столбцу.

```{r}
apply(M2, 2, mean)
```

- Создайте список `list3`:

```{r, echo = TRUE}
list3 <- list(
  a = 1:5,
  b = 0:20,
  c = 4:24,
  d = 6:3,
  e = 6:25
  )
```

- Найдите максимальное значение каждого вектора списка `list3`.

```{r}
sapply(list3, max)
```

- Посчитайте сумму каждого вектора списка `list3`.

```{r}
sapply(list3, sum)
```

- Посчитайте длину каждого вектора списка `list3`.

```{r}
sapply(list3, length)
```

- Напишите функцию `max_item()`, которая будет принимать на входе список, а возвращать - (первый) самый длинный его элемент.

> Для этого вам может понадобиться функция `which.max()`, которая возвращает индекс максимального значения (первого, если их несколько).

```{r}
max_item <- function (x) x[[which.max(sapply(x, length))]]
```

- Проверьте функцию `max_item()` на списке `list3`. 

```{r, echo = TRUE}
max_item(list3)
```

- Теперь мы сделаем сложный список `list4`:

```{r, echo = TRUE}
list4 <- list(1:3, 3:40, list3)
```

- Посчитайте длину каждого вектора в списке, в т.ч. для списка внутри. Результат должен быть списком с такой же структорой, как и изначальный список `list4`.

> Для этого может понадобиться функция `rapply()`: **recursive lapply**

```{r}
rapply(list4, length, how = "list")
```

- *Загрузите набор данных `heroes` и посчитайте, сколько `NA` в каждом из столбцов.

> Для этого удобно использовать ранее написанную функцию `na_n()`.

```{r}
sapply(heroes, na_n)
```

- *Используя ранее написанную функцию `is_prime()`, напишите функцию `prime_numbers()`, которая будет возвращать все простые числа до выбранного числа.

```{r}
is_prime <- function(x) !any(x %% (2:(x - 1)) == 0)
prime_numbers <- function(x) (2:x)[sapply(2:x, is_prime)]
```

```{r, echo = TRUE}
prime_numbers(200)
```


```{r}
library(tidyverse)
heroes <- read_csv("data/heroes_information.csv",
                   na = c("-", "-99"))
powers <- read_csv("data/super_hero_powers.csv")
```



## magrittr::`%>%` {#task_pipe}

- Перепишите следующие выражения, используя `%>%`:

```{r, echo = TRUE}
sqrt(sum(1:10))
```

```{r}
1:10 %>%
  sum() %>%
  sqrt()
```


```{r, echo = TRUE}
abs(min(-5:5))
```

```{r}
-5:5 %>%
  min() %>%
  abs()
```

```{r, echo = TRUE}
c("Корень из", 2, "равен", sqrt(2))
```

```{r}
2 %>% c("Корень из", ., "равен", sqrt(.))
```


##Выбор строк: `dplyr::slice()` и `dplyr::filter()` {#task_filt}

- Выберите только те строчки, в которых содержится информация о супергероях тяжелее 500 кг.

```{r}
heroes %>% 
  filter(Weight > 500)
```

- Выберите только те строчки, в которых содержится информация о *женщинах*-супергероях тяжелее 500 кг.

```{r}
heroes %>% 
  filter(Weight > 500 & Gender == "Female")
```

- Выберите только те строчки, в которых содержится информация о супергероях человеческой расы (`"Human"`) женского пола. Из этих супергероев возьмите первые 5.

```{r}
heroes %>% 
  filter(Race == "Human" & Gender == "Female") %>%
  slice(1:5)
```

##Выбор столбцов: `dplyr::select()` {#task_select}

- Выберете первые 4 столбца в `powers`.

```{r}
powers %>%
  select(1:4)
```

- Выберите все столбцы от `Reflexes` до `Empathy` в тиббле `powers`:

```{r}
powers %>%
  select(Reflexes:Empathy)
```

- Выберите все столбцы тиббла `powers` кроме первого (`hero_names`):

```{r}
powers %>%
select(!hero_names)
```

## Сортировка строк: `dplyr::arrange()` {#task_arr}

- Выберите из тиббла `heroes` колонки `name`, `Gender`, `Height` и отсортируйте строчки *по возрастанию* `Height`.

```{r}
heroes %>%
  select(name, Gender, Height) %>%
  arrange(Height)
```

- Выберите из тиббла `heroes` колонки `name`, `Gender`, `Height` и отсортируйте строчки *по убыванию* `Height`.

```{r}
heroes %>%
  select(name, Gender, Height) %>%
  arrange(desc(Height))
```


- Выберите из тиббла `heroes` колонки `name`, `Gender`, `Height` и отсортируйте строчки сначала по `Gender`, затем *по убыванию* `Height`.


```{r}
heroes %>%
  select(name, Gender, Height) %>%
  arrange(Gender, desc(Height))
```

## Уникальные значения: `dplyr::distinct()` {#task_dist}

- Извлеките уникальные значения столбца `Eye color` из тиббла `heroes`.

```{r}
heroes %>%
  distinct(`Eye color`)
```

- Извлеките уникальные значения столбца `Hair color` из тиббла `heroes`.

```{r}
heroes %>%
  distinct(`Hair color`)
```

## Создание колонок: `dplyr::mutate()` и `dplyr::transmute()` {#task_mutate}

- Создайте колонку `height_m` с ростом супергероев в метрах, затем выберите только колонки `name` и `height_m`.

```{r}
heroes %>%
  mutate(height_m = Height/100) %>%
  select(name, height_m)
```

- Создайте новою колонку `hair` в heroes, в которой будет значение `"Bold"` для тех супергероев, у которых в колонке `Hair.color` стоит `"No Hair"`, и значение `"Hairy"` во всех остальных случаях. Затем выберите только колонки `name`, `Hair color`, `hair`.

```{r}
heroes %>%
  mutate(hair = ifelse(`Hair color` == "No Hair", "Bold", "Hairy")) %>%
  select(name, `Hair color`, hair)
```

## Агрегация: `dplyr::group_by() %>% summarise()` {#task_group_by}

- Посчитайте количество супергероев по расам и отсортируйте по убыванию. Извлеките первые 5 строк.

```{r}
heroes %>%
  count(Race, sort = TRUE) %>%
  slice(1:5)
```

- Посчитайте средний пост по полу.

```{r}
heroes %>%
  group_by(Gender) %>%
  summarise(height_mean = mean(Height, na.rm = TRUE))
```

## Операции с несколькими колонками: `across()` {#task_across}

- Посчитайте количество `NA` в каждой колонке, группируя по полу (`Gender`).

```{r}
na_n <- function(x) sum(is.na(x))
heroes %>%
  group_by(Gender) %>%
  summarise(across(everything(), na_n))
```

- Посчитайте количество `NA` в каждой колонке, которая заканчивается на `"color"`, группируя по полу (`Gender`).

```{r}
na_n <- function(x) sum(is.na(x))
heroes %>%
  group_by(Gender) %>%
  summarise(across(ends_with("color"), na_n))
```

- Создайте из тиббла `heroes` новый тиббл с колонками `name`, `Height` и `Weight`, где для каждого героя содержится значение `"выше среднего"`, если его рост или вес выше среднего по колонке и `"ниже среднего"`, если ниже или равен среднему.

```{r}
higher_than_average <- function(x) ifelse(x > mean(x, na.rm = TRUE),
                                          "выше среднего",
                                          "ниже среднего")
heroes %>%
  transmute(name, 
            across(c(Height, Weight), 
                   higher_than_average))
```

- Создайте из тиббла `heroes` новый тиббл с колонками `Gender`, `name`, `Height` и `Weight`, где для каждого героя содержится значение `"выше среднего"`, если его рост или вес выше среднего по колонке и `"ниже среднего"`, если ниже или равен среднему *внутри соответствующей группы по полу*.

```{r}
heroes %>%
  group_by(Gender) %>%
  transmute(name, 
            across(c(Height, Weight), 
                   higher_than_average))
```

## Соединение датафреймов: *_join {#task_join}

- Создайте тиббл `web_creators`, в котором будут супергерои, которые могут плести паутину, т.е. у них стоит `TRUE` в колонке `Web Creation` в тиббле `powers`.

```{r}
powers_web <- powers %>%
  select(hero_names, `Web Creation`)
web_creators <- left_join(heroes, powers_web, by = c("name" = "hero_names")) %>%
  filter(`Web Creation`)
web_creators
```

- Найдите всех супергероев, которые присутствуют в `heroes`, но отсутствуют в `powers`. Ответом должен быть строковый вектор с именами супергероев.

```{r}
anti_join(heroes, powers, by = c("name" = "hero_names")) %>%
  pull(name)
```

- Найдите всех супергероев, которые присутствуют в `powers`, но отсутствуют в `heroes`. Ответом должен быть строковый вектор с именами супергероев.

```{r}
anti_join(powers, heroes, by = c("hero_names" = "name")) %>%
  pull(hero_names)
```

## Tidy data {#task_join}

- Для начала создайте тиббл `heroes_weight`, скопировав код:

```{r, echo = TRUE}
heroes_weight <- heroes %>%
  filter(Publisher %in% c("DC Comics", "Marvel Comics")) %>%
  group_by(Gender, Publisher) %>%
  summarise(weight_mean = mean(Weight, na.rm = TRUE)) %>%
  drop_na()
heroes_weight 
```

> Функция `drop_na()` позволяет выбросить все строчки, в которых встречается `NA`.

- Превратите тиббл `heroes_weight` в широкий тиббл:

```{r}
heroes_weight %>%
  pivot_wider(names_from = "Publisher", values_from = "weight_mean")
```

- Затем превратите его обратно в длинный тиббл:

```{r}
heroes_weight %>%
  pivot_wider(names_from = "Publisher", values_from = "weight_mean") %>%
  pivot_longer(cols = !Gender,
               names_to = "Publisher",
               values_to = "weight_mean")
```

- Сделайте `powers` длинным тибблом с тремя колонками: `hero_names`, `power` (названгие суперсилы) и `has` (наличие суперсилы у данного супергероя).

```{r}
powers %>%
  pivot_longer(cols = !hero_names,
               names_to = "power",
               values_to = "has")
```

- Сделайте тиббл `powers` обратно широким, но с новой структурой: каждая строчка означает суперсилу, а каждая колонка - супергероя (за исключением первой колонки - названия суперсилы).

```{r}
powers %>%
  pivot_longer(cols = !hero_names,
               names_to = "power",
               values_to = "has") %>%
  pivot_wider(names_from = hero_names,
              values_from = has)
```

