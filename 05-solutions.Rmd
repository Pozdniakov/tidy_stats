# Решения_заданий {#solutions}

```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## Вектор {#solvvec_task_1}

- Посчитайте логарифм от 8912162342 по основанию 6

```{r}
log(8912162342, 6)

```

- Теперь натуральный логарифм 10 и умножьте его на 5

```{r}
log(10)*5
```

- Создайте вектор от 1 до 20

```{r}
1:20
```

- Создайте вектор от 20 до 1

```{r}
20:1
```

- Создайте вектор от 1 до 20 и снова до 1. Число 20 должно присутствовать только один раз!

```{r}
c(1:20, 19:1)
```

- Создайте вектор 2, 4, 6,  ... , 18, 20

```{r}
seq(2,20, 2)
```

- Создайте вектор из одной единицы, двух двоек, трех троек, .... , девяти девяток

```{r}
rep(1:9, 1:9)
```

- Сделайте вектор vec, в котором соедините `3`, а также значения `"Мой"` и `"вектор"`.

```{r}
vec <- c(3, "Мой", "вектор")
vec
```

- Вычесть `TRUE` из 10

```{r}
10 - TRUE
```

- Соедините значение `10` и `TRUE` в вектор `vec`

```{r}
vec <- c(10, TRUE)
vec
```

- Соедините вектор `vec` и значение `"r"`:

```{r}
c(vec, "r")
```

- Соедините значения `10`, `TRUE`, `"r"`  в вектор.

```{r}
c(10, TRUE, "r")
```

## Вектор. Операции с векторами {#solvvec_op}

Создайте вектор `p`, состоящий из значений 4, 5, 6, 7, и вектор `q`, состоящий из 0, 1, 2, 3. 

```{r}
p <- 4:7
p
q <- 0:3
q
```

Посчитайте поэлементную сумму векторов `p` и `q`:

```{r}
p + q
```

Посчитайте поэлементную разницу `p` и `q`:

```{r}
p - q
```

Поделите каждый элемент вектора `p` на соответствующий ему элемент вектора `q`:

> О, да, Вам нужно делить на 0!

```{r}
p/q
```

Возведите каждый элемент вектора `p` в степень соответствующего ему элемента вектора `q`:

```{r}
p^q
```


Создайте вектор квадратов чисел от 1 до 10:

```{r}
(1:10)^2
```

Создайте вектор 0, 2, 0, 4, ... , 18, 0, 20

```{r}
1:20 * 0:1
```

## Вектор. Индексирование {#solvvec_task_2}

Создайте вектор `vec1`:

```{r, echo = TRUE}
vec1 <- c(3, 5, 2, 1, 8, 4, 9, 10, 3, 15, 1, 11)
```

- Найдите второй элемент вектора `vec1`:

```{r}
vec1[2]
```

- Найдите последний элемент вектора `vec1`

```{r}
vec1[length(vec1)]
```

- Найдите все значения вектора `vec1`, которые больше 4

```{r}
vec1[vec1>4]
```

- Найдите все значения вектора vec1, которые больше 4, но меньше 10

```{r}
vec1[vec1>4 & vec1<10]
```

- Возведите в квадрат каждое значение вектора `vec1`

```{r}
vec1^2
```

- Возведите в квадрат каждое значение вектора на нечетной позиции и извлеките корень из каждого значения на четной позиции вектора `vec1`

```{r}
vec1 ^ c(2, 0.5)
```

- Создайте вектор `vec2`, в котором будут значения все значения `vec1`, которые меньше 10 будут заменены на `NA`.

```{r}
vec2 <- vec1
vec2[vec2<10] <- NA
vec2
```


- Посчитайте сумму `vec2` с помощью функции `sum()`. Ответ `NA` не считается!

```{r}
sum(vec2, na.rm = TRUE)
```

- Создайте вектор 2, 4, 6,  ... , 18, 20 как минимум 2 новыми способами

> Знаю, это задание может показаться бессмысленным, но это очень базовая операция, с помощью которой можно, например, разделить данные на две части. Чем больше способов Вы знаете, тем лучше!

```{r}
(1:20)[c(F,T)]
#(1:10)*2
```

## Матрицы {#solvt}

- Создайте матрицу 4х4, состоящую из единиц. Назовите ее `M`

```{r}
M <- matrix(rep(1, 16), ncol = 4)
M
```

- Поменяйте все некрайние значения матрицы `M` (то есть значения на позициях [2,2], [2,3], [3,2] и [3,3]) на число 2.

```{r}
M[2:3, 2:3] <- 2
M
```

- Выделите второй и третий столбик из матрицы `M`

```{r}
M[,2:3]
```

- Сравните (`==`) вторую колонку и вторую строчку матрицы `M`
```{r}
M[,2] == M[2,]
```


- Создайте таблицу умножения (9х9) в виде матрицы. Сохраните ее в переменную `tab`:

```{r}
tab <- matrix(rep(1:9, rep(9,9))*(1:9), nrow = 9)
tab

#Еще
#outer(1:9, 1:9, "*")
#1:9 %o% 1:9
```

- Из матрицы `tab` выделите подматрицу, включающую в себя только строчки с 6 по 8 и столбцы с 3 по 7.

```{r}
tab[6:8, 3:7]
```

- Создайте матрицу с логическими значениями, где `TRUE`, если в этом месте в таблице умножения (`tab`) двузначное число и `FALSE`, если однозначное.

> Матрица - это почти вектор. К нему можно обращаться с единственным индексом.

```{r}
tab>=10
```

- Создайте матрицу `tab2`, в которой все значения `tab` меньше 10 заменены на 0.

```{r}
tab2 <- tab
tab2[tab<10] <- 0
tab2
```


## Списки {#solvlist_ta}

Дан список `list_1`:

```{r, echo = T}
list_1 = list(numbers = 1:5, letters = letters, logic = T)
list_1
```

- Найдите первый элемент списка. Ответ должен быть списком.

```{r}
list_1[1]
```

- Теперь найдите содержание первого элемента списка двумя разными способами. Ответ должен быть вектором.

```{r}
list_1[[1]]
list_1$numbers
```

Теперь возьмите первый элемент содержания первого элемента списка. Ответ должен быть вектором.

```{r}
list_1[[1]][1]
```

Создайте список `list_2`, содержащий в себе два списка `list_1` с именами `pupa` и `lupa`.

```{r}
list_2 = list(pupa = list_1, lupa = list_1)
list_2
```

Извлеките первый элемент списка, из него - второй полэлемент, а из него - третье значение
```{r}
list_2[[1]][[2]][3]
```


## Датафрейм {#solvdf_task}

- Кто является 274ым персонажем в `got` датафрейме? Из какого он дома?

```{r}
got[274, 1:2]
```

- Найдите имена всех персонажей из дома (`Allegiances`) `"Tyrell"` и `"House Tyrell"`.

```{r}
got[got$Allegiances %in% c("Tyrell", "House Tyrell"), "Name"]
```

- Создайте новый датафрейм `greyjoy_women`, который будет включать в себя только женщин Грейджоев (`"Greyjoy"`, `"House Greyjoy"`)

```{r}
greyjoy_women <- got[got$Allegiances %in% c("Greyjoy", "House Greyjoy") & got$Gender == 0, ]
greyjoy_women
```

- Сколько всего женских персонажей в книгах "Песни льда и пламени"?

```{r}
sum(got$Gender == 0)
```

- Сколько всего женских персонажей дворянского происхождения в книгах "Песни льда и пламени"?

```{r}
sum((got$Gender == 0) & (got$Nobility == 1))
```


- Поcчитатйе процентную (!) долю знати от общего числа персонажей (`Nobility`) в `Night's Watch`.

```{r}
mean(got[got$Allegiances == "Night's Watch", "Nobility"])*100
```

- Поcчитатйе процентную (!) долю знати от общего числа персонажей (`Nobility`) у `Lannister`.

```{r}
mean(got[got$Allegiances == "Lannister", "Nobility"])*100
```

- Какая из книг цикла самая кровавая? Для ответа на этот вопрос подсчитайте таблицу частот для колонки `got$Book.of.Death`:

> Это можно сделать с помощью функции `table()`, но в дальнейшем Вы узнаете и другие способы - подобная задача возникает достаточно часто.

```{r}
table(got$Book.of.Death)
```


## Создание функций {#solvtask_function}

- Создайте функцию `plus_one()`, которая принимает число и возвращает это же число + 1

```{r}
plus_one <- function(x) x+1
```

```{r, echo = T}
plus_one(41)
```

- Создайте функцию `kvadrat()` возвращающее число в квадрате

```{r}
kvadrat <- function(x) x*x
```

```{r, echo = T}
kvadrat(6)
```

- Создайте функцию `century()`, которая превращает год в век. Возможно, понадобится вспомнить, [как года переводятся в века](https://ru.wikipedia.org/wiki/Век). 

> Здесь нужно немного погуглить.

```{r}
century <- function(x) floor((x-1)/100)+1
```

```{r, echo=TRUE}
century(1999:2002)
```
- *А теперь сделайте функцию `century_roman()`, которая переводит год в век, записанный римскими цифрами!

> Здесь нужно просто немного погуглить - возможно, для создания римских цифр есть уже готовая функция?
> Прежде созданные функции можно использовать для создания новых функций!

```{r}
century_roman <- function(x) as.roman(century(x))
```

```{r, echo = TRUE }
century_roman(1999:2002)
```

- *Напишите функцию `is_prime()`, которая проверяет, является ли число простым.

> Здесь может понадобиться оператор для получения остатка от деления: `%%`. Еще может пригодиться функция `any()` - она возвращает `TRUE`, если в векторе есть хотя бы один `TRUE`

```{r}
is_prime <- function(x) !any(x%%(2:(x-1)) == 0)
``` 

```{r, echo = TRUE}
is_prime(2017)
is_prime(2019)
2019/3 #2019 делится на 3 без остатка
is_prime(2020)
```

- *Создайте функцию `monotonic()`, которая принимает возвращает `TRUE`, если значения в векторе не убывают (то есть каждое следующее - больше или равно предыдущему) или не возврастают.

```{r}
monotonic <- function(x) all(diff(x)>=0) | all(diff(x)<=0)
```

```{r, echo = TRUE}
monotonic(1:7)
monotonic(c(1:5,5:1))
monotonic(6:-1)
monotonic(c(1:5, rep(5, 10), 5:10))
```


## Семейство apply() {#solvtask_text}

- Посчитайте, в какой из 5 книг больше всего персонажей.

```{r}
apply(got[, 9:13], 2, sum)

#Без apply():

#colSums(got[, 9:13])

#Еще:

#sapply(got[,9:13], sum)
```

- Сделайте датафрейм `heroes` с персонажами, которые присутствовали во всех книгах.

```{r}
heroes <- got[apply(got[, 9:13], 1, sum) == 5, ]

heroes

#Еще

#heroes <- got[rowSums(got[, 9:13]) == 5, ]
```

- Создайте функцию `na_n()`, которая будет возвращать количество `NA` в векторе.

```{r}
na_n <- function(x) sum(is.na(x))
```

```{r, echo = TRUE}
na_n(c(NA, 3:5, NA, 2, NA))
```

- Посчитайте количество NA в каждом столбце `got`.

```{r}
apply(got, 2, na_n)
```

- Есть список `spisok`:

```{r, echo = TRUE}
spisok <- list(1:5, 0:20, 4:24, 6:3, 6:25)
```

- Посчитайте сумму каждого вектора.

```{r}
sapply(spisok, sum)
```

- А теперь длину.

```{r}
sapply(spisok, length)
```

- Напишите функцию `max_item()`, которая будет принимать на входе список, а возвращать - (первый) самый длинный его элемент.

```{r}
max_item <- function (x) spisok[[which.max(sapply(x, length))]]
```

- Теперь мы сделаем сложный список:

```{r, echo = T}
large_spisok <- list(1:3, 3:40, spisok)
```

- Посчитайте длину каждого вектора в списке, в т.ч. для списка внутри

> Для этого может понадобиться функция `rapply()`: **recursive lapply**

```{r}
rapply(large_spisok, length, how = "list")
```

## Работа с текстом {#solvtask_test}

Дан строковый вектор:

```{r, echo = TRUE}
s <- c("Я", "выучу", "R", "за", "май!")
```

- Соедините вектор в одно строковое значение `ch`

```{r}
ch <- paste(s, collapse = " ")
ch
```

- Подсчитайте количество знаков в `ch`

```{r}
nchar(ch)
```

- Следующее задание: вырезать Замая

```{r}
substr(ch, 11, 16)
```

- Превратите `ch` обратно в вектор, значения которого - отдельные слова:

```{r}
strsplit(ch, " ")[[1]]
```

- Создайте дополнительную колонку в `got` под названием `info`, в которой будет написано: 
"ИМЯ_ПЕРСОНАЖА from House ЕГО_ДОМ is dead/alive" в зависимости от его статуса

```{r}
got$info <- paste(got$Name, "from House", got$Houses, "is", got$Is.Alive)
got$info <- sprintf("%s from House %s is %s", got$Name, got$Houses, got$Is.Alive)
head(got$info)
```


- Посчитайте длину самого короткого имени в "Песни льда и пламени"?

```{r}
min(nchar(got$Name))
```

- На самом деле, функция `which.max()` выдает только индекс первого максимального значения, даже если их несколько. Это же верно для функции `which.min()`.

Напишите функцию `which.all.min()`, которая выдает индексы всех минимальных значений векторов.

```{r}
which.all.min <- function(x) (1:length(x))[x == min(x)]
```

Проверьте, что эта функция работает на длине имен персонажей:

```{r}
got[which.all.min(nchar(got$Name)),]
```


- Создайте функцию `is_anagram()`, которая будет выдавать `TRUE` если одно слово является анаграммой другого.

```{r}
a <- "tree"
b <- "erte"

is_anagram <- function(a, b) paste(sort(strsplit(a, "")[[1]]), collapse = "") == paste(sort(strsplit(b, "")[[1]]), collapse = "")
```

Проверьте, работает ли функция, на двух векторах:

```{r, echo = T}
a <- c("спаниель", "капюшон", "state")
b <- c("апельсин", "парашют", "taste")
```

> Нужно либо векторизовать функцию (сделать так, чтобы она могла принимать вектора на входе), либо использовать mapply(). Есть простой и хитрый способ векторизовать функцию - Vectorize(). Постарайтесь все-таки не использовать for, пожалуйста.

```{r}
mapply(is_anagram, a, b)
is_anagram_v <- function(a, b) {
  sapply(sapply(sapply(a,strsplit, ""), sort), paste, collapse = "") == sapply(sapply(sapply(b,strsplit, ""), sort), paste, collapse = "")
}
```

## data.table {#solvdt_task}

Найдите все битвы, в которых `attacker_king` - `Robb Stark`. 

```{r}
batdt[attacker_king == "Robb Stark"]
```

Как они заканчивались?

```{r}
batdt[attacker_king == "Robb Stark", .N, by = attacker_outcome]
```

Найдите, в битвах какого типа проигрывал `Robb Stark` как атакующий король. 

```{r}
batdt[attacker_king == "Robb Stark", .N, by = .(attacker_outcome, battle_type)]
```



## Решейпинг {#solvtask_reshape}

- Допустим, у вас есть следующий `data.table`:

```{r, echo = T}
iq <- data.table(id = 1:3, iq_before = c(98, 106, 102), iq_after = c(103, 105, 103))
```

- Превратите широкий iq в длинный iq_long с колонками `id`, `time`, `IQ`

```{r}
iq_long <- melt(iq, id.vars = 'id', variable.name = "time", value.name = "IQ")
iq_long
```

- В колонке `time` должно быть значение `before` или `after`

```{r}
iq_long[, time := gsub("iq_", "", time)]
iq_long
```

- А теперь обратно `iq_long` в широкий формат:

```{r}
dcast(iq_long, ... ~ time)
```

## Описательная статистика {#solvtask_desc}

- Вспомните все описательные статистики, которые мы прошли, и примените их на векторе `pbcdt$chol` (количество холистерина). Попытайтесь представить, как будут распределены эти данные исходя из результатов.

- Посчитайте описательные статистики 

- Создайте функцию `check_outliers()`, которая принимает как аргумент числовой вектор, а возвращает логический вектор: `TRUE` - если есть значения больше или меньше чем 3 стандартных отклонения от среднего, `FALSE` в обратнос случае. Проверьте функцию на векторе 
`pbcdt$chol`. Посчитайте количество `TRUE` в результате.

```{r}
check_outliers <- function(x) abs(x - mean(x))>3*sd(x)
sum(check_outliers(pbcdt$chol))
```

- Измените функцию `check_outliers()`, чтобы у нее появился параметр `n = ` со значением 3 по умолчанию. От этого параметра должно зависеть количество стандартных отклонений от среднего в формуле. Проверьте функцию на том же векторе и `n = 2`:

```{r}
check_outliers <- function(x, n) abs(x - mean(x))>n*sd(x)
```

```{r, echo = T}
sum(check_outliers(pbcdt$chol, n = 2))
```

- Добавим в функцию `check_outliers()` еще больше гибкости. Теперь функция сможет принимать на вход еще и функции центральной тенденции и вариабельности `central = ` и `deviation = ` со средним и стандартным отклонением по умолчанию. Проверьте функцию с помощью `n = 3`, медианой и медианным абсолютным отклонением.

```{r}
check_outliers <- function(x, n, central = mean, deviation = sd) abs(x - central(x))>n*deviation(x)
```

```{r, echo = T}
sum(check_outliers(pbcdt$chol, n = 3, median, mad))
```
- $$s^2_{pool} = \frac {(n_1-1)s^2_1 + (n_2-1)s^2_2} {(n_1 - 1) + (n_2 -1)}$$
